const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":90,\"nextId\":90,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"2#前言\",\"4\":\"2#并发\",\"5\":\"2#在计算机中的并发\",\"6\":\"2#并发与并行\",\"7\":\"2#总结\",\"8\":\"3\",\"9\":\"3#hello-world\",\"10\":\"3#当前环境支持并发线程数\",\"11\":\"3#线程管理\",\"12\":\"3#启动新线程\",\"13\":\"3#raii\",\"14\":\"3#传递参数\",\"15\":\"3#std-this-thread\",\"16\":\"3#std-thread-转移所有权\",\"17\":\"3#std-thread-的构造-源码解析\",\"18\":\"3#实现-joining-thread\",\"19\":\"3#c-20-std-jthread\",\"20\":\"3#零开销原则\",\"21\":\"3#线程停止\",\"22\":\"3#总结\",\"23\":\"3#总结-1\",\"24\":\"4\",\"25\":\"4#条件竞争\",\"26\":\"4#使用互斥量\",\"27\":\"4#std-lock-guard\",\"28\":\"4#try-lock\",\"29\":\"4#保护共享数据\",\"30\":\"4#死锁-问题与解决\",\"31\":\"4#std-unique-lock-灵活的锁\",\"32\":\"4#在不同作用域传递互斥量\",\"33\":\"4#保护共享数据的初始化过程\",\"34\":\"4#保护不常更新的数据结构\",\"35\":\"4#std-recursive-mutex\",\"36\":\"4#new、delete-是线程安全的吗\",\"37\":\"4#线程存储期\",\"38\":\"4#总结\",\"39\":\"5\",\"40\":\"5#等待事件或条件\",\"41\":\"5#线程安全的队列\",\"42\":\"5#使用-future\",\"43\":\"5#创建异步任务获取返回值\",\"44\":\"5#future-与-std-packaged-task\",\"45\":\"5#使用-std-promise\",\"46\":\"5#多个线程的等待\",\"47\":\"5#限时等待\",\"48\":\"5#时钟\",\"49\":\"5#时间段\",\"50\":\"5#时间点\",\"51\":\"5#异步任务执行\",\"52\":\"5#背景介绍\",\"53\":\"5#项目说明\",\"54\":\"5#完整代码实现\",\"55\":\"5#注意事项\",\"56\":\"5#跨平台兼容性\",\"57\":\"5#实践建议\",\"58\":\"5#c-20-信号量\",\"59\":\"5#c-20-闩与屏障\",\"60\":\"5#std-latch\",\"61\":\"5#std-barrier\",\"62\":\"5#总结\",\"63\":\"6\",\"64\":\"6#原子操作\",\"65\":\"6#原子类型-std-atomic\",\"66\":\"6#st-atomic-flag\",\"67\":\"6#std-atomic-bool\",\"68\":\"6#std-atomic-t\",\"69\":\"6#std-atomic-std-shared-ptr\",\"70\":\"6#内存次序\",\"71\":\"6#前言\",\"72\":\"7\",\"73\":\"8\",\"74\":\"8#学习注意事项\",\"75\":\"8#代码风格\",\"76\":\"8#总结\",\"77\":\"9\",\"78\":\"10\",\"79\":\"10#std-thread-的数据成员\",\"80\":\"10#std-thread-的构造函数\",\"81\":\"10#总结\",\"82\":\"11\",\"83\":\"11#std-scoped-lock-的数据成员\",\"84\":\"11#std-scoped-lock的构造与析构\",\"85\":\"11#总结\",\"86\":\"12\",\"87\":\"13\",\"88\":\"14\",\"89\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,58],\"1\":[1,19],\"2\":[1],\"3\":[1,15],\"4\":[1,7],\"5\":[1,39],\"6\":[1,23],\"7\":[1,11],\"8\":[1,9],\"9\":[2,68],\"10\":[1,228],\"11\":[1,15],\"12\":[1,299],\"13\":[1,104],\"14\":[1,226],\"15\":[1,114],\"16\":[1,109],\"17\":[1,27],\"18\":[1,96],\"19\":[1,15],\"20\":[1,52],\"21\":[1,163],\"22\":[1,19],\"23\":[1,41],\"24\":[1,16],\"25\":[1,110],\"26\":[1,84],\"27\":[1,213],\"28\":[1,58],\"29\":[1,63],\"30\":[2,208],\"31\":[1,185],\"32\":[1,99],\"33\":[1,146],\"34\":[1,84],\"35\":[1,83],\"36\":[2,97],\"37\":[1,114],\"38\":[1,46],\"39\":[1,17],\"40\":[1,185],\"41\":[1,134],\"42\":[1,53],\"43\":[1,187],\"44\":[1,198],\"45\":[1,136],\"46\":[1,111],\"47\":[1,75],\"48\":[1,122],\"49\":[1,149],\"50\":[1,116],\"51\":[1,15],\"52\":[1,64],\"53\":[1,26],\"54\":[1,123],\"55\":[1,15],\"56\":[1,24],\"57\":[1,15],\"58\":[2,167],\"59\":[2,26],\"60\":[1,62],\"61\":[1],\"62\":[1,68],\"63\":[1,11],\"64\":[1,54],\"65\":[1,302],\"66\":[1,198],\"67\":[1,152],\"68\":[1],\"69\":[1],\"70\":[1],\"71\":[1,118],\"72\":[1,22],\"73\":[1,29],\"74\":[1,58],\"75\":[1,38],\"76\":[1,9],\"77\":[1,5],\"78\":[4,32],\"79\":[1,44],\"80\":[1,267],\"81\":[1,68],\"82\":[4,32],\"83\":[1,91],\"84\":[1,159],\"85\":[1,19],\"86\":[6],\"87\":[1,2],\"88\":[1,3],\"89\":[1]},\"averageFieldLength\":[1.1777777777777778,86.03448414667243],\"storedFields\":{\"0\":{\"h\":\"现代C++并发编程教程\",\"t\":[\"本仓库用来存放 B 站课程《现代 C++ 并发编程教程》的教案、代码。\",\"不管是否购买课程，任何组织和个人遵守 CC BY-NC-ND 4.0 协议均可随意使用学习。\",\"捐赠、issues、pr 均会在致谢列表中铭记您的贡献。\",\" 国内的 C++ 并发编程的教程并不稀少，不管是书籍、博客、视频。然而大多数是粗糙的、不够准确、复杂的。而我们想以更加现代、简单、准确的方式进行教学。\",\" 我们在教学中可能常常为您展示部分标准库源码，自己手动实现一些库，这是必须的，希望您是已经较为熟练使用模板（如果没有，可以先学习 现代C++模板教程）。阅读源码可以帮助我们更轻松的理解标准库设施的使用与原理。\",\" 本教程假设开发者的最低水平为：C++11 + STL + template。\",\" 虽强调现代，但不用担心，我们几乎是从头教学，即使你从来没使用过 C++ 进行多线程编程，也不成问题。\",\" 我们希望您的编译器版本和标准尽可能的高，我们的代码均会测试三大编译器 gcc、clang、msvc。需要更高的标准会进行强调。\"]},\"1\":{\"h\":\"Summary\",\"t\":[\"首页\",\"阅读须知\",\"基本概念\",\"使用线程\",\"共享数据\",\"同步操作\",\"内存模型与原子操作\",\"协程\",\"详细分析\",\"std::thread 的构造-源码解析\",\"std::scoped_lock 的源码实现与解析\",\"std::async 与 std::future 源码解析\"]},\"2\":{\"h\":\"基本概念\"},\"3\":{\"h\":\"前言\",\"t\":[\" 在我们谈起“并发编程”，其实可以直接简单理解为“多线程编程”，我知道你或许有疑问：“那多进程呢？” C++ 语言层面没有进程的概念，并发支持库也不涉及多进程，所以在本教程中，不用在意。\",\" 我们主要使用标准 C++ 进行教学，也会稍微涉及一些其它库。\"]},\"4\":{\"h\":\"并发\",\"t\":[\"并发，指两个或两个以上的独立活动同时发生。\",\"并发在生活中随处可见，我们可以一边走路一边说话，也可以两只手同时做不同的动作，又或者一边看电视一边吃零食。\"]},\"5\":{\"h\":\"在计算机中的并发\",\"t\":[\"计算机中的并发有两种方式：\",\"多核机器的真正并行。\",\"单核机器的任务切换。\",\" 在早期，一些单核机器，它要想并发，执行多个任务，那就只能是任务切换，任务切换会给你一种“好像这些任务都在同时执行”的假象。只有硬件上是多核的，才能进行真正的并行，也就是真正的”同时执行任务“。\",\" 在现在，我们日常使用的机器，基本上是二者都有。我们现在的 CPU 基本都是多核，而操作系统调度基本也一样有任务切换，因为要执行的任务非常之多，CPU 是很快的，但是核心却没有那么多，不可能每一个任务都单独给一个核心。大家可以打开自己电脑的任务管理器看一眼，进程至少上百个，线程更是上千。这基本不可能每一个任务分配一个核心，都并行，而且也没必要。正是任务切换使得这些后台任务可以运行，这样系统使用者就可以同时运行文字处理器、编译器、编辑器和 Web 浏览器。\"]},\"6\":{\"h\":\"并发与并行\",\"t\":[\"事实上，对于这两个术语，并没有非常公认的说法。\",\"有些人认为二者毫无关系，指代的东西完全不同。\",\"有些人认为二者大多数时候是相同的，只是用于描述一些东西的时候关注点不同。\",\"我喜欢第二种，那我们就讲第二种。\",\"对多线程来说，这两个概念大部分是重叠的。对于很多人来说，它们没有什么区别。 这两个词是用来描述硬件同时执行多个任务的方式：\",\"“并行”更加注重性能。使用硬件提高数据处理速度时，会讨论程序的并行性。\",\"当关注重点在于任务分离或任务响应时，会讨论程序的并发性。\",\"这两个术语存在的目的，就是为了区别多线程中不同的关注点。\"]},\"7\":{\"h\":\"总结\",\"t\":[\" 概念从来不是我们的重点，尤其是某些说法准确性也一般，假设开发者对操作系统等知识有基本了解。\",\" 我们也不打算特别介绍什么 C++ 并发库的历史发展、什么时候你该使用多线程、什么时候不该使用多线程... 类似问题应该是看你自己的，而我们回到代码上即可。\"]},\"8\":{\"h\":\"使用线程\",\"t\":[\"在标准 C++ 中，std::thread 可以指代线程，使用线程也就是使用 std::thread 类。\"]},\"9\":{\"h\":\"Hello World\",\"t\":[\"在我们初学 C++ 的时候应该都写过这样一段代码：\",\"#include <iostream> int main(){ std::cout << \\\"Hello World!\\\" << std::endl; } \",\"这段代码将\\\"Hello World!\\\"写入到标准输出流，换行并刷新。\",\"我们可以启动一个线程来做这件事情：\",\"#include <iostream> #include <thread> // 引入线程支持头文件 void hello(){ // 定义一个函数用作打印任务 std::cout << \\\"Hello World\\\" << std::endl; } int main(){ std::thread t{ hello }; t.join(); } \",\"std::thread t{ hello }; 创建了一个线程对象 t，将 hello 作为它的可调用(Callable)对象，在新线程中执行。线程对象关联了一个线程资源，我们无需手动控制，在线程对象构造成功，就自动在新线程开始执行函数 hello。\",\"t.join(); 等待线程对象 t 关联的线程执行完毕，否则将一直堵塞。这里的调用是必须的，否则 std::thread 的析构函数将调用 std::terminate() 无法正确析构。\",\"这是因为我们创建线程对象 t 的时候就关联了一个活跃的线程，调用 join() 就是确保线程对象关联的线程已经执行完毕，然后会修改对象的状态，让 std::thread::joinable() 返回 false，表示线程对象目前没有关联活跃线程。std::thread 的析构函数，正是通过 joinable() 判断线程对象目前是否有关联活跃线程，如果为 true，那么就当做有关联活跃线程，会调用 std::terminate()。\",\"如你所见，std::thread 高度封装，其成员函数也很少，我们可以轻易的创建线程执行任务，不过，它的用法也还远不止如此，我们慢慢介绍。\"]},\"10\":{\"h\":\"当前环境支持并发线程数\",\"t\":[\"使用 hardware_concurrency 函数可以获得我们当前硬件支持的并发线程数量，它是 std::thread 的静态成员函数。\",\"#include <iostream> #include <thread> int main(){ unsigned int n = std::thread::hardware_concurrency(); std::cout << \\\"支持 \\\" << n << \\\" 个并发线程。\\\\n\\\"; } \",\"本节其实是要普及一下计算机常识，一些古老的书籍比如 csapp 应该也会提到“超线程技术”。\",\"英特尔® 超线程技术是一项硬件创新，允许在每个内核上运行多个线程。更多的线程意味着可以并行完成更多的工作。\",\"AMD 超线程技术被称为 SMT（Simultaneous Multi-Threading），它与英特尔的技术实现有所不同，不过使用类似。\",\"举个例子：一款 4 核心 8 线程的 CPU，这里的 8 线程其实是指所谓的逻辑处理器，也意味着这颗 CPU 最多可并行执行 8 个任务。\",\"我们的 hardware_concurrency() 获取的值自然也会是 8。\",\"当然了，都 2024 年了，我们还得考虑一个问题：“ 英特尔从 12 代酷睿开始，为其处理器引入了全新的“大小核”混合设计架构”。\",\"比如我的 CPU i7 13700H 它是 14 核心，20 线程，有 6 个能效核，6 个性能核。不过我们说了，物理核心这个通常不看重，hardware_concurrency() 输出的值会为 20。\",\"在进行多线程编程时，我们可以参考此值来确定创建的线程数量，以更好地利用当前硬件，从而提升程序性能。\",\"我们可以举个简单的例子运用这个值：\",\"template<typename ForwardIt> auto sum(ForwardIt first, ForwardIt last){ using value_type = std::iter_value_t<ForwardIt>; std::size_t num_threads = std::thread::hardware_concurrency(); std::ptrdiff_t distance = std::distance(first, last); if(distance > 1024000){ // 计算每个线程处理的元素数量 std::size_t chunk_size = distance / num_threads; std::size_t remainder = distance % num_threads; // 存储每个线程的结果 std::vector<value_type>results(num_threads); // 存储关联线程的线程对象 std::vector<std::thread> threads; // 创建并启动线程 auto start = first; for (std::size_t i = 0; i < num_threads; ++i) { auto end = std::next(start, chunk_size + (i < remainder ? 1 : 0)); threads.emplace_back([start, end, &results, i] { results[i] = std::accumulate(start, end, value_type{}); }); start = end; // 开始迭代器不断向前 } // 等待所有线程执行完毕 for (auto& thread : threads) thread.join(); // 汇总线程的计算结果 value_type total_sum = std::accumulate(results.begin(), results.end(), value_type{}); return total_sum; } value_type total_sum = std::accumulate(first, last, value_type{}); return total_sum; } \",\"运行测试。\",\"我们写了这样一个求和函数 sum，接受两个迭代器计算它们范围中对象的和。\",\"我们先获取了迭代器所指向的值的类型，定义了一个别名 value_type，我们这里使用到的 std::iter_value_t 是 C++20 引入的，返回类型推导是 C++14 引入。如果希望代码可以在 C++11 的环境运行也可以自行修改为：\",\"template<typename ForwardIt> typename std::iterator_traits<ForwardIt>::value_type sum(ForwardIt first, ForwardIt last); \",\"运行测试。\",\"num_threads 是当前硬件支持的并发线程的值。std::distance 用来计算 first 到 last 的距离，也就是我们要进行求和的元素个数了。\",\"我们这里的设计比较简单，毕竟是初学，所以只对元素个数大于 1024000 的进行多线程求和，而小于这个值的则直接使用标准库函数 std::accumulate 求和即可。\",\"多线程求和只需要介绍三个地方\",\"chunk_size 是每个线程分配的任务，但是这是可能有余数的，比如 10 个任务分配三个线程，必然余 1。但是我们也需要执行这个任务，所以还定义了一个对象 remainder ，它存储的就是余数。\",\"auto end = std::next(start, chunk_size + (i < remainder ? 1 : 0)); 这行代码是获取当前线程的执行范围，其实也就是要 chunk_size 再加上我们的余数 remainder 。这里写了一个三目运算符是为了进行分配任务，比如：\",\"假设有 3 个线程执行，并且余数是 2。那么，每个线程的处理情况如下：\",\"当 i = 0 时，由于 0 < 2，所以这个线程会多分配一个元素。\",\"当 i = 1 时，同样因为 1 < 2，这个线程也会多分配一个元素。\",\"当 i = 2 时，由于 2 >= 2，所以这个线程只处理平均数量的元素。\",\"这确保了剩余的 2 个元素被分配给了前两个线程，而第三个线程只处理了平均数量的元素。这样就确保了所有的元素都被正确地分配给了各个线程进行处理。\",\"auto start = first; 在创建线程执行之前先定义了一个开始迭代器。在传递给线程执行的lambda表达式中，最后一行是：start = end; 这是为了让迭代器一直向前。\",\"由于求和不涉及数据竞争之类的问题，所以我们甚至可以在刚讲完 Hello World 就手搓了一个“并行求和”的简单的模板函数。主要的难度其实在于对 C++ 的熟悉程度，而非对线程类 std::thread 的使用了，这里反而是最简单的，无非是用容器存储线程对象管理，最后进行 join() 罢了。\",\"本节代码只是为了学习，而且只是百万数据通常没必要多线程，上亿的话差不多。如果你需要多线程求和，可以使用 C++17 引入的求和算法 std::reduce 并指明执行策略。它的效率接近我们实现的 sum 的两倍，当前环境核心越多数据越多，和单线程效率差距越明显。\"]},\"11\":{\"h\":\"线程管理\",\"t\":[\"在 C++ 标准库中，没有直接管理线程的机制，只能通过对象关联线程后，通过该对象来管理线程。类 std::thread 的对象就是指代线程的对象，而我们本节说的“线程管理”，其实也就是指管理 std::thread 对象。\"]},\"12\":{\"h\":\"启动新线程\",\"t\":[\"使用 C++ 线程库启动线程，就是构造 std::thread 对象。\",\"当然了，如果是默认构造之类的，那么 std::thread 线程对象没有关联线程的，自然也不会启动线程执行任务。\",\"std::thread t; // 构造不表示线程的新 std::thread 对象 \",\"我们上一节的示例是传递了一个函数给 std::thread 对象，函数会在新线程中执行。std::thread 支持的形式还有很多，只要是可调用(Callable)对象即可，比如重载了 operator() 的类对象（也可以直接叫函数对象）。\",\"class Task{ public: void operator()()const { std::cout << \\\"operator()()const\\\\n\\\"; } }; \",\"我们显然没办法直接像函数使用函数名一样，使用“类名”，函数名可以隐式转换到指向它的函数指针，而类名可不会直接变成对象，我们想使用 Task 自然就得构造对象了\",\"std::thread t{ Task{} }; t.join(); \",\"直接创建临时对象即可，可以简化代码并避免引入不必要的局部对象。\",\"不过有件事情需要注意，当我们使用函数对象用于构造 std::thread 的时候，如果你传入的是一个临时对象，且使用的都是 “()”小括号初始化，那么编译器会将此语法解析为函数声明。\",\"std::thread t( Task() ); // 函数声明 \",\"这被编译器解析为函数声明，是一个返回类型为 std::thread，函数名为 t，接受一个返回 Task 的空参的函数指针类型，也就是 Task(*)()。\",\"之所以我们看着抽象是因为这里的形参是无名的，且写了个函数类型。\",\"我们用一个简单的示例为你展示：\",\"void h(int(int)); //#1 声明 void h(int (*p)(int)){} //#2 定义 \",\"即使我还没有为你讲述概念，我相信你也发现了，#1 和 #2 的区别无非是，#1 省略了形参的名称，还有它的形参是函数类型而不是函数指针类型，没有 *。\",\"在确定每个形参的类型后，类型是 “T 的数组”或某个函数类型 T 的形参会调整为具有类型“指向 T 的指针”。文档。\",\"显然，int(int) 是一个函数类型，它被调整为了一个指向这个函数类型的指针类型。\",\"那么回到我们最初的：\",\"std::thread t( Task() ); // #1 函数声明 std::thread t( Task (*p)() ){ return {}; } // #2 函数定义 \",\"#2我们写出了函数形参名称 p，再将函数类型写成函数指针类型，事实上完全等价。我相信，这样，也就足够了。\",\"所以总而言之，建议使用 {} 进行初始化，这是好习惯，大多数时候它是合适的。\",\"C++11 引入的 Lambda 表达式，同样可以作为构造 std::thread 的参数，因为 Lambda 本身就是生成了一个函数对象，它自身就是类类型。\",\"#include <iostream> #include <thread> int main(){ std::thread thread{ [] {std::cout << \\\"Hello World!\\\\n\\\"; } }; thread.join(); } \",\"启动线程后（也就是构造 std::thread 对象）我们必须在线程对象的生存期结束之前，即 std::thread::~thread 调用之前，决定它的执行策略，是 join()（合并）还是 detach()（分离）。\",\"我们先前使用的就是 join()，我们聊一下 detach()，当 std::thread 线程对象调用了 detach()，那么就是线程对象放弃了对线程资源的所有权，不再管理此线程，允许此线程独立的运行，在线程退出时释放所有分配的资源。\",\"放弃了对线程资源的所有权，也就是线程对象没有关联活跃线程了，此时 joinable 为 false。\",\"在单线程的代码中，对象销毁之后再去访问，会产生未定义行为，多线程增加了这个问题发生的几率。\",\"比如函数结束，那么函数局部对象的生存期都已经结束了，都被销毁了，此时线程函数还持有函数局部对象的指针或引用。\",\"#include <iostream> #include <thread> struct func { int& m_i; func(int& i) :m_i{ i } {} void operator()(int n)const { for (int i = 0; i <= n; ++i) { m_i += i; // 可能悬空引用 } } }; int main(){ int n = 0; std::thread my_thread{ func{n},100 }; my_thread.detach(); // 分离，不等待线程结束 } // 分离的线程可能还在运行 \",\"主线程（main）创建局部对象 n、创建线程对象 my_thread 启动线程，执行任务 func{n}，局部对象 n 的引用被子线程持有。传入 100 用于调用 func 的 operator(int)。\",\"my_thread.detach();，joinable() 为 false。线程分离，线程对象不再持有线程资源，线程独立的运行。\",\"主线程不等待，此时分离的子线程可能没有执行完毕，但是主线程（main）已经结束，局部对象 n 生存期结束，被销毁，而此时子线程还持有它的引用，访问悬空引用，造成未定义行为。my_thread 已经没有关联线程资源，正常析构，没有问题。\",\"解决方法很简单，将 detach() 替换为 join()。\",\"通常非常不推荐使用 detach()，因为程序员必须确保所有创建的线程正常退出，释放所有获取的资源并执行其它必要的清理操作。这意味着通过调用 detach() 放弃线程的所有权不是一种选择，因此 join 应该在所有场景中使用。 一些老式特殊情况不聊。\",\"另外提示一下，也不要想着 detach() 之后，再次调用 join()\",\"my_thread.detach(); // todo.. my_thread.join(); // 函数结束 \",\"认为这样可以确保被分离的线程在这里阻塞执行完？\",\"我们前面聊的很清楚了，detach() 是线程分离，线程对象放弃了线程资源的所有权，此时我们的 my_thread 它现在根本没有关联任何线程。调用 join() 是：“阻塞当前线程直至 *this 所标识的线程结束其执行”，我们的线程对象都没有线程，堵塞什么？执行什么呢？\",\"简单点说，必须是 std::thread 的 joinable() 为 true 即线程对象有活跃线程，才能调用 join() 和 detach()。\",\"顺带的，我们还得处理线程运行后的异常问题，举个例子：你在一个函数中构造了一个 std::thread 对象，线程开始执行，函数继续执行下面别的代码，但是如果抛出了异常呢？下面我的 join() 就会被跳过。\",\"std::thread my_thread{func{n},10}; //todo.. 抛出异常的代码 my_thread.join(); \",\"避免程序被抛出的异常所终止，在异常处理过程中调用 join()，从而避免线程对象析构产生问题。\",\"struct func; // 复用之前 void f(){ int n = 0; std::thread t{ func{n},10 }; try{ // todo.. 一些当前线程可能抛出异常的代码 f2(); } catch (...){ t.join(); // 1 throw; } t.join(); // 2 } \",\"我知道你可能有很多疑问，我们既然 catch 接住了异常，为什么还要 throw？以及为什么我们要两个 join()？\",\"这两个问题其实也算一个问题，如果代码里抛出了异常，就会跳转到 catch 的代码中，执行 join() 确保线程正常执行完成，线程对象可以正常析构。然而此时我们必须再次 throw 抛出异常，因为你要是不抛出，那么你不是还得执行一个 t.join()？显然逻辑不对，自然抛出。\",\"至于这个函数产生的异常，由调用方进行处理，我们只是确保函数 f 中创建的线程正常执行完成，其局部对象正常析构释放。测试代码。\",\"我知道你可能会想到：“我在 try 块中最后一行写一个 t.join() ，这样如果前面的代码没有抛出异常，就能正常的调用 join()，如果抛出了异常，那就调用 catch 中的 t.join() 根本不需要最外部 2 那里的 join()，也不需要再次 throw 抛出异常”\",\"void f(){ int n = 0; std::thread t{ func{n},10 }; try{ // todo.. 一些当前线程可能抛出异常的代码 f2(); t.join(); // try 最后一行调用 join() } catch (...){ t.join(); // 如果抛出异常，就在 这里调用 join() } } \",\"你是否觉得这样也可以？也没问题？简单的测试运行的确没问题。\",\"但是这是不对的，你要注意我们的注释：“一些当前线程可能抛出异常的代码”，而不是 f2()，我们的 trycatch 只是为了让线程对象关联的线程得以正确执行完毕，以及线程对象正确析构。并没有处理什么其他的东西，不掩盖错误，try块中的代码抛出了异常，catch` 接住了，我们理所应当再次抛出。\"]},\"13\":{\"h\":\"RAII\",\"t\":[\"“资源获取即初始化”(RAII，Resource Acquisition Is Initialization)。\",\"简单的说是：构造函数申请资源，析构函数释放资源，让对象的生命周期和资源绑定。当异常抛出时，C++ 会自动调用对象的析构函数。\",\"我们可以提供一个类，在析构函数中使用 join() 确保线程执行完成，线程对象正常析构。\",\"class thread_guard{ std::thread& m_t; public: explicit thread_guard(std::thread& t) :m_t{ t } {} ~thread_guard(){ std::puts(\\\"析构\\\"); // 打印日志 不用在乎 if (m_t.joinable()) { // 线程对象当前关联了活跃线程 m_t.join(); } } thread_guard(const thread_guard&) = delete; thread_guard& operator=(const thread_guard&) = delete; }; void f(){ int n = 0; std::thread t{ func{n},10 }; thread_guard g(t); f2(); // 可能抛出异常 } \",\"函数 f 执行完毕，局部对象就要逆序销毁了。因此，thread_guard 对象 g 是第一个被销毁的，调用析构函数。即使函数 f2() 抛出了一个异常，这个销毁依然会发生（前提是你捕获了这个异常）。这确保了线程对象 t 所关联的线程正常的执行完毕以及线程对象的正常析构。测试代码。\",\"如果异常被抛出但未被捕获那么就会调用 std::terminate。是否对未捕获的异常进行任何栈回溯由实现定义。（简单的说就是不一定会调用析构）\",\"我们的测试代码是捕获了异常的，为了观测，看到它一定打印“析构”。\",\"在 thread_guard 的析构函数中，我们要判断 std::thread 线程对象现在是否有关联的活跃线程，如果有，我们才会执行 join()，阻塞当前线程直到线程对象关联的线程执行完毕。如果不想等待线程结束可以使用 detach() ，但是这让 std::thread 对象失去了线程资源的所有权，难以掌控，具体如何，看情况分析。\",\"复制赋值和复制构造定义为 =delete 可以防止编译器隐式生成，同时会阻止移动构造函数和移动赋值运算符的隐式定义。这样的话，对 thread_guard 对象进行复制或赋值等操作会引发一个编译错误。\",\"不允许这些操作主要在于：这是个管理类，而且顾名思义，它就应该只是单纯的管理线程对象仅此而已，只保有一个引用，单纯的做好 RAII 的事情就行，允许其他操作没有价值。\",\"严格来说其实这里倒也不算 RAII，因为 thread_guard 的构造函数其实并没有申请资源，只是保有了线程对象的引用，在析构的时候进行了 join() 。\"]},\"14\":{\"h\":\"传递参数\",\"t\":[\"向可调用对象或函数传递参数很简单，我们前面也都写了，只需要将这些参数作为 std::thread 的构造参数即可。需要注意的是，这些参数会复制到新线程的内存空间中，即使函数中的参数是引用，依然实际是复制。\",\"void f(int, const int& a); int n = 1; std::thread t(f, 3, n); \",\"线程对象 t 的构造没有问题，可以通过编译，但是这个 n 实际上并没有按引用传递，而按值复制的。我们可以打印地址来验证我们的猜想。\",\"void f(int, const int& a) { // a 并非引用了局部对象 n std::cout << &a << '\\\\n'; } int main() { int n = 1; std::cout << &n << '\\\\n'; std::thread t(f, 3, n); t.join(); } \",\"运行代码，打印的地址截然不同。\",\"可以通过编译，但通常这不符合我们的需求，因为我们的函数中的参数是引用，我们自然希望能引用调用方传递的参数，而不是复制。如果我们的 f 的形参类型不是 const 的引用，则会产生一个编译错误。\",\"想要解决这个问题很简单，我们可以使用标准库的设施 std::ref 、 std::cref 函数模板。\",\"void f(int, int& a) { std::cout << &a << '\\\\n'; } int main() { int n = 1; std::cout << &n << '\\\\n'; std::thread t(f, 3, std::ref(n)); t.join(); } \",\"运行代码，打印地址完全相同。\",\"我们来解释一下，“ref” 其实就是 “reference”（引用）的缩写，意思也很简单，返回“引用”，当然了，不是真的返回引用，它们返回一个包装类 std::reference_wrapper，顾名思义，这个类就是包装引用对象类模板，将对象包装，可以隐式转换为被包装对象的引用。\",\"“cref”呢？，这个“c”就是“const”，就是返回了 std::reference_wrapper<const T>。我们不详细介绍他们的实现，你简单认为reference_wrapper可以隐式转换为被包装对象的引用即可，\",\"int n = 0; std::reference_wrapper<int> r = std::ref(n); int& p = r; // r 隐式转换为 n 的引用 此时 p 引用的就是 n \",\"int n = 0; std::reference_wrapper<const int> r = std::cref(n); const int& p = r; // r 隐式转换为 n 的 const 的引用 此时 p 引用的就是 n \",\"如果对他们的实现感兴趣，可以观看视频。\",\"以上代码void f(int, int&) 如果不使用 std::ref 并不会和前面 void f(int, const int&) 一样只是多了复制，而是会产生编译错误，这是因为 std::thread 内部会将保有的参数副本转换为右值表达式进行传递，这是为了那些只支持移动的类型，左值引用没办法引用右值表达式，所以产生编译错误。\",\"struct move_only { move_only() { std::puts(\\\"默认构造\\\"); } move_only(const move_only&) = delete; move_only(move_only&&)noexcept { std::puts(\\\"移动构造\\\"); } }; void f(move_only){} int main(){ move_only obj; std::thread t{ f,std::move(obj) }; t.join(); } \",\"运行测试。\",\"没有 std::ref 自然是会保有一个副本，所以有两次移动构造，一次是被 std::thread 构造函数中初始化副本，一次是调用函数 f。\",\"如果还有不理解，不用担心，记住，这一切的问题都会在后面的 std::thread 的构造-源码解析 解释清楚。\",\"成员函数指针也是可调用(Callable)的 ，可以传递给 std::thread 作为构造参数，让其关联的线程执行成员函数。\",\"struct X{ void task_run(int)const; }; X x; int n = 0; std::thread t{ &X::task_run,&x,n }; t.join(); \",\"传入成员函数指针、与其配合使用的对象、调用成员函数的参数，构造线程对象 t，启动线程。\",\"如果你是第一次见到成员指针，那么我们稍微聊一下，&X::task_run 是一个整体，它们构成了成员指针，&类名::非静态成员。\",\"成员指针必须和对象一起使用，这是唯一标准用法，成员指针不可以转换到函数指针单独使用，即使是非静态成员函数没有使用任何数据成员。\",\"我们还可以使用模板函数 std::bind与成员指针一起使用\",\"std::thread t{ std::bind(&X::task_run, &x ,n) }; \",\"不过需要注意，std::bind 也是默认按值复制的，即使我们的成员函数形参类型为引用：\",\"struct X { void task_run(int& a)const{ std::cout << &a << '\\\\n'; } }; X x; int n = 0; std::cout << &n << '\\\\n'; std::thread t{ std::bind(&X::task_run,&x,n) }; t.join(); \",\"除非给参数 n 加上 std::ref，就是按引用传递了：\",\"std::thread t{ std::bind(&X::task_run,&x,std::ref(n)) }; \",\"void f(const std::string&); std::thread t{ f,\\\"hello\\\" }; \",\"代码创建了一个调用 f(\\\"hello\\\") 的线程。注意，函数 f 实际需要的是一个 std::string 类型的对象作为参数，但这里使用的是字符串字面量，我们要明白“A的引用只能引用A，或者以任何形式转换到A”，字符串字面量的类型是 const char[N] ，它会退化成指向它的const char* 指针，被线程对象保存。在调用 f 的时候，这个指针可以通过 std::string 的转换构造函数，构造出一个临时的 std::string 对象，就能成功调用。\",\"字符串字面量具有静态存储期，指向它的指针这当然没问题了，不用担心生存期的问题，但是如果是指向“动态”对象的指针，就要特别注意了：\",\"void f(const std::string&); void test(){ char buffer[1024]{}; //todo.. code std::thread t{ f,buffer }; t.detach(); } \",\"以上代码可能导致一些问题，buffer 是一个数组对象，作为 std::thread 构造参数的传递的时候会decay-copy （确保实参在按值传递时会退化） 隐式转换为了指向这个数组的指针。\",\"我们要特别强调，std::thread 构造是代表“启动线程”，而不是调用我们传递的可调用对象。\",\"std::thread 的构造函数中调用了创建线程的函数（windows 下可能为 _beginthreadex），它将我们传入的参数，f、buffer ，传递给这个函数，在新线程中执行函数 f。也就是说，调用和执行 f(buffer) 并不是说要在 std::thread 的构造函数中，而是在创建的新线程中，具体什么时候执行，取决于操作系统的调度，所以完全有可能函数 test 先执行完，而新线程此时还没有进行 f(buffer) 的调用，转换为std::string，那么 buffer 指针就悬空了，会导致问题。解决方案：\",\"将 detach() 替换为 join()。\",\"void f(const std::string&); void test(){ char buffer[1024]{}; //todo.. code std::thread t{ f,buffer }; t.join(); } \",\"显式将 buffer 转换为 std::string。\",\"void f(const std::string&); void test(){ char buffer[1024]{}; //todo.. code std::thread t{ f,std::string(buffer) }; t.detach(); } \"]},\"15\":{\"h\":\"\",\"t\":[\"这个命名空间包含了管理当前线程的函数。\",\"yield 建议实现重新调度各执行线程。\",\"get_id 返回当前线程 id。\",\"sleep_for 使当前线程停止执行指定时间。\",\"sleep_until 使当前线程执行停止到指定的时间点。\",\"它们之中最常用的是 get_id，其次是 sleep_for，再然后 yield，sleep_until 较少。\",\"使用 get_id打印主线程和子线程的 ID。\",\"int main() { std::cout << std::this_thread::get_id() << '\\\\n'; std::thread t{ [] { std::cout << std::this_thread::get_id() << '\\\\n'; } }; t.join(); } \",\"使用 sleep_for 延时。当 Sleep 之类的就行，但是它需要接受的参数不同，是 std::chrono 命名空间中的时间对象。\",\"int main() { std::this_thread::sleep_for(std::chrono::seconds(3)); } \",\"主线程延时 3 秒，这个传入了一个临时对象 seconds ，它是模板 std::chrono::duration 的别名，以及还有很多其他的时间类型，都基于这个类。说实话挺麻烦的，如果您支持 C++14，建议使用时间字面量，在 std::chrono_literals 命名空间中。我们可以改成下面这样：\",\"using namespace std::chrono_literals; int main() { std::this_thread::sleep_for(3s); } \",\"简单直观。\",\"yield 减少 CPU 的占用。\",\"while (!isDone()){ std::this_thread::yield(); } \",\"线程需要等待某个操作完成，如果你直接用一个循环不断判断这个操作是否完成就会使得这个线程占满 CPU 时间，这会造成资源浪费。此时可以判断操作是否完成，如果还没完成就调用 yield 交出 CPU 时间片让其他线程执行，过一会儿再来判断是否完成，这样这个线程占用 CPU 时间会大大减少。\",\"使用 sleep_until 让当前线程延迟到具体的时间。我们延时 5 秒就是。\",\"int main() { // 获取当前时间点 auto now = std::chrono::system_clock::now(); // 设置要等待的时间点为当前时间点之后的5秒 auto wakeup_time = now + 5s; // 输出当前时间 auto now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Current time:\\\\t\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\") << std::endl; // 输出等待的时间点 auto wakeup_time_time = std::chrono::system_clock::to_time_t(wakeup_time); std::cout << \\\"Waiting until:\\\\t\\\\t\\\" << std::put_time(std::localtime(&wakeup_time_time), \\\"%H:%M:%S\\\") << std::endl; // 等待到指定的时间点 std::this_thread::sleep_until(wakeup_time); // 输出等待结束后的时间 now = std::chrono::system_clock::now(); now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Time after waiting:\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\") << std::endl; } \",\"sleep_until 本身设置使用很简单，是打印时间格式、设置时区麻烦。运行结果。\",\"介绍了一下 std::this_thread 命名空间中的四个函数的基本用法，我们后续会经常看到这些函数的使用，不用着急。\"]},\"16\":{\"h\":\"转移所有权\",\"t\":[\"传入可调用对象以及参数，构造 std::thread 对象，启动线程，而线程对象拥有了线程的所有权，线程是一种系统资源，所以可称作“线程资源”。\",\"std::thread 不可复制。两个 std::thread 对象不可表示一个线程，std::thread 对线程资源是独占所有权。而移动操作可以将一个 std::thread 对象的线程资源所有权转移给另一个 std::thread 对象。\",\"int main() { std::thread t{ [] { std::cout << std::this_thread::get_id() << '\\\\n'; } }; std::cout << t.joinable() << '\\\\n'; // 线程对象 t 当前关联了活跃线程 打印 1 std::thread t2{ std::move(t) }; // 将 t 的线程资源的所有权移交给 t2 std::cout << t.joinable() << '\\\\n'; // 线程对象 t 当前没有关联活跃线程 打印 0 //t.join(); // Error! t 没有线程资源 t2.join(); // t2 当前持有线程资源 } \",\"这段代码通过移动构造转移了线程对象 t 的线程资源所有权到 t2，这里虽然有两个 std::thread 对象，但是从始至终只有一个线程资源，让持有线程资源的 t2 对象最后调用 join() 堵塞让其线程执行完毕。t 与 t2 都能正常析构。\",\"我们还可以使用移动赋值来转移线程资源的所有权：\",\"int main() { std::thread t; // 默认构造，没有关联活跃线程 std::cout << t.joinable() << '\\\\n'; // 0 std::thread t2{ [] {} }; t = std::move(t2); // 转移线程资源的所有权到 t std::cout << t.joinable() << '\\\\n'; // 1 t.join(); t2 = std::thread([] {}); t2.join(); } \",\"我们只需要介绍 t2 = std::thread([] {}) ，临时对象是右值表达式，不用调用 std::move，这里相当于是将临时的 std::thread 对象所持有的线程资源转移给 t2，t2 再调用 join() 正常析构。\",\"函数返回 std::thread 对象：\",\"std::thread f(){ std::thread t{ [] {} }; return t; } int main(){ std::thread rt = f(); rt.join(); } \",\"这段代码可以通过编译，你是否感到奇怪？我们在函数 f 中创建了一个局部的 std::thread 对象，启动线程，然后返回它。\",\"这里的 return t重载决议[1]选择到了移动构造，将 t 线程资源的所有权转移给函数调用 f() 返回的临时 std::thread 对象中，然后这个临时对象再用来初始化 rt ，临时对象是右值表达式，这里一样选择到移动构造，将临时对象的线程资源所有权移交给 rt。此时 rt 具有线程资源的所有权，由它调用 join() 正常析构。\",\"如果标准达到 C++17，强制的复制消除（RVO）保证这里少一次移动构造的开销（临时对象初始化 rt 的这次）。\",\"所有权也可以在函数内部传递：\",\"void f(std::thread t){ t.join(); } int main(){ std::thread t{ [] {} }; f(std::move(t)); f(std::thread{ [] {} }); } \",\"std::move 将 t 转换为了一个右值表达式，初始化函数f 形参 t，选择到了移动构造转移线程资源的所有权，在函数中调用 t.join() 后正常析构。std::thread{ [] {} } 构造了一个临时对象，本身就是右值表达式，初始化函数f 形参 t，移动构造转移线程资源的所有权到 t，t.join() 后正常析构。\",\"本节内容总体来说是很简单的，如果你有些地方无法理解，那只有一种可能，“对移动语义不了解”，不过这也不是问题，在后续我们详细介绍 std::thread 构造函数的源码即可，不用着急。\"]},\"17\":{\"h\":\"\",\"t\":[\"我们上一个大节讲解了线程管理，也就是 std::thread 的使用，其中的重中之重就是它的构造，传递参数。我们用源码实现为各位从头讲解。\",\"了解其实现，才能更好的使用它，同时也能解释其使用与学习中的各种问题。如：\",\"为什么默认按值复制？\",\"为什么需要 std::ref ？\",\"如何支持只能移动的对象？\",\"如何做到接受任意可调用对象？\",\"如何创建的线程？\",\"传递参数一节中的：“std::thread 内部会将保有的参数副本转换为右值表达式进行传递”到底是如何做到的？\",\"当你看完 std::thread 的构造-源码解析 后，可以再回过头来问问自己是否能够回答这些问题。\"]},\"18\":{\"h\":\"实现\",\"t\":[\"这个类和 std::thread 的区别就是析构函数会自动 join 。如果您好好的学习了上一节的内容，阅读了 std::thread 的源码，以下内容不会对您构成任何的难度。\",\"我们存储一个 std::thread 作为底层数据成员，稍微注意一下构造函数和赋值运算符的实现即可。\",\"class joining_thread { std::thread t; public: joining_thread()noexcept = default; template<typename Callable, typename... Args> explicit joining_thread(Callable&& func, Args&&...args) : t{ std::forward<Callable>(func), std::forward<Args>(args)... } {} explicit joining_thread(std::thread t_)noexcept : t{ std::move(t_) } {} joining_thread(joining_thread&& other)noexcept : t{ std::move(other.t) } {} joining_thread& operator=(std::thread&& other)noexcept { if (joinable()) { // 如果当前有活跃线程，那就先执行完 join(); } t = std::move(other); return *this; } ~joining_thread() { if (joinable()) { join(); } } void swap(joining_thread& other)noexcept { t.swap(other.t); } std::thread::id get_id()const noexcept { return t.get_id(); } bool joinable()const noexcept { return t.joinable(); } void join() { t.join(); } void detach() { t.detach(); } std::thread& data()noexcept { return t; } const std::thread& data()const noexcept { return t; } }; \",\"简单使用一下：\",\"int main(){ std::cout << std::this_thread::get_id() << '\\\\n'; joining_thread thread{[]{ std::cout << std::this_thread::get_id() << '\\\\n'; } }; joining_thread thread2{ std::move(thread) }; } \",\"使用容器管理线程对象，等待线程执行结束：\",\"void do_work(std::size_t id){ std::cout << id << '\\\\n'; } int main(){ std::vector<std::thread>threads; for (std::size_t i = 0; i < 10; ++i){ threads.emplace_back(do_work, i); // 产生线程 } for(auto& thread:threads){ thread.join(); // 对每个线程对象调用 join() } } \",\"运行测试。\",\"线程对象代表了线程，管理线程对象也就是管理线程，这个 vector 对象管理 10 个线程，保证他们的执行、退出。\",\"使用我们这节实现的 joining_thread 则不需要最后的循环 join()：\",\"int main(){ std::vector<joining_thread>threads; for (std::size_t i = 0; i < 10; ++i){ threads.emplace_back(do_work, i); } } \",\"运行测试。\",\"如果你自己编译了这些代码，相信你注意到了，打印的是乱序的，没什么规律，而且重复运行的结果还不一样，这是正常现象。多线程执行就是如此，无序且操作可能被打断。使用互斥量可以解决这些问题，这也就是下一章节的内容了。\"]},\"19\":{\"h\":\"C++20\",\"t\":[\"std::jthread 相比于 C++11 引入的 std::thread，只是多了两个功能：\",\"RAII 管理：在析构时自动调用 join()。\",\"线程停止功能：线程的取消/停止。\"]},\"20\":{\"h\":\"零开销原则\",\"t\":[\"我知道你肯定有疑问，为什么 C++20 不直接为 std::thread 增加这两个功能，而是创造一个新的线程类型呢？\",\"这就是 C++ 的设计哲学，零开销原则：你不需要为你没有用到的（特性）付出额外的开销。\",\"std::jthread 的通常实现就是单纯的保有 std::thread + std::stop_source 这两个数据成员：\",\"thread _Impl; stop_source _Ssource; \",\"MSVC STL、libstdc++、libc++ 均是如此。\",\"stop_source 通常占 8 字节，先前 std::thread 源码解析详细聊过其不同标准库对其保有的成员不同，简单来说也就是 64 位环境，大小为 16 或者 8。也就是 sizeof(std::jthread) 的值相比 std::thread 会多 8 ，为 24 或 16。\",\"引入 std::jthread 符合零开销原则，它通过创建新的类型提供了更多的功能，而没有影响到原来 std::thread 的性能和内存占用。\"]},\"21\":{\"h\":\"线程停止\",\"t\":[\"第一个功能很简单，不用赘述，我们直接聊这个所谓的“线程停止”就好。\",\"首先要明确，C++ 的 std::jthread 提供的线程停止功能并不同于常见的 POSIX 函数 pthread_cancel。pthread_cancel 是一种发送取消请求的函数，但并不是强制性的线程终止方式。目标线程的可取消性状态和类型决定了取消何时生效。当取消被执行时，进行清理和终止线程[2]。\",\"std::jthread 所谓的线程停止只是一种基于用户代码的控制机制，而不是一种与操作系统系统有关系的线程终止。使用 std::stop_source 和 std::stop_token 提供了一种优雅地请求线程停止的方式，但实际上停止的决定和实现都由用户代码来完成。\",\"using namespace std::literals::chrono_literals; void f(std::stop_token stop_token, int value){ while (!stop_token.stop_requested()){ // 检查是否已经收到停止请求 std::cout << value++ << ' ' << std::flush; std::this_thread::sleep_for(200ms); } std::cout << std::endl; } int main(){ std::jthread thread{ f, 1 }; // 打印 1..15 大约 3 秒 std::this_thread::sleep_for(3s); // jthread 的析构函数调用 request_stop() 和 join()。 } \",\"运行测试。截止目前（2024/5/29 clang19 未发布） libc++ 不完全支持 std::jthread，建议使用 clang 的开发者链接 libstdc++ 或 MSVC STL 进行编译。如果非要使用 libc++，可以添加 -fexperimental-library 编译选项，启用不稳定库功能和实验库功能。这样，我们的这段代码就可以通过编译。\",\"std::jthread 提供了三个成员函数进行所谓的线程停止：\",\"get_stop_source：返回与 jthread 对象关联的 std::stop_source，允许从外部请求线程停止。\",\"get_stop_token：返回与 jthread 对象停止状态[3]关联的 std::stop_token，允许检查是否有停止请求。\",\"request_stop：请求线程停止。\",\"上面这段代码并未出现这三个函数的任何一个调用，不过在 jthread 的析构函数中，会调用 request_stop 请求线程停止。\",\"void _Try_cancel_and_join() noexcept { if (_Impl.joinable()) { _Ssource.request_stop(); _Impl.join(); } } ~jthread() { _Try_cancel_and_join(); } \",\"至于 std::jthread thread{ f, 1 }; 函数 f 的 std::stop_token 的形参是谁传递的？其实就是线程对象自己调用 get_token() 传递的 ，源码一眼便可发现：\",\"template <class _Fn, class... _Args, enable_if_t<!is_same_v<remove_cvref_t<_Fn>, jthread>, int> = 0> _NODISCARD_CTOR_JTHREAD explicit jthread(_Fn&& _Fx, _Args&&... _Ax) { if constexpr (is_invocable_v<decay_t<_Fn>, stop_token, decay_t<_Args>...>) { _Impl._Start(_STD forward<_Fn>(_Fx), _Ssource.get_token(), _STD forward<_Args>(_Ax)...); } else { _Impl._Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...); } } \",\"也就是说虽然最初的那段代码看似什么都没调用，但是实际什么都调用了。这所谓的线程停止，其实简单来说，有点像外部给线程传递信号一样。\",\"std::stop_source：\",\"这是一个可以发出停止请求的类型。当你调用 stop_source 的 request_stop() 方法时，它会设置内部的停止状态为“已请求停止”。\",\"任何持有与这个 stop_source 关联的 std::stop_token 对象都能检查到这个停止请求。\",\"std::stop_token：\",\"这是一个可以检查停止请求的类型。线程内部可以定期检查 stop_token 是否收到了停止请求。\",\"通过调用 stop_token.stop_requested()，线程可以检测到停止状态是否已被设置为“已请求停止”。\"]},\"22\":{\"h\":\"\",\"t\":[\"零开销原则应当很好理解。我们本节的难点只在于使用到了一些 MSVC STL 的源码实现来配合理解，其主要在于“线程停止”。线程停止设施你会感觉是一种类似与外部与线程进行某种信号通信的设施，std::stop_source 和 std::stop_token 都与线程对象关联，然后来管理函数到底如何执行。\",\"我们并没有举很多的例子，我们觉得这一个小例子所牵扯到的内容也就足够了，关键在于理解其设计与概念。\"]},\"23\":{\"h\":\"总结\",\"t\":[\"本章节的内容围绕着：“使用线程”，也就是\\\"使用 std::thread\\\"展开， std::thread 是我们学习 C++ 并发支持库的重中之重，本章的内容在市面上并不少见，但是却是少有的准确与完善。即使你早已学习乃至使用 C++ 标准库进行多线程编程，我相信本章也一定可以让你收获良多。\",\"如果是第一次学习本章的内容，能会有一些难以理解的地方。建议你多思考、多记忆，并在以后反复查看和实践。\",\"我尽量以简单通俗的方式进行讲解。学完本章后，你可能还无法在实际环境利用多线程提升程序效率，至少还需要学习到使用互斥量来保护共享数据，才能实际应用多线程编程。\",\"重载决议简单来说就是编译器必须要根据规则选择最合适的函数重载进行调用。 ↩︎\",\"注：通常需要线程执行的函数中有一些系统调用，设置取消点，线程会在那个调用中结束。 ↩︎\",\"注：“停止状态”指的是由 std::stop_source 和 std::stop_token 管理的一种标志，用于通知线程应该停止执行。这种机制不是强制性的终止线程，而是提供一种线程内外都能检查和响应的信号。 ↩︎\"]},\"24\":{\"h\":\"共享数据\",\"t\":[\"本章节主要内容：\",\"多线程共享数据的问题\",\"使用互斥量保护共享数据\",\"保护共享数据的其它方案\",\"在上一章内容，我们对于线程的基本使用和管理，可以说已经比较了解了，甚至深入阅读了部分的 std::thread 源码。所以如果你好好学习了上一章，本章也完全不用担心。\",\"我们本章，就要开始聊共享数据的那些事。\"]},\"25\":{\"h\":\"条件竞争\",\"t\":[\"在多线程的情况下，每个线程都抢着完成自己的任务。在大多数情况下，即使会改变执行顺序，也是良性竞争，这是无所谓的。比如两个线程都要往标准输出输出一段字符，谁先谁后并不会有什么太大影响。\",\"void f() { std::cout << \\\"❤️\\\\n\\\"; } void f2() { std::cout << \\\"😢\\\\n\\\"; } int main(){ std::thread t{ f }; std::thread t2{ f2 }; t.join(); t2.join(); } \",\"std::cout 的 operator<< 调用是线程安全的，不会被打断。即：同步的 C++ 流保证是线程安全的（从多个线程输出的单独字符可能交错，但无数据竞争）\",\"只有在涉及多线程读写相同共享数据的时候，才会导致“恶性的条件竞争”。\",\"std::vector<int>v; void f() { v.emplace_back(1); } void f2() { v.erase(v.begin()); } int main() { std::thread t{ f }; std::thread t2{ f2 }; t.join(); t2.join(); std::cout << v.size() << '\\\\n'; } \",\"比如这段代码就是典型的恶性条件竞争，两个线程共享一个 vector，并对它进行修改。可能导致许多问题，比如 f2 先执行，此时 vector 还没有元素，导致抛出异常。又或者 f 执行了一半，调用了 f2()，等等。\",\"当然了，也有可能先执行 f，然后执行 f2，最后打印了 0，程序老老实实执行完毕。\",\"但是我们显然不能寄希望于这种操作系统的调度。\",\"而且即使不是一个添加元素，一个删除元素，全是 emplace_back 添加元素，也一样会有问题，由于 std::vector 不是线程安全的容器，因此当多个线程同时访问并修改 v 时，可能会发生未定义的行为。具体来说，当两个线程同时尝试向 v 中添加元素时，但是 emplace_back 函数却是可以被打断的，执行了一半，又去执行另一个线程。可能会导致数据竞争，从而引发未定义的结果。\",\"当某个表达式的求值写入某个内存位置，而另一求值读或修改同一内存位置时，称这些表达式冲突。拥有两个冲突的求值的程序就有数据竞争，除非\",\"两个求值都在同一线程上，或者在同一信号处理函数中执行，或\",\"两个冲突的求值都是原子操作（见 std::atomic），或\",\"一个冲突的求值发生早于 另一个（见 std::memory_order）\",\"如果出现数据竞争，那么程序的行为未定义。\",\"标量类型等都同理，有数据竞争，未定义行为：\",\"int cnt = 0; auto f = [&]{cnt++;}; std::thread t1{f}, t2{f}, t3{f}; // 未定义行为 \"]},\"26\":{\"h\":\"使用互斥量\",\"t\":[\"互斥量（Mutex），又称为互斥锁（或者直接被称作“锁”），是一种用来保护临界区[1]的特殊对象，其相当于实现了一个公共的“标志位”。它可以处于锁定（locked）状态，也可以处于解锁（unlocked）状态：\",\"如果互斥量是锁定的，通常说某个特定的线程正持有这个锁。\",\"如果没有线程持有这个互斥量，那么这个互斥量就处于解锁状态。\",\"概念从来不是我们的重点，用一段对比代码为你直观的展示互斥量的作用：\",\"void f() { std::cout << std::this_thread::get_id() << '\\\\n'; } int main() { std::vector<std::thread> threads; for (std::size_t i = 0; i < 10; ++i) threads.emplace_back(f); for (auto& thread : threads) thread.join(); } \",\"这段代码你多次运行它会得到毫无规律和格式的结果，我们可以使用互斥量解决这个问题：\",\"#include <mutex> // 必要标头 std::mutex m; void f() { m.lock(); std::cout << std::this_thread::get_id() << '\\\\n'; m.unlock(); } int main() { std::vector<std::thread>threads; for (std::size_t i = 0; i < 10; ++i) threads.emplace_back(f); for (auto& thread : threads) thread.join(); } \",\"当多个线程执行函数 f 的时候，只有一个线程能成功调用 lock() 给互斥量上锁，其他所有的线程 lock() 的调用将阻塞执行，直至获得锁。第一个调用 lock() 的线程得以继续往下执行，执行我们的 std::cout 输出语句，不会有任何其他的线程打断这个操作。直到线程执行 unlock()，就解锁了互斥量。\",\"那么其他线程此时也就能再有一个成功调用 lock...\",\"至于到底哪个线程才会成功调用，这个是由操作系统调度决定的。\",\"看一遍描述就可以了，简而言之，被 lock() 和 unlock() 包含在其中的代码是线程安全的，同一时间只有一个线程执行，不会被其它线程的执行所打断。\"]},\"27\":{\"h\":\"\",\"t\":[\"不过一般不推荐这样显式的 lock() 与 unlock()，我们可以使用 C++11 标准库引入的“管理类” std::lock_guard：\",\"void f() { std::lock_guard<std::mutex>lc{ m }; std::cout << std::this_thread::get_id() << '\\\\n'; } \",\"那么问题来了，std::lock_guard 是如何做到的呢？它是怎么实现的呢？首先顾名思义，这是一个“管理类”模板，用来管理互斥量的上锁与解锁，我们来看它在 MSVC STL 的实现：\",\"_EXPORT_STD template <class _Mutex> class _NODISCARD_LOCK lock_guard { // class with destructor that unlocks a mutex public: using mutex_type = _Mutex; explicit lock_guard(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock _MyMutex.lock(); } lock_guard(_Mutex& _Mtx, adopt_lock_t) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don't lock ~lock_guard() noexcept { _MyMutex.unlock(); } lock_guard(const lock_guard&) = delete; lock_guard& operator=(const lock_guard&) = delete; private: _Mutex& _MyMutex; }; \",\"这段代码极其简单，首先管理类，自然不可移动不可复制，我们定义复制构造与复制赋值为弃置函数，同时阻止了移动等函数的隐式定义。\",\"它只保有一个私有数据成员，一个引用，用来引用互斥量。\",\"构造函数中初始化这个引用，同时上锁，析构函数中解锁，这是一个非常典型的 RAII 式的管理。\",\"同时它还提供一个有额外std::adopt_lock_t参数的构造函数 ，如果使用这个构造函数，则构造函数不会上锁。\",\"所以有的时候你可能会看到一些这样的代码：\",\"void f(){ //code.. { std::lock_guard<std::mutex> lc{ m }; // 涉及共享资源的修改的代码... } //code.. } \",\"使用 {} 创建了一个块作用域，限制了对象 lc 的生存期，进入作用域构造 lock_guard 的时候上锁（lock），离开作用域析构的时候解锁（unlock）。\",\"我们要尽可能的让互斥量上锁的粒度小，只用来确保必须的共享资源的线程安全。\",\"“粒度”通常用于描述锁定的范围大小，较小的粒度意味着锁定的范围更小，因此有更好的性能和更少的竞争。\",\"我们举一个例子：\",\"std::mutex m; void add_to_list(int n, std::list<int>& list) { std::vector<int> numbers(n + 1); std::iota(numbers.begin(), numbers.end(), 0); int sum = std::accumulate(numbers.begin(), numbers.end(), 0); { std::lock_guard<std::mutex> lc{ m }; list.push_back(sum); } } void print_list(const std::list<int>& list){ std::lock_guard<std::mutex> lc{ m }; for(const auto& i : list){ std::cout << i << ' '; } std::cout << '\\\\n'; } \",\"std::list<int> list; std::thread t1{ add_to_list,i,std::ref(list) }; std::thread t2{ add_to_list,i,std::ref(list) }; std::thread t3{ print_list,std::cref(list) }; std::thread t4{ print_list,std::cref(list) }; t1.join(); t2.join(); t3.join(); t4.join(); \",\"完整代码测试。\",\"先看 add_to_list，只有 list.push_back(sum) 涉及到了对共享数据的修改，需要进行保护，我们用 {} 包起来了。\",\"假设有线程 A、B执行函数 add_to_list() ：线程 A 中的 numbers、sum 与线程 B 中的，不是同一个，希望大家分清楚，自然不存在数据竞争，也不需要上锁。线程 A、B执行完了前面求 0-n 的计算，只有一个线程能在 lock_guard 的构造函数中成功调用 lock() 给互斥量上锁。假设线程 A 成功调用 lock()，那么线程 B 的 lock() 调用就阻塞了，必须等待线程 A 执行完里面的代码，然后作用域结束，调用 lock_guard 的析构函数，解锁 unlock()，此时线程 B 就可以进去执行了，避免了数据竞争，不存在一个对象同时被多个线程修改。\",\"函数 print_list() 就更简单了，打印 list，给整个函数上锁，同一时刻只能有一个线程执行。\",\"我们的使用代码是多个线程执行这两个函数，两个函数共享了一个锁，这样确保了当执行函数 print_list() 打印的时候，list 的状态是确定的。打印函数 print_list 和 add_to_list 函数的修改操作同一时间只能有一个线程在执行。print_list() 不可能看到正在被add_to_list() 修改的 list。\",\"至于到底哪个函数哪个线程会先执行，执行多少次，这些都由操作系统调度决定，也完全有可能连续 4 次都是执行函数 print_list 的线程成功调用 lock，会打印出了一样的值，这都很正常。\",\"C++17 添加了一个新的特性，类模板实参推导， std::lock_guard 可以根据传入的参数自行推导，而不需要写明模板类型参数：\",\"std::mutex m; std::lock_guard lc{ m }; // std::lock_guard<std::mutex> \",\"并且 C++17 还引入了一个新的“管理类”：std::scoped_lock，它相较于 lock_guard的区别在于，它可以管理多个互斥量。不过对于处理一个互斥量的情况，它和 lock_guard 几乎完全相同。\",\"std::mutex m; std::scoped_lock lc{ m }; // std::scoped_lock<std::mutex> \",\"我们在后续管理多个互斥量，会详细了解这个类。\"]},\"28\":{\"h\":\"\",\"t\":[\"try_lock 是互斥量中的一种尝试上锁的方式。与常规的 lock 不同，try_lock 会尝试上锁，但如果锁已经被其他线程占用，则不会阻塞当前线程，而是立即返回。\",\"它的返回类型是 bool ，如果上锁成功就返回 true，失败就返回 false。\",\"这种方法在多线程编程中很有用，特别是在需要保护临界区的同时，又不想线程因为等待锁而阻塞的情况下。\",\"std::mutex mtx; void thread_function(int id) { // 尝试加锁 if (mtx.try_lock()) { std::cout << \\\"线程：\\\" << id << \\\" 获得锁\\\" << std::endl; // 临界区代码 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 模拟临界区操作 mtx.unlock(); // 解锁 std::cout << \\\"线程：\\\" << id << \\\" 释放锁\\\" << std::endl; } else { std::cout << \\\"线程：\\\" << id << \\\" 获取锁失败 处理步骤\\\" << std::endl; } } \",\"如果有两个线程运行这段代码，必然有一个线程无法成功上锁，要走 else 的分支。\",\"std::thread t1(thread_function, 1); std::thread t2(thread_function, 2); t1.join(); t2.join(); \",\"可能的运行结果：\",\"线程：1 获得锁 线程：2 获取锁失败 处理步骤 线程：1 释放锁 \"]},\"29\":{\"h\":\"保护共享数据\",\"t\":[\"互斥量主要也就是为了保护共享数据，上一节的使用互斥量也已经为各位展示了一些。\",\"然而使用互斥量来保护共享数据也并不是在函数中加上一个 std::lock_guard 就万事大吉了。有的时候只需要一个指针或者引用，就能让这种保护形同虚设。\",\"class Data{ int a{}; std::string b{}; public: void do_something(){ // 修改数据成员等... } }; class Data_wrapper{ Data data; std::mutex m; public: template<class Func> void process_data(Func func){ std::lock_guard<std::mutex> lc{m}; func(data); // 受保护数据传递给函数 } }; Data* p = nullptr; void malicious_function(Data& protected_data){ p = &protected_data; // 受保护的数据被传递 } Data_wrapper d; void foo(){ d.process_data(malicious_function); // 传递了一个恶意的函数 p->do_something(); // 在无保护的情况下访问保护数据 } \",\"成员函数模板 process_data 看起来一点问题也没有，使用 std::lock_guard 对数据做了保护，但是调用方传递了 malicious_function 这样一个恶意的函数，使受保护数据传递给外部，可以在没有被互斥量保护的情况下调用 do_something()。\",\"我们传递的函数就不该是涉及外部副作用的，就应该是单纯的在受互斥量保护的情况下老老实实调用 do_something() 操作受保护的数据。\",\"简而言之：切勿将受保护数据的指针或引用传递到互斥量作用域之外，不然保护将形同虚设。\",\"process_data 的确算是没问题，用户非要做这些事情也是防不住的，我们只是告诉各位可能的情况。\"]},\"30\":{\"h\":\"死锁：问题与解决\",\"t\":[\"试想一下，有一个玩具，这个玩具有两个部分，必须同时拿到两部分才能玩。比如一个遥控汽车，需要遥控器和玩具车才能玩。有两个小孩，他们都想玩这个玩具。当其中一个小孩拿到了遥控器和玩具车时，就可以尽情玩耍。当另一个小孩也想玩，他就得等待另一个小孩玩完才行。再试想，遥控器和玩具车被放在两个不同的地方，并且两个小孩都想要玩，并且一个拿到了遥控器，另一个拿到了玩具车。问题就出现了，除非其中一个孩子决定让另一个先玩，他把自己的那个部分给另一个小孩。但如果他们都不愿意，那么这个遥控汽车就谁都没有办法玩。\",\"我们当然不在乎小孩抢玩具，我们要聊的是线程对锁的竞争：两个线程需要对它们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个线程的互斥量解锁。因为它们都在等待对方释放互斥量，没有线程工作。 这种情况就是死锁。\",\"多个互斥量才可能遇到死锁问题。\",\"避免死锁的一般建议是让两个互斥量以相同的顺序上锁，总在互斥量 B 之前锁住互斥量 A，就通常不会死锁。反面示例\",\"std::mutex m1,m2; std::size_t n{}; void f(){ std::lock_guard<std::mutex> lc1{ m1 }; std::lock_guard<std::mutex> lc2{ m2 };; ++n; } void f2() { std::lock_guard<std::mutex> lc1{ m2 }; std::lock_guard<std::mutex> lc2{ m1 }; ++n; } \",\"f 与 f2 因为互斥量上锁顺序不同，就有死锁风险。函数 f 先锁定 m1，然后再尝试锁定 m2，而函数 f2 先锁定 m2 再锁定 m1 。如果两个线程同时运行，它们就可能会彼此等待对方释放其所需的锁，从而造成死锁。\",\"简而言之，有可能函数 f 锁定了 m1，函数 f2 锁定了 m2，函数 f 要往下执行，给 m2 上锁，所以在等待 f2 解锁 m2，然而函数 f2 也在等待函数 f 解锁 m1 它才能往下执行。所以死锁。测试代码。\",\"但是有的时候即使固定锁顺序，依旧会产生问题。当有多个互斥量保护同一个类的对象时，对于相同类型的两个不同对象进行数据的交换操作，为了保证数据交换的正确性，就要避免其它线程修改，确保每个对象的互斥量都锁住自己要保护的区域。如果按照前面的的选择一个固定的顺序上锁解锁，则毫无意义，比如：\",\"struct X{ X(const std::string& str) :object{ str } {} friend void swap(X& lhs, X& rhs); private: std::string object; std::mutex m; }; void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::lock_guard<std::mutex> lock1{ lhs.m }; std::lock_guard<std::mutex> lock2{ rhs.m }; swap(lhs.object, rhs.object); } \",\"考虑用户调用的时候将参数交换，就会产生死锁：\",\"X a{ \\\"🤣\\\" }, b{ \\\"😅\\\" }; std::thread t{ [&] {swap(a, b); } }; // 1 std::thread t2{ [&] {swap(b, a); } }; // 2 \",\"1 执行的时候，先上锁 a 的互斥量，再上锁 b 的互斥量。\",\"2 执行的时候，先上锁 b 的互斥量，再上锁 a 的互斥量。\",\"完全可能线程 A 执行 1 的时候上锁了 a 的互斥量，线程 B 执行 2 上锁了 b 的互斥量。线程 A 往下执行需要上锁 b 的互斥量，线程 B 则要上锁 a 的互斥量执行完毕才能解锁，哪个都没办法往下执行，死锁。测试代码。\",\"其实也就是回到了第一个示例的问题。\",\"C++ 标准库有很多办法解决这个问题，可以使用 std::lock ，它能一次性锁住多个互斥量，并且没有死锁风险。修改 swap 代码后如下：\",\"void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::lock(lhs.m, rhs.m); // 给两个互斥量上锁 std::lock_guard<std::mutex> lock1{ lhs.m,std::adopt_lock }; std::lock_guard<std::mutex> lock2{ rhs.m,std::adopt_lock }; swap(lhs.object, rhs.object); } \",\"因为前面已经使用了 std::lock 上锁，所以后的 std::lock_guard 构造都额外传递了一个 std::adopt_lock 参数，让其选择到不上锁的构造函数。函数退出也能正常解锁。\",\"std::lock 给 lhs.m 或 rhs.m 上锁时若抛出异常，则在重抛前对任何已锁的对象调用 unlock() 解锁，也就是 std::lock 要么将互斥量都上锁，要么一个都不锁。\",\"C++17 新增了 std::scoped_lock ，提供此函数的 RAII 包装，通常它比裸调用 std::lock 更好。\",\"所以我们前面的代码可以改写为：\",\"void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::scoped_lock guard{ lhs.m,rhs.m }; swap(lhs.object, rhs.object); } \",\"对此类有兴趣或任何疑问，建议阅读std::scoped_lock 的源码实现与解析\",\"使用 std::scoped_lock 可以将所有 std::lock 替换掉，减少错误发生。\",\"然而它们的帮助都是有限的，一切最终都是依靠开发者使用与管理。\",\"死锁是多线程编程中令人相当头疼的问题，并且死锁经常是不可预见，甚至难以复现，因为在大部分时间里，程序都能正常完成工作。我们可以通过一些简单的规则，约束开发者的行为，帮助写出“无死锁”的代码。\",\"避免嵌套锁\",\"线程获取一个锁时，就别再获取第二个锁。每个线程只持有一个锁，自然不会产生死锁。如果必须要获取多个锁，使用 std::lock 。\",\"避免在持有锁时调用外部代码\",\"这个建议是很简单的：因为代码是外部提供的，所以没办法确定外部要做什么。外部程序可能做任何事情，包括获取锁。在持有锁的情况下，如果用外部代码要获取一个锁，就会违反第一个指导意见，并造成死锁（有时这是无法避免的）。当写通用代码时（比如保护共享数据中的 Date 类）。这不是接口设计者可以处理的，只能寄希望于调用方传递的代码是能正常执行的。\",\"使用固定顺序获取锁\",\"如同第一个示例那样，固定的顺序上锁就不存在问题。\"]},\"31\":{\"h\":\"灵活的锁\",\"t\":[\"std::unique_lock 是 C++11 引入的一种通用互斥包装器，它相比于 std::lock_guard 更加的灵活。当然，它也更加的复杂，尤其它还可以与我们下一章要讲的条件变量一起使用。使用它可以将之前使用 std::lock_guard 的 swap 改写一下：\",\"void swap(X& lhs, X& rhs) { if (&lhs == &rhs) return; std::unique_lock<std::mutex> lock1{ lhs.m, std::defer_lock }; std::unique_lock<std::mutex> lock2{ rhs.m, std::defer_lock }; std::lock(lock1, lock2); swap(lhs.object, rhs.object); ++n; } \",\"解释这段代码最简单的方式就是直接展示标准库的源码，首先，我们要了解 std::defer_lock 是“不获得互斥体的所有权”。没有所有权自然构造函数就不会上锁，但不止如此。我们还要先知道 std::unique_lock 保有的数据成员（都以 MSVC STL 为例）：\",\"private: _Mutex* _Pmtx = nullptr; bool _Owns = false; \",\"如你所见很简单，一个互斥量的指针，还有一个就是表示对象是否拥有互斥量所有权的 bool 类型的对象 _Owns 了。我们前面代码会调用构造函数：\",\"unique_lock(_Mutex& _Mtx, defer_lock_t) noexcept : _Pmtx(_STD addressof(_Mtx)), _Owns(false) {} // construct but don't lock \",\"如你所见，只是初始化了数据成员而已，注意，这个构造函数没有给互斥量上锁，且 _Owns 为 false 表示没有互斥量所有权。并且 std::unique_lock 是有 lock() 、try_lock() 、unlock() 成员函数的，所以可以直接传递给 std::lock、 进行调用。这里还需要提一下 lock() 成员函数的代码：\",\"void lock() { // lock the mutex _Validate(); _Pmtx->lock(); _Owns = true; } \",\"如你所见，正常上锁，并且把 _Owns 设置为 true，即表示当前对象拥有互斥量的所有权。那么接下来看析构函数：\",\"~unique_lock() noexcept { if (_Owns) { _Pmtx->unlock(); } } \",\"必须得是当前对象拥有互斥量的所有权析构函数才会调用 unlock() 解锁互斥量。我们的代码因为调用了 lock ，所以 _Owns 设置为 true ，函数结束的时候会解锁互斥量。\",\"设计挺奇怪的对吧，这个所有权语义。其实上面的代码还不够简单直接，我们再举个例子：\",\"std::mutex m; int main() { std::unique_lock<std::mutex>lock{ m,std::adopt_lock }; lock.lock(); } \",\"这段代码运行会抛出异常，原因很简单，因为 std::adopt_lock 只是不上锁，但是有所有权，即 _Owns 设置为 true 了，当运行 lock() 成员函数的时候，调用了 _Validate() 进行检测，也就是：\",\"void _Validate() const { // check if the mutex can be locked if (!_Pmtx) { _Throw_system_error(errc::operation_not_permitted); } if (_Owns) { _Throw_system_error(errc::resource_deadlock_would_occur); } } \",\"满足第二个 if，因为 _Owns 为 true 所以抛出异常，别的标准库也都有类似设计。很诡异的设计对吧，正常。除非我们写成：\",\"lock.mutex()->lock(); \",\"也就是说 std::unique_lock 要想调用 lock() 成员函数，必须是当前没有所有权。\",\"所以正常的用法其实是，先上锁了互斥量，然后传递 std::adopt_lock 构造 std::unique_lock 对象表示拥有互斥量的所有权，即可在析构的时候正常解锁。如下：\",\"std::mutex m; int main() { m.lock(); std::unique_lock<std::mutex>lock { m,std::adopt_lock }; } \",\"简而言之：\",\"使用 std::defer_lock 构造函数不上锁，要求构造之后上锁\",\"使用 std::adopt_lock 构造函数不上锁，要求在构造之前互斥量上锁\",\"默认构造会上锁，要求构造函数之前和构造函数之后都不能再次上锁\",\"我们前面提到了 std::unique_lock 更加灵活，那么灵活在哪？很简单，它拥有 lock() 和 unlock() 成员函数，所以我们能写出如下代码：\",\"void f() { //code.. std::unique_lock<std::mutex> lock{ m }; // 涉及共享资源的修改的代码... lock.unlock(); // 解锁并释放所有权，析构函数不会再 unlock() //code.. } \",\"而不是像之前 std::lock_guard 一样使用 {}。\",\"另外再聊一聊开销吧，其实倒也还好，多了一个 bool ，内存对齐，x64 环境也就是 16 字节。这都不是最重要的，主要是复杂性和需求，通常建议优先 std::lock_guard，当它无法满足你的需求或者显得代码非常繁琐，那么可以考虑使用 std::unique_lock。\"]},\"32\":{\"h\":\"在不同作用域传递互斥量\",\"t\":[\"首先我们要明白，互斥量满足互斥体 (Mutex)的要求，不可复制不可移动。所谓的在不同作用域传递互斥量，其实只是传递了它们的指针或者引用罢了。可以利用各种类来进行传递，比如前面提到的 std::unique_lock。\",\"std::unique_lock 可以获取互斥量的所有权，而互斥量的所有权可以通过移动操作转移给其他的 std::unique_lock 对象。有些时候，这种转移（就是调用移动构造）是自动发生的，比如当函数返回std::unique_lock 对象。另一种情况就是得显式使用 std::move。\",\"请勿对移动语义和转移所有权抱有错误的幻想，我们说的无非是调用 std::unique_lock 的移动构造罢了：\",\"_NODISCARD_CTOR_LOCK unique_lock(unique_lock&& _Other) noexcept : _Pmtx(_Other._Pmtx), _Owns(_Other._Owns) { _Other._Pmtx = nullptr; _Other._Owns = false; } \",\"将数据成员赋给新对象，原来的置空，这就是所谓的 “所有权”转移，切勿被词语迷惑。\",\"std::unique_lock 是只能移动不可复制的类，它移动即标志其管理的互斥量的所有权转移了。\",\"一种可能的使用是允许函数去锁住一个互斥量，并将互斥量的所有权转移到调用者上，所以调用者可以在这个锁保护的范围内执行代码。\",\"std::unique_lock<std::mutex>get_lock(){ extern std::mutex some_mutex; std::unique_lock<std::mutex> lk{ some_mutex }; return lk; } void process_data(){ std::unique_lock<std::mutex> lk{ get_lock() }; // 执行一些任务... } \",\"return lk 这里会调用移动构造，将互斥量的所有权转移给调用方， process_data 函数结束的时候会解锁互斥量。\",\"我相信你可能对 extern std::mutex some_mutex 有疑问，其实不用感到奇怪，这是一个互斥量的声明，可能别的翻译单元（或 dll 等）有它的定义，成功链接上。我们前面也说了：“所谓的在不同作用域传递互斥量，其实只是传递了它们的指针或者引用罢了”，所以要特别注意互斥量的生存期。\",\"extern 说明符只能搭配变量声明和函数声明（除了类成员或函数形参）。它指定外部链接，而且技术上不影响存储期，但它不能用来定义自动存储期的对象，故所有 extern 对象都具有静态或线程存储期。\",\"如果你简单写一个 std::mutex some_mutex 那么函数 process_data 中的 lk 会持有一个悬垂指针。\",\"举一个使用 extern std::mutex 的完整运行示例。当然，其实理论上你 new std::mutex 也是完全可行...... 🤣🤣\",\"std::unique_lock 是灵活的，同样允许在对象销毁之前就解锁互斥量，调用 unlock() 成员函数即可，不再强调。\"]},\"33\":{\"h\":\"保护共享数据的初始化过程\",\"t\":[\"保护共享数据并非必须使用互斥量，互斥量只是其中一种常见的方式而已，对于一些特殊的场景，也有专门的保护方式，比如对于共享数据的初始化过程的保护。我们通常就不会用互斥量，这会造成很多的额外开销。\",\"我们不想为各位介绍其它乱七八糟的各种保护初始化的方式，我们只介绍三种：双检锁（错误）、使用 std::call_once、静态局部变量初始化在 C++11 是线程安全。\",\"双检锁（错误）线程不安全\",\"void f(){ if(!ptr){ // 1 std::lock_guard<std::mutex> lk{ m }; if(!ptr){ // 2 ptr.reset(new some); // 3 } } ptr->do_something(); // 4 } \",\"① 是查看指针是否为空，空才需要初始化，才需要获取锁。指针为空，当获取锁后会再检查一次指针②（这就是双重检查），避免另一线程在第一次检查后再做初始化，并且让当前线程获取锁。\",\"然而这显然没用，因为有潜在的条件竞争。未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步，因此就会产生条件竞争。\",\"简而言之：一个线程知道另一个线程已经在执行③，但是此时还没有创建 some 对象，而只是分配内存对指针写入。那么这个线程在①的时候就不会进入，直接执行了 ptr->do_something()④，得不到正确的结果，因为对象还没构造。\",\"如果你觉得难以理解，那就记住 ptr.reset(new some); 并非是不可打断不可交换的固定指令。\",\"这种错误写法在一些单例中也非常的常见。如果你的同事或上司写出此代码，一般不建议指出，因为不见得你能教会他们，不要“没事找事”，只要不影响自己即可。\",\"C++ 标准委员会也认为处理此问题很重要，所以标准库提供了 std::call_once 和 std::once_flag 来处理这种情况。比起锁住互斥量并显式检查指针，每个线程只需要使用 std::call_once 就可以。使用 std::call_once 比显式使用互斥量消耗的资源更少，特别是当初始化完成之后。\",\"std::shared_ptr<some>ptr; std::mutex m; std::once_flag resource_flag; void init_resource(){ ptr.reset(new some); } void foo(){ std::call_once(resource_flag, init_resource); // 线程安全的一次初始化 ptr->do_something(); } \",\"以上代码 std::once_flag 对象是全局命名空间作用域声明，如果你有需要，它也可以是类的成员。用于搭配 std::call_once 使用，保证线程安全的一次初始化。std::call_once 只需要接受可调用 (Callable)对象即可，也不要求一定是函数。\",\"“初始化”，自然是一次。但是 std::call_once 也有一些例外情况（比如异常）会让传入的可调用对象被多次调用，即“多次”初始化：\",\"std::once_flag flag; int n = 0; void f(){ std::call_once(flag, [] { ++n; std::cout << \\\"第\\\" << n << \\\"次调用\\\\n\\\"; throw std::runtime_error(\\\"异常\\\"); }); } int main(){ try{ f(); } catch (std::exception&){} try{ f(); } catch (std::exception&){} } \",\"测试链接。正常情况会保证传入的可调用对象只调用一次，即初始化只有一次。异常之类的是例外。\",\"静态局部变量初始化在 C++11 是线程安全\",\"class my_class; my_class& get_my_class_instance(){ static my_class instance; // 线程安全的初始化过程 初始化严格发生一次 return instance; } \",\"多线程可以安全的调用 get_my_class_instance 函数，不用为数据竞争而担心。此方式也在单例中多见，是简单合理的做法。\",\"其实还有不少其他的做法或者反例，但是觉得没必要再聊了，因为本文不是详尽的文档，而是“教程”。\"]},\"34\":{\"h\":\"保护不常更新的数据结构\",\"t\":[\"试想一下，你有一个数据结构存储了用户的设置信息，每次用户打开程序的时候，都要进行读取，且运行时很多地方都依赖这个数据结构需要读取，所以为了效率，我们使用了多线程读写。这个数据结构很少进行改变，而我们知道，多线程读取，是没有数据竞争的，是安全的，但是有些时候又不可避免的有修改和读取都要工作的时候，所以依然必须得使用互斥量进行保护。\",\"然而使用 std::mutex 的开销是过大的，它不管有没有发生数据竞争（也就是就算全是读的情况）也必须是老老实实上锁解锁，只有一个线程可以运行。如果你学过其它语言或者操作系统，相信这个时候就已经想到了：“读写锁”。\",\"C++ 标准库自然为我们提供了： std::shared_timed_mutex（C++14）、 std::shared_mutex（C++17）。它们的区别简单来说，前者支持更多的操作方式，后者有更高的性能优势。\",\"std::shared_mutex 同样支持 std::lock_guard、std::unique_lock。和 std::mutex 做的一样，保证写线程的独占访问。而那些无需修改数据结构的读线程，可以使用 std::shared_lock<std::shared_mutex> 获取访问权，多个线程可以一起读取。\",\"class Settings { private: std::map<std::string, std::string> data_; mutable std::shared_mutex mutex_; // “M&M 规则”：mutable 与 mutex 一起出现 public: void set(const std::string& key, const std::string& value) { std::lock_guard<std::shared_mutex> lock{ mutex_ }; data_[key] = value; } std::string get(const std::string& key) const { std::shared_lock<std::shared_mutex> lock(mutex_); auto it = data_.find(key); return (it != data_.end()) ? it->second : \\\"\\\"; // 如果没有找到键返回空字符串 } }; \",\"完整代码。测试链接。标准输出可能交错，但无数据竞争。\",\"std::shared_timed_mutex 具有 std::shared_mutex 的所有功能，并且额外支持超时功能。所以以上代码可以随意更换这两个互斥量。\"]},\"35\":{\"h\":\"\",\"t\":[\"线程对已经上锁的 std::mutex 再次上锁是错误的，这是未定义行为。然而在某些情况下，一个线程会尝试在释放一个互斥量前多次获取，所以提供了std::recursive_mutex。\",\"std::recursive_mutex 是 C++ 标准库提供的一种互斥量类型，它允许同一线程多次锁定同一个互斥量，而不会造成死锁。当同一线程多次对同一个 std::recursive_mutex 进行锁定时，只有在解锁与锁定次数相匹配时，互斥量才会真正释放。但它并不影响不同线程对同一个互斥量进行锁定的情况。不同线程对同一个互斥量进行锁定时，会按照互斥量的规则进行阻塞，\",\"#include <iostream> #include <thread> #include <mutex> std::recursive_mutex mtx; void recursive_function(int count) { // 递归函数，每次递归都会锁定互斥量 mtx.lock(); std::cout << \\\"Locked by thread: \\\" << std::this_thread::get_id() << \\\", count: \\\" << count << std::endl; if (count > 0) { recursive_function(count - 1); // 递归调用 } mtx.unlock(); // 解锁互斥量 } int main() { std::thread t1(recursive_function, 3); std::thread t2(recursive_function, 2); t1.join(); t2.join(); } \",\"运行测试。\",\"lock：线程可以在递归互斥体上重复调用 lock。在线程调用 unlock 匹配次数后，所有权才会得到释放。\",\"unlock：若所有权层数为 1（此线程对 lock() 的调用恰好比 unlock() 多一次 ）则解锁互斥体，否则将所有权层数减少 1。\",\"我们重点的强调了一下这两个成员函数的这个概念，其实也很简单，总而言之就是 unlock 必须和 lock 的调用次数一样，才会真正解锁互斥量。\",\"同样的，我们也可以使用 std::lock_guard、std::unique_lock 帮我们管理 std::recursive_mutex，而非显式调用 lock 与 unlock：\",\"void recursive_function(int count) { std::lock_guard<std::recursive_mutex> lc{ mtx }; std::cout << \\\"Locked by thread: \\\" << std::this_thread::get_id() << \\\", count: \\\" << count << std::endl; if (count > 0) { recursive_function(count - 1); } } \",\"运行测试。\"]},\"36\":{\"h\":\"、 是线程安全的吗？\",\"t\":[\"如果你的标准达到 C++11，要求下列函数是线程安全的：\",\"new 运算符和 delete 运算符的库版本\",\"全局 new 运算符和 delete 运算符的用户替换版本\",\"std::calloc、std::malloc、std::realloc、std::aligned_alloc (C++17 起)、std::free\",\"所以以下函数在多线程运行是线程安全的：\",\"void f(){ T* p = new T{}; delete p; } \",\"内存分配、释放操作是线程安全，构造和析构不涉及共享资源。而局部对象 p 对于每个线程来说是独立的。换句话说，每个线程都有其自己的 p 对象实例，因此它们不会共享同一个对象，自然没有数据竞争。\",\"如果 p 是全局对象（或者外部的，只要可被多个线程读写），多个线程同时对其进行访问和修改时，就可能会导致数据竞争和未定义行为。因此，确保全局对象的线程安全访问通常需要额外的同步措施，比如互斥量或原子操作。\",\"T* p = nullptr; void f(){ p = new T{}; // 存在数据竞争 delete p; } \",\"即使 p 是局部对象，如果构造函数（析构同理）涉及读写共享资源，那么一样存在数据竞争，需要进行额外的同步措施进行保护。\",\"int n = 1; struct X{ X(int v){ ::n += v; } }; void f(){ X* p = new X{ 1 }; // 存在数据竞争 delete p; } \",\"一个直观的展示是，我们可以在构造函数中使用 std::cout，看到无序的输出，例子。\",\"值得注意的是，如果是自己重载 operator new、operator delete 替换了库的全局版本，那么它的线程安全就要我们来保证。\",\"// 全局的 new 运算符，替换了库的版本 void* operator new (std::size_t count){ return ::operator new(count); } \",\"以上代码是线程安全的，因为 C++11 保证了 new 运算符的库版本，即 ::operator new 是线程安全的，我们直接调用它自然不成问题。如果你需要更多的操作，就得使用互斥量之类的方式保护了。\",\"总而言之，new 表达式线程安全要考虑三方面：operator new、构造函数、修改指针。\",\"delete 表达式线程安全考虑两方面：operator delete、析构函数。\",\"C++ 只保证了 operator new、operator delete 这两个方面的线程安全（不包括用户定义的），其它方面就得自己保证了。前面的内容也都提到了。\"]},\"37\":{\"h\":\"线程存储期\",\"t\":[\"线程存储期（也有人喜欢称作“线程局部存储”）的概念源自操作系统，是一种非常古老的机制，广泛应用于各种编程语言。线程存储期的对象在线程开始时分配，并在线程结束时释放。每个线程拥有自己独立的对象实例，互不干扰。在 C++11中，引入了thread_local关键字，用于声明具有线程存储期的对象。\",\"以下是一个示例代码，展示了 thread_local 关键字的使用：\",\"int global_counter = 0; thread_local int thread_local_counter = 0; void print_counters(){ std::cout << \\\"global：\\\" << global_counter++ << '\\\\n'; std::cout << \\\"thread_local：\\\" << thread_local_counter++ << '\\\\n'; } int main(){ std::thread{ print_counters }.join(); std::thread{ print_counters }.join(); } \",\"运行结果：\",\"global：0 thread_local：0 global：1 thread_local：0 \",\"这段代码很好的展示了 thread_local 关键字的使用以及它的作用。每一个线程都有独立的 thread_local_counter 对象，它们不是同一个。\",\"我知道你会有问题：“那么 C++11 之前呢？”那时开发者通常使用 POSIX 线程（Pthreads）或 Win32 线程的接口，或者依赖各家编译器的扩展。例如：\",\"POSIX：使用 pthread_key_t 和相关的函数（ pthread_key_create、pthread_setspecific、pthread_getspecific 和pthread_key_delete）来管理线程局部存储。\",\"Win32：使用 TLS（Thread Local Storage）机制，通过函数 TlsAlloc、TlsSetValue、TlsGetValue 和 TlsFree 来实现线程局部存储。\",\"GCC：使用 __thread 。\",\"MSVC：使用 __declspec(thread)。\",\"POSIX 与 Win32 接口的就不再介绍了，有兴趣参见我们的链接即可。我们就拿先前的代码改成使用 GCC 与 MSVC 的编译器扩展即可。\",\"__thread int thread_local_counter = 0; // GCC __declspec(thread) int thread_local_counter = 0; // MSVC \",\"MSVC 无法使用 GCC 的编译器扩展，GCC 也肯定无法使用 MSVC 的扩展，不过 Clang 编译器可以，它支持 __thread 与 __declspec(thread) 两种。Clang 默认情况就支持 GCC 的编译器扩展，如果要支持 MSVC，需要设置 -fms-extensions 编译选项。\",\"__declspec(thread) 运行测试\",\"__thread 运行测试\",\"要注意的是，这些扩展并不是标准的 C++ 语言特性，它们的跨平台性和可移植性较差，我们应当使用 C++ 标准的 thread_local。\",\"了解其它 API 以及编译器扩展有助于理解历史上线程存储期的演进。同时扩展知识面。\"]},\"38\":{\"h\":\"总结\",\"t\":[\"本章讨论了多线程的共享数据引发的恶性条件竞争会带来的问题。并说明了可以使用互斥量（std::mutex）保护共享数据，并且要注意互斥量上锁的“粒度”。C++标准库提供了很多工具，包括管理互斥量的管理类（std::lock_guard），但是互斥量只能解决它能解决的问题，并且它有自己的问题（死锁）。同时我们讲述了一些避免死锁的方法和技术。还讲了一下互斥量所有权转移。然后讨论了面对不同情况保护共享数据的不同方式，使用 std::call_once() 保护共享数据的初始化过程，使用读写锁（std::shared_mutex）保护不常更新的数据结构。以及特殊情况可能用到的互斥量 recursive_mutex，有些人可能喜欢称作：递归锁。最后聊了一下 new、delete 运算符的库函数实际是线程安全的，以及线程存储期。\",\"下一章，我们将开始讲述同步操作，会使用到 Futures、条件变量等设施。\",\"\\\"临界区\\\"指的是一个访问共享资源的程序片段，而这些共享资源又无法同时被多个线程访问的特性。在临界区中，通常会使用同步机制，比如我们要讲的互斥量（Mutex）。 ↩︎\"]},\"39\":{\"h\":\"同步操作\",\"t\":[\"\\\"同步操作\\\"是指在计算机科学和信息技术中的一种操作方式，其中不同的任务或操作按顺序执行，一个操作完成后才能开始下一个操作。在多线程编程中，各个任务通常需要通过同步操作进行相互协调和等待，以确保数据的一致性和正确性。\",\"本章的主要内容有：\",\"条件变量\",\"std::future 等待异步任务\",\"在规定时间内等待\",\"本章将讨论如何使用条件变量等待事件，介绍 future 等标准库设施用作同步操作。\"]},\"40\":{\"h\":\"等待事件或条件\",\"t\":[\"假设你正在一辆夜间运行的地铁上，那么你要如何在正确的站点下车呢？\",\"一直不休息，每一站都能知道，这样就不会错过你要下车的站点，但是这会很疲惫。\",\"可以看一下时间，估算一下地铁到达目的地的时间，然后设置一个稍早的闹钟，就休息。这个方法听起来还行，但是你可能被过早的叫醒，甚至估算错误导致坐过站，又或者闹钟没电了睡过站。\",\"事实上最简单的方式是，到站的时候有人或者其它东西能将你叫醒（比如手机的地图，到达设置的位置就提醒）。\",\"这和线程有什么关系呢？其实第一种方法就是在说”忙等待（busy waiting）”也称“自旋“。\",\"bool flag = false; std::mutex m; void wait_for_flag(){ std::unique_lock<std::mutex>lk{ m }; while (!flag){ lk.unlock(); // 1 解锁互斥量 lk.lock(); // 2 上锁互斥量 } } \",\"第二种方法就是加个延时，这种实现进步了很多，减少浪费的执行时间，但很难确定正确的休眠时间。这会影响到程序的行为，在需要快速响应的程序中就意味着丢帧或错过了一个时间片。循环中，休眠②前函数对互斥量解锁①，再休眠结束后再对互斥量上锁，让另外的线程有机会获取锁并设置标识（因为修改函数和等待函数共用一个互斥量）。\",\"void wait_for_flag(){ std::unique_lock<std::mutex>lk{ m }; while (!flag){ lk.unlock(); // 1 解锁互斥量 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 2 休眠 lk.lock(); // 3 上锁互斥量 } } \",\"第三种方式（也是最好的）实际上就是使用条件变量了。通过另一线程触发等待事件的机制是最基本的唤醒方式，这种机制就称为“条件变量”。\",\"C++ 标准库对条件变量有两套实现：std::condition_variable 和 std::condition_variable_any，这两个实现都包含在 <condition_variable> 头文件中。\",\"condition_variable_any 类是 std::condition_variable 的泛化。相对于只在 std::unique_lock<std::mutex> 上工作的 std::condition_variable，condition_variable_any 能在任何满足可基本锁定(BasicLockable)要求的锁上工作，所以增加了 _any 后缀。显而易见，这种区分必然是 any 版更加通用但是却有更多的性能开销。所以通常首选std::condition_variable。有特殊需求，才会考虑 std::condition_variable_any。\",\"std::mutex mtx; std::condition_variable cv; bool arrived = false; void wait_for_arrival() { std::unique_lock<std::mutex> lck(mtx); cv.wait(lck, []{ return arrived; }); // 等待 arrived 变为 true std::cout << \\\"到达目的地，可以下车了！\\\" << std::endl; } void simulate_arrival() { std::this_thread::sleep_for(std::chrono::seconds(5)); // 模拟地铁到站，假设5秒后到达目的地 { std::lock_guard<std::mutex> lck(mtx); arrived = true; // 设置条件变量为 true，表示到达目的地 } cv.notify_one(); // 通知等待的线程 } \",\"运行测试。更换为 std::condition_variable_any 效果相同。\",\"std::mutex mtx: 创建了一个互斥量，用于保护共享数据的访问，确保在多线程环境下的数据同步。\",\"std::condition_variable cv: 创建了一个条件变量，用于线程间的同步，当条件不满足时，线程可以等待，直到条件满足时被唤醒。\",\"bool arrived = false: 设置了一个标志位，表示是否到达目的地。\",\"在 wait_for_arrival 函数中：\",\"std::unique_lock<std::mutex> lck(mtx): 使用互斥量创建了一个独占锁。\",\"cv.wait(lck, []{ return arrived; }): 阻塞当前线程，释放（unlock）锁，直到条件被满足。\",\"一旦条件满足，即 arrived 变为 true，并且条件变量 cv 被唤醒（包括虚假唤醒），那么当前线程会重新获取锁（lock），并执行后续的操作。\",\"在 simulate_arrival 函数中：\",\"std::this_thread::sleep_for(std::chrono::seconds(5)): 模拟地铁到站，暂停当前线程 5 秒。\",\"设置 arrived 为 true，表示到达目的地。\",\"cv.notify_one(): 唤醒一个等待条件变量的线程。\",\"这样，当 simulate_arrival 函数执行后，arrived 被设置为 true，并且通过 cv.notify_one() 唤醒了等待在条件变量上的线程，从而使得 wait_for_arrival 函数中的等待结束，可以执行后续的操作，即输出提示信息。\",\"条件变量的 wait 成员函数有两个版本，以上代码使用的就是第二个版本，传入了一个谓词。\",\"void wait(std::unique_lock<std::mutex>& lock); // 1 template<class Predicate> void wait(std::unique_lock<std::mutex>& lock, Predicate pred); // 2 \",\"②等价于：\",\"while (!pred()) wait(lock); \",\"这可以避免“虚假唤醒（spurious wakeup）”。\",\"条件变量虚假唤醒是指在使用条件变量进行线程同步时，有时候线程可能会在没有收到通知的情况下被唤醒。问题取决于程序和系统的具体实现。解决方法很简单，在循环中等待并判断条件可一并解决。使用 C++ 标准库则没有这个烦恼了。\"]},\"41\":{\"h\":\"线程安全的队列\",\"t\":[\"在本节中，我们介绍了一个更为复杂的示例，以巩固我们对条件变量的学习。为了实现一个线程安全的队列，我们需要考虑以下两个关键点：\",\"当执行 push 操作时，需要确保没有其他线程正在执行 push 或 pop 操作；同样，在执行 pop 操作时，也需要确保没有其他线程正在执行 push 或 pop 操作。\",\"当队列为空时，不应该执行 pop 操作。因此，我们需要使用条件变量来传递一个谓词，以确保在执行 pop 操作时队列不为空。\",\"基于以上思考，我们设计了一个名为 threadsafe_queue 的模板类，如下：\",\"template<typename T> class threadsafe_queue { mutable std::mutex m; // 互斥量，用于保护队列操作的独占访问 std::condition_variable data_cond; // 条件变量，用于在队列为空时等待 std::queue<T> data_queue; // 实际存储数据的队列 public: threadsafe_queue() {} void push(T new_value) { { std::lock_guard<std::mutex>lk(m); data_queue.push(new_value); } data_cond.notify_one(); } // 从队列中弹出元素（阻塞直到队列不为空） void pop(T& value) { std::unique_lock<std::mutex>lk(m); data_cond.wait(lk, [this] {return !data_queue.empty(); }); value = data_queue.front(); data_queue.pop(); } // 从队列中弹出元素（阻塞直到队列不为空），并返回一个指向弹出元素的 shared_ptr std::shared_ptr<T> pop() { std::unique_lock<std::mutex>lk(m); data_cond.wait(lk, [this] {return !data_queue.empty(); }); std::shared_ptr<T>res(std::make_shared<T>(data_queue.front())); data_queue.pop(); return res; } bool empty()const { std::lock_guard<std::mutex>lk(m); return data_queue.empty(); } }; \",\"请无视我们省略的构造、赋值、交换、try_xx 等操作。以上示例已经足够。\",\"光写好了肯定不够，我们还得测试运行，我们可以写一个经典的：”生产者消费者模型“，也就是一个线程 push ”生产“，一个线程 pop ”消费“。\",\"void producer(threadsafe_queue<int>& q) { for (int i = 0; i < 5; ++i) { q.push(i); } } void consumer(threadsafe_queue<int>& q) { for (int i = 0; i < 5; ++i) { int value{}; q.pop(value); } } \",\"两个线程分别运行 producer 与 consumer，为了观测运行我们可以为 push 与 pop 中增加打印语句：\",\"std::cout << \\\"push:\\\" << new_value << std::endl; std::cout << \\\"pop:\\\" << value << std::endl; \",\"可能的运行结果是：\",\"push:0 pop:0 push:1 pop:1 push:2 push:3 push:4 pop:2 pop:3 pop:4 \",\"这很正常，到底哪个线程会抢到 CPU 时间片持续运行，是系统调度决定的，我们只需要保证一开始提到的两点就行了：\",\"push 与 pop 都只能单独执行；当队列为空时，不执行 pop 操作。\",\"我们可以给一个简单的示意图帮助你理解这段运行结果：\",\"初始状态：队列为空 +---+---+---+---+---+ Producer 线程插入元素 0： +---+---+---+---+---+ | 0 | | | | | Consumer 线程弹出元素 0： +---+---+---+---+---+ | | | | | | Producer 线程插入元素 1： +---+---+---+---+---+ | 1 | | | | | Consumer 线程弹出元素 1： +---+---+---+---+---+ | | | | | | Producer 线程插入元素 2： +---+---+---+---+---+ | | 2 | | | | Producer 线程插入元素 3： +---+---+---+---+---+ | | 2 | 3 | | | Producer 线程插入元素 4： +---+---+---+---+---+ | | 2 | 3 | 4 | | Consumer 线程弹出元素 2： +---+---+---+---+---+ | | | 3 | 4 | | Consumer 线程弹出元素 3： +---+---+---+---+---+ | | | | 4 | | Consumer 线程弹出元素 4： +---+---+---+---+---+ | | | | | | 队列为空，所有元素已被弹出 \",\"到此，也就可以了。\"]},\"42\":{\"h\":\"使用\",\"t\":[\"举个例子：我们在车站等车，你可能会做一些别的事情打发时间，比如学习现代 C++ 模板教程、观看 mq白 的视频教程、玩手机等。不过，你始终在等待一件事情：车到站。\",\"C++ 标准库将这种事件称为 future。它用于处理线程中需要等待某个事件的情况，线程知道预期结果。等待的同时也可以执行其它的任务。\",\"C++ 标准库有两种 future，都声明在 <future> 头文件中：独占的 std::future 、共享的 std::shared_future。它们的区别与 std::unique_ptr 和 std::shared_ptr 类似。std::future 只能与单个指定事件关联，而 std::shared_future 能关联多个事件。它们都是模板，它们的模板类型参数，就是其关联的事件（函数）的返回类型。当多个线程需要访问一个独立 future 对象时， 必须使用互斥量或类似同步机制进行保护。而多个线程访问同一共享状态，若每个线程都是通过其自身的 shared_future 对象副本进行访问，则是安全的。\",\"最简单的作用是，我们先前讲的 std::thread 执行任务是没有返回值的，这个问题就能使用 future 解决。\"]},\"43\":{\"h\":\"创建异步任务获取返回值\",\"t\":[\"假设需要执行一个耗时任务并获取其返回值，但是并不急切的需要它。那么就可以启动新线程计算，然而 std::thread 没提供直接从线程获取返回值的机制。所以我们可以使用 std::async 函数模板。\",\"使用 std::async 启动一个异步任务，它会返回一个 std::future 对象，这个对象和任务关联，将持有最终计算出来的结果。当需要任务执行完的结果的时候，只需要调用 get() 成员函数，就会阻塞直到 future 为就绪为止（即任务执行完毕），返回执行结果。valid() 成员函数检查 future 当前是否关联共享状态，即是否当前关联任务。还未关联，或者任务已经执行完（调用了 get()、set()），都会返回 false。\",\"#include <iostream> #include <thread> #include <future> // 引入 future 头文件 int task(int n) { std::cout << \\\"异步任务 ID: \\\" << std::this_thread::get_id() << '\\\\n'; return n * n; } int main() { std::future<int> future = std::async(task, 10); std::cout << \\\"main: \\\" << std::this_thread::get_id() << '\\\\n'; std::cout << std::boolalpha << future.valid() << '\\\\n'; // true std::cout << future.get() << '\\\\n'; std::cout << std::boolalpha << future.valid() << '\\\\n'; // false } \",\"运行测试。\",\"与 std::thread 一样，std::async 支持任意可调用(Callable)对象，以及传递调用参数。包括支持使用 std::ref ，以及支持只能移动的类型。我们下面详细聊一下 std::async 参数传递的事。\",\"struct X{ int operator()(int n)const{ return n * n; } }; struct Y{ int f(int n)const{ return n * n; } }; void f(int& p) { std::cout << &p << '\\\\n'; } int main(){ Y y; int n = 0; auto t1 = std::async(X{}, 10); auto t2 = std::async(&Y::f,&y,10); auto t3 = std::async([] {}); auto t4 = std::async(f, std::ref(n)); std::cout << &n << '\\\\n'; } \",\"运行测试。\",\"如你所见，它支持所有可调用(Callable)对象，并且也是默认按值复制，必须使用 std::ref 才能传递引用。并且它和 std::thread 一样，内部会将保有的参数副本转换为右值表达式进行传递，这是为了那些只支持移动的类型，左值引用没办法引用右值表达式，所以如果不使用 std::ref，这里 void f(int&) 就会导致编译错误，如果是 void f(const int&) 则可以通过编译，不过引用的不是我们传递的局部对象。\",\"void f(const int& p) {} void f2(int& p ){} int n = 0; std::async(f, n); // OK! 可以通过编译，不过引用的并非是局部的n std::async(f2, n); // Error! 无法通过编译 \",\"我们来展示使用 std::move ，也就移动传递参数：\",\"struct move_only { move_only() { std::puts(\\\"默认构造\\\"); } move_only(const move_only&) = delete; move_only(move_only&&)noexcept { std::puts(\\\"移动构造\\\"); } }; void task(move_only x){ std::cout << \\\"异步任务 ID: \\\" << std::this_thread::get_id() << '\\\\n'; } int main(){ move_only x; std::future<void> future = std::async(task, std::move(x)); std::this_thread::sleep_for(std::chrono::milliseconds(1)); std::cout << \\\"main\\\\n\\\"; future.wait(); // 等待异步任务执行完毕 } \",\"运行测试。\",\"如你所见，它支持只移动类型，我们将参数使用 std::move 传递。\",\"接下来我们聊 std::async 的执行策略，我们前面一直没有使用，其实就是在传递可调用对象与参数之前传递枚举值罢了：\",\"std::launch::async 在不同线程上执行异步任务。\",\"std::launch::deferred 惰性求值，不创建线程，等待 future 对象调用 wait 或 get 成员函数的时候执行任务。\",\"而我们先前一直没有写明这个参数，是因为 std::async 函数模板有两个重载，不给出执行策略就是以：std::launch::async | std::launch::deferred 调用另一个重载版本（这一点中在源码中很明显），此策略表示由实现选择到底是否创建线程执行异步任务。典型情况是，如果系统资源充足，并且异步任务的执行不会导致性能问题，那么系统可能会选择在新线程中执行任务。但是，如果系统资源有限，或者延迟执行可以提高性能或节省资源，那么系统可能会选择延迟执行。\",\"我们来展示一下：\",\"void f(){ std::cout << std::this_thread::get_id() << '\\\\n'; } int main(){ std::cout << std::this_thread::get_id() << '\\\\n'; auto f1 = std::async(std::launch::deferred, f); f1.wait(); // 在 wait() 或 get() 调用时执行，不创建线程 auto f2 = std::async(std::launch::async,f); // 创建线程执行异步任务 auto f3 = std::async(std::launch::deferred | std::launch::async, f); // 实现选择的执行方式 } \",\"运行测试。\",\"其实到此基本就差不多了，我们再介绍两个常见问题即可：\",\"如果从 std::async 获得的 std::future 没有被移动或绑定到引用，那么在完整表达式结尾， std::future 的析构函数将阻塞到异步计算完成。因为临时对象的生存期就在这一行，调用析构函数阻塞执行。\",\"std::async(std::launch::async, []{ f(); }); // 临时量的析构函数等待 f() std::async(std::launch::async, []{ g(); }); // f() 完成前不开始 \",\"如你所见，这并不能创建异步任务，会堵塞，然后逐个执行。\",\"被移动的 std::future 没有所有权，失去共享状态，不能调用 get、wait 成员函数。\",\"auto t = std::async([] {}); std::future<void> future{ std::move(t) }; t.wait(); // Error! 抛出异常 \",\"如同没有线程资源所有权的 std::thread 对象调用 join() 一样错误，这是移动语义的基本语义逻辑。\"]},\"44\":{\"h\":\"与\",\"t\":[\"类模板 std::packaged_task 包装任何可调用(Callable)目标（函数、lambda 表达式、bind 表达式或其它函数对象），使得能异步调用它。其返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。\",\"通常它会和 std::future 一起使用，不过也可以单独使用，我们一步一步来：\",\"std::packaged_task<double(int, int)> task([](int a, int b){ return std::pow(a, b); }); task(10, 2); // 执行传递的 lambda，但无法获取返回值 \",\"它有 operator() 的重载，它会执行我们传递的可调用(Callable)对象，不过这个重载的返回类型是 void没办法获取返回值。\",\"如果想要异步的获取返回值，我们需要在调用 operator() 之前，让它和 future 关联，然后使用 future.get()，也就是：\",\"std::packaged_task<double(int, int)> task([](int a, int b){ return std::pow(a, b); }); std::future<double>future = task.get_future(); task(10, 2); // 此处执行任务 std::cout << future.get() << '\\\\n'; // 不堵塞，此处获取返回值 \",\"运行测试。\",\"先关联任务，再执行任务，当我们想要获取任务的返回值的时候，就 future.get() 即可。值得注意的是，任务并不会在线程中执行，想要在线程中执行异步任务，然后再获取返回值，我们可以这么做：\",\"std::packaged_task<double(int, int)> task([](int a, int b){ return std::pow(a, b); }); std::future<double>future = task.get_future(); std::thread t{ std::move(task),10,2 }; // 任务在线程中执行 // todo.. 幻想还有许多耗时的代码 t.join(); std::cout << future.get() << '\\\\n'; // 并不堵塞，获取任务返回值罢了 \",\"运行测试。\",\"因为 task 本身是重载了 operator() 的，是可调用对象，自然可以传递给 std::thread 执行，以及传递调用参数。唯一需要注意的是我们使用了 std::move ，这是因为 std::packaged_task 只能移动，不能复制。\",\"简而言之，其实 std::packaged_task 也就是一个“包装”类而已，它本身并没什么特殊的，老老实实执行我们传递的任务，且方便我们获取返回值罢了，明确这一点，那么一切都不成问题。\",\"std::packaged_task 也可以在线程中传递，在需要的时候获取返回值，而非像上面那样将它自己作为可调用对象：\",\"template<typename R, typename...Ts, typename...Args> requires std::invocable<std::packaged_task<R(Ts...)>&, Args...> void async_task(std::packaged_task<R(Ts...)>& task, Args&&...args) { // todo.. task(std::forward<Args>(args)...); } int main() { std::packaged_task<int(int,int)> task([](int a,int b){ return a + b; }); int value = 50; std::future<int> future = task.get_future(); // 创建一个线程来执行异步任务 std::thread t{ [&] {async_task(task, value, value); } }; std::cout << future.get() << '\\\\n'; t.join(); } \",\"运行测试。\",\"我们套了一个 lambda，这是因为函数模板不是函数，它并非具体类型，没办法直接被那样传递使用，只能包一层了。这只是一个简单的示例，展示可以使用 std::packaged_task 作函数形参，然后我们来传递任务进行异步调用等操作。\",\"我们再将第二章实现的并行 sum 改成 std::package_task + std::future 的形式：\",\"template<typename ForwardIt> auto sum(ForwardIt first, ForwardIt last) { using value_type = std::iter_value_t<ForwardIt>; std::size_t num_threads = std::thread::hardware_concurrency(); std::ptrdiff_t distance = std::distance(first, last); if (distance > 1024000) { // 计算每个线程处理的元素数量 std::size_t chunk_size = distance / num_threads; std::size_t remainder = distance % num_threads; // 存储每个线程要执行的任务 std::vector<std::packaged_task<value_type()>>tasks; // 和每一个任务进行关联的 future 用于获取返回值 std::vector<std::future<value_type>>futures(num_threads); // 存储关联线程的线程对象 std::vector<std::thread> threads; // 制作任务、与 future 关联、启动线程执行 auto start = first; for (std::size_t i = 0; i < num_threads; ++i) { auto end = std::next(start, chunk_size + (i < remainder ? 1 : 0)); tasks.emplace_back(std::packaged_task<value_type()>{[start, end, i] { return std::accumulate(start, end, value_type{}); }}); start = end; // 开始迭代器不断向前 futures[i] = tasks[i].get_future(); // 任务与 std::future 关联 threads.emplace_back(std::move(tasks[i])); } // 等待所有线程执行完毕 for (auto& thread : threads) thread.join(); // 汇总线程的计算结果 value_type total_sum {}; for (std::size_t i = 0; i < num_threads; ++i) { total_sum += futures[i].get(); } return total_sum; } value_type total_sum = std::accumulate(first, last, value_type{}); return total_sum; } \",\"运行测试。\",\"相比于之前，其实不同无非是定义了 std::vector<std::packaged_task<value_type()>> tasks 与 std::vector<std::future<value_type>> futures ，然后在循环中制造任务插入容器，关联 tuple，再放到线程中执行。最后汇总的时候写一个循环，futures[i].get() 获取任务的返回值加起来即可。\",\"到此，也就可以了。\"]},\"45\":{\"h\":\"使用\",\"t\":[\"类模板 std::promise 用于存储一个值或一个异常，之后通过 std::promise 对象所创建的 std::future 对象异步获得。\",\"// 计算函数，接受一个整数并返回它的平方 void calculate_square(std::promise<int> promiseObj, int num) { // 模拟一些计算 std::this_thread::sleep_for(std::chrono::seconds(1)); // 计算平方并设置值到 promise 中 promiseObj.set_value(num * num); } // 创建一个 promise 对象，用于存储计算结果 std::promise<int> promise; // 从 promise 获取 future 对象进行关联 std::future<int> future = promise.get_future(); // 启动一个线程进行计算 int num = 5; std::thread t(calculate_square, std::move(promise), num); // 阻塞，直到结果可用 int result = future.get(); std::cout << num << \\\" 的平方是：\\\" << result << std::endl; t.join(); \",\"运行测试。\",\"我们在新线程中通过调用 set_value() 函数设置 promise 的值，并在主线程中通过与其关联的 future 对象的 get() 成员函数获取这个值，如果promise的值还没有被设置，那么将阻塞当前线程，直到被设置为止。同样的 std::promise只能移动，不可复制，所以我们使用了 std::move 进行传递。\",\"除了 set_value() 函数外，std::promise 还有一个 set_exception() 成员函数，它接受一个 std::exception_ptr 类型的参数，这个参数通常通过 std::current_exception() 获取，用于指示当前线程中抛出的异常。然后，std::future 对象通过 get() 函数获取这个异常，如果 promise 所在的函数有异常被抛出，则 std::future 对象会重新抛出这个异常，从而允许主线程捕获并处理它。\",\"void throw_function(std::promise<int> prom) { try { throw std::runtime_error(\\\"一个异常\\\"); } catch (...) { prom.set_exception(std::current_exception()); } } int main() { std::promise<int> prom; std::future<int> fut = prom.get_future(); std::thread t(throw_function, std::move(prom)); try { std::cout << \\\"等待线程执行，抛出异常并设置\\\\n\\\"; fut.get(); } catch (std::exception& e) { std::cerr << \\\"来自线程的异常: \\\" << e.what() << '\\\\n'; } t.join(); } \",\"运行结果：\",\"等待线程执行，抛出异常并设置 来自线程的异常: 一个异常 \",\"你可能对这段代码还有一些疑问：我们写的是 promised<int> ，但是却没有使用 set_value 设置值，你可能会想着再写一行 prom.set_value(0)？\",\"共享状态的 promise 已经存储值或者异常，再次调用 set_value（set_exception） 会抛出 std::future_error 异常，将错误码设置为 promise_already_satisfied。这是因为 std::promise 对象只能是存储值或者异常其中一种，而无法共存。\",\"简而言之，set_value 与 set_exception 二选一，如果先前调用了 set_value ，就不可再次调用 set_exception，反之亦然（不然就会抛出异常），示例如下：\",\"void throw_function(std::promise<int> prom) { prom.set_value(100); try { throw std::runtime_error(\\\"一个异常\\\"); } catch (...) { try{ // 共享状态的 promise 已存储值，调用 set_exception 产生异常 prom.set_exception(std::current_exception()); }catch (std::exception& e){ std::cerr << \\\"来自 set_exception 的异常: \\\" << e.what() << '\\\\n'; } } } int main() { std::promise<int> prom; std::future<int> fut = prom.get_future(); std::thread t(throw_function, std::move(prom)); std::cout << \\\"等待线程执行，抛出异常并设置\\\\n\\\"; std::cout << \\\"值：\\\" << fut.get() << '\\\\n'; // 100 t.join(); } \",\"运行结果：\",\"等待线程执行，抛出异常并设置 值：100 来自 set_exception 的异常: promise already satisfied \"]},\"46\":{\"h\":\"多个线程的等待\",\"t\":[\"之前的例子中都在用 std::future ，不过 std::future 也有局限性。很多线程在等待的时候，只有一个线程能获取结果。当多个线程等待相同事件的结果时，就需要使用 std::shared_future 来替代 std::future 了。std::future 与 std::shared_future 的区别就如同 std::unique_ptr、std::shared_ptr 一样。\",\"std::future 是只能移动的，其所有权可以在不同的对象中互相传递，但只有一个对象可以获得特定的同步结果。而 std::shared_future 是可复制的，多个对象可以指代同一个共享状态。\",\"在多个线程中对同一个 std::shared_future 对象进行操作时（如果没有进行同步保护）存在竞争条件。而从多个线程访问同一共享状态，若每个线程都是通过其自身的 shared_future 对象副本进行访问，则是安全的。\",\"std::string fetch_data() { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 return \\\"从网络获取的数据！\\\"; } int main() { std::future<std::string> future_data = std::async(std::launch::async, fetch_data); // // 转移共享状态，原来的 future 被清空 valid() == false std::shared_future<std::string> shared_future_data = future_data.share(); // 第一个线程等待结果并访问数据 std::thread thread1([&shared_future_data] { std::cout << \\\"线程1：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程1：收到数据：\\\" << shared_future_data.get() << std::endl; }); // 第二个线程等待结果并访问数据 std::thread thread2([&shared_future_data] { std::cout << \\\"线程2：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程2：收到数据：\\\" << shared_future_data.get() << std::endl; }); thread1.join(); thread2.join(); } \",\"这段代码存在数据竞争，就如同我们先前所说：“在多个线程中对同一个 std::shared_future 对象进行操作时（如果没有进行同步保护）存在竞争条件”，它并没有提供线程安全的方式。而我们的 lambda 是按引用传递，也就是“同一个”进行操作了。可以改为：\",\"std::string fetch_data() { std::this_thread::sleep_for(std::chrono::seconds(1)); // 模拟耗时操作 return \\\"从网络获取的数据！\\\"; } int main() { std::future<std::string> future_data = std::async(std::launch::async, fetch_data); std::shared_future<std::string> shared_future_data = future_data.share(); std::thread thread1([shared_future_data] { std::cout << \\\"线程1：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程1：收到数据：\\\" << shared_future_data.get() << std::endl; }); std::thread thread2([shared_future_data] { std::cout << \\\"线程2：等待数据中...\\\" << std::endl; shared_future_data.wait(); std::cout << \\\"线程2：收到数据：\\\" << shared_future_data.get() << std::endl; }); thread1.join(); thread2.join(); } \",\"这样访问的就都是 std::shared_future 的副本了，我们的 lambda 按复制捕获 std::shared_future 对象，每个线程都有一个 shared_future 的副本，这样不会有任何问题。这一点和 std::shared_ptr 类似[1]。\",\"std::promise 也同，它的 get_future() 成员函数一样可以用来构造 std::shared_future，虽然它的返回类型是 std::future，不过不影响，这是因为 std::shared_future 有一个 std::future<T>&& 参数的构造函数，转移 std::future 的所有权。\",\"std::promise<std::string>p; std::shared_future<std::string>sf{ p.get_future() }; // 隐式转移所有权 \",\"就不需要再强调了。\"]},\"47\":{\"h\":\"限时等待\",\"t\":[\"阻塞调用会将线程挂起一段（不确定的）时间，直到对应的事件发生。通常情况下，这样的方式很好，但是在一些情况下，需要限定线程等待的时间，因为无限期地等待事件发生可能会导致性能下降或资源浪费。一个常见的例子是在很多网络库中的 connect 函数，这个函数调用是阻塞的，但是也是限时的，一定时间内没有连接到服务器就不会继续阻塞了，会进行其它处理，比如抛出异常。\",\"介绍两种指定超时的方式，一种是“时间段”，另一种是“时间点”，其实就是先前讲的 std::this::thread::sleep_for 与 std::this_thread::sleep_until 的区别。前者是需要指定等待一段时间（比如 10 毫秒）。而后者是指定等待到一个具体的时间点（比如到 2024-05-07T12:01:10.123）。多数函数都对两种超时方式进行处理。处理持续时间的函数以 _for 作为后缀，处理绝对时间的函数以 _until 作为后缀。\",\"条件变量 std::condition_variable 的等待函数，也有两个超时的版本 wait_for 和 wait_until 。它们和我们先前讲的 wait 成员函数一样有两个重载，可以选择是否传递一个谓词。它们相比于 wait 多了一个解除阻塞的可能，即：超过指定的时长或抵达指定的时间点。\",\"在讲述它的使用细节之前，我们还是要来先聊一下 C++ 中的时间库（chrono），指定时间的方式，它较为麻烦。我们分：时钟（clock）、时间段（duration）、*时间点（time point）*三个阶段稍微介绍一下。\"]},\"48\":{\"h\":\"时钟\",\"t\":[\"在 C++ 标准库中，时钟被视为时间信息的来源。C++ 定义了很多种时间类型，每种时钟类型都提供了四种不同的信息：\",\"当前时间\",\"时间类型\",\"时钟节拍\",\"稳定时钟\",\"当前时间可以通过静态成员函数 now 获取，例如，std::chrono::system_clock::now() 会返回系统的当前时间。特定的时间点则可以通过 time_point 来指定。system_clock::now() 的返回类型就是 time_point。\",\"时钟节拍被指定为 1/x（x 在不同硬件上有不同的值）秒，这是由时间周期所决定。假设一个时钟一秒有 25 个节拍，因此一个周期为 std::ratio<1,25> 。当一个时钟的时钟节拍每 2.5 秒一次，周期就可以表示为 std::ratio<5,2>。\",\"类模板 std::chrono::duration 表示时间间隔。\",\"template<class Rep, class Period = std::ratio<1>> class duration; \",\"std::ratio 是一个分数类模板，它有两个非类型模板参数，也就是分子与分母，分母有默认实参 1，所以 std::ratio<1> 等价于 std::ratio<1,1>。\",\"如你所见，它默认的时钟节拍是 1，这是一个很重要的类，标准库通过它定义了很多的时间类型，比如 std::chrono::minutes 是分钟类型，那么它的 Period 就是 std::ratio<60> ，因为一分钟等于 60 秒。\",\"std::chrono::minutes std::chrono::duration</* int29 */, std::ratio<60>> \",\"稳定时钟（Steady Clock）是指提供稳定、持续递增的时间流逝信息的时钟。它的特点是不受系统时间调整或变化的影响，即使在系统休眠或时钟调整的情况下，它也能保持稳定。在 C++ 标准库中，std::chrono::steady_clock 就是一个稳定时钟。它通常用于测量时间间隔和性能计时等需要高精度和稳定性的场景。可以通过 is_steady 静态常量判断当前时钟是否是稳定时钟。\",\"稳定时钟的主要优点在于，它可以提供相对于起始时间的稳定的递增时间，因此适用于需要保持时间顺序和不受系统时间变化影响的应用场景。相比之下，像 std::chrono::system_clock 这样的系统时钟可能会受到系统时间调整或变化的影响，因此在某些情况下可能不适合对时间间隔进行精确测量。\",\"不管使用哪种时钟获取时间，C++ 都提供了函数，可以将时间点转换为 time_t 类型的值：\",\"auto now = std::chrono::system_clock::now(); time_t now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Current time:\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\\n\\\"); auto now2 = std::chrono::steady_clock::now(); now_time = std::chrono::system_clock::to_time_t(now); std::cout << \\\"Current time:\\\\t\\\" << std::put_time(std::localtime(&now_time), \\\"%H:%M:%S\\\\n\\\"); \",\"C++ 的时间库极其繁杂，主要在于类型之多，以及实现之复杂。根据我们的描述，了解基本构成、概念、使用，即可。\"]},\"49\":{\"h\":\"时间段\",\"t\":[\"时间部分最简单的就是时间段，主要的内容就是我们上面讲的类模板 std::chrono::duration ，它用于对时间段进行处理。\",\"它的第一个参数是类型表示，第二个参数就是先前提到的“节拍”，需要传递一个 std::ratio 类型，也就是一个时钟所用的秒数。\",\"标准库在 std::chrono 命名空间内为时间段提供了一系列的类型，它们都是通过 std::chrono::duration 定义的别名：\",\"using nanoseconds = duration<long long, nano>; using microseconds = duration<long long, micro>; using milliseconds = duration<long long, milli>; using seconds = duration<long long>; using minutes = duration<int, ratio<60>>; using hours = duration<int, ratio<3600>>; // CXX20 using days = duration<int, ratio_multiply<ratio<24>, hours::period>>; using weeks = duration<int, ratio_multiply<ratio<7>, days::period>>; using years = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>; using months = duration<int, ratio_divide<years::period, ratio<12>>>; \",\"如上，是 MSVC STL 定义的，看似有一些没有使用 ratio 作为第二个参数，其实也还是别名罢了，见：\",\"using milli = ratio<1, 1000>; \",\"并且为了方便使用，在 C++14 标准库增加了时间字面量，存在于 std::chrono_literals 命名空间中，让我们得以简单的使用：\",\"using namespace std::chrono_literals; auto one_nanosecond = 1ns; auto one_microsecond = 1us; auto one_millisecond = 1ms; auto one_second = 1s; auto one_minute = 1min; auto one_hour = 1h; \",\"当不要求截断值的情况下（时转换为秒时没问题的，但反过来不行）时间段有隐式转换，显式转换可以由 std::chrono::duration_cast<> 来完成。\",\"std::chrono::milliseconds ms{ 3999 }; std::chrono::seconds s = std::chrono::duration_cast<std::chrono::seconds>(ms); std::cout << s.count() << '\\\\n'; \",\"这里的结果是截断的，而不会进行所谓的四舍五入，最终的值是 3。\",\"时间库支持四则运算，可以对两个时间段进行加减乘除。时间段对象可以通过 count() 成员函数获得计次数。例如 std::chrono::milliseconds{123}.count() 的结果就是 123。\",\"基于时间段的等待都是由 std::chrono::duration<> 来完成。例如：等待一个 future 对象在 35 毫秒内变为就绪状态：\",\"std::future<int> future = std::async([] {return 6; }); if (future.wait_for(35ms) == std::future_status::ready) std::cout << future.get() << '\\\\n'; \",\"wait_for： 等待结果，如果在指定的超时间隔后仍然无法得到结果，则返回。它的返回类型是一个枚举类 std::future_status ，三个枚举项分别表示三种 future 状态。\",\"deferred\",\"共享状态持有的函数正在延迟运行，结果将仅在明确请求时计算\",\"ready\",\"共享状态就绪\",\"timeout\",\"共享状态在经过指定的等待时间内仍未就绪\",\"timeout 超时，也很好理解，那我们就提一下 deferred ：\",\"auto future = std::async(std::launch::deferred, []{}); if (future.wait_for(35ms) == std::future_status::deferred) std::cout << \\\"future_status::deferred \\\" << \\\"正在延迟执行\\\\n\\\"; future.wait(); // 在 wait() 或 get() 调用时执行，不创建线程 \"]},\"50\":{\"h\":\"时间点\",\"t\":[\"时间点可用 std::chrono::time_point<> 来表示，第一个模板参数用来指定使用的时钟，第二个模板参数用来表示时间单位（std::chrono::duration<>）。时间点顾名思义就是时间中的一个点，在 C++ 中用于表达当前时间，先前提到的静态成员函数 now() 获取当前时间，它们的返回类型都是 std::chrono::time_point。\",\"template< class Clock, class Duration = typename Clock::duration > class time_point; \",\"如你所见，它的第二个模板参数的时间单位，默认是根据第一个参数时钟得到的，所以假设有类型：\",\"std::chrono::time_point<std::chrono::system_clock> \",\"那它等价于：\",\"std::chrono::time_point<std::chrono::system_clock, std::chrono::system_clock::duration> \",\"也就是说第二个参数的实际类型是：\",\"std::chrono::duration<long long,std::ratio<1, 10000000>> // // 100 nanoseconds \",\"更多的问题参见源码都很直观。\",\"同样的，时间点也支持加减以及比较操作。\",\"std::chrono::steady_clock::now() + std::chrono::nanoseconds(500); // 500 纳秒之后的时间 \",\"可以减去一个时间点，结果是两个时间点的时间差。这对于代码块的计时是很有用的，如：\",\"auto start = std::chrono::steady_clock::now(); std::this_thread::sleep_for(std::chrono::seconds(1)); auto end = std::chrono::steady_clock::now(); auto result = std::chrono::duration_cast<std::chrono::milliseconds>(end - start); std::cout << result.count() << '\\\\n'; \",\"运行测试。\",\"我们进行了一个显式的转换，最终输出的是以毫秒作为单位，有可能不会是 1000，没有这么精确。\",\"等待条件变量满足条件——带超时功能\",\"using namespace std::chrono_literals; std::condition_variable cv; bool done{}; std::mutex m; bool wait_loop() { const auto timeout = std::chrono::steady_clock::now() + 500ms; std::unique_lock<std::mutex> lk{ m }; while (!done) { if (cv.wait_until(lk, timeout) == std::cv_status::timeout) { std::cout << \\\"超时 500ms\\\\n\\\"; return false; } } return true; } \",\"运行测试。\",\"_until 也就是等待到一个时间点，我们设置的是等待到当前时间往后 500 毫秒。如果超过了这个时间还没有被唤醒，那就打印超时，并退出循环，函数返回 false。\",\"到此，时间点的知识也就足够了。\"]},\"51\":{\"h\":\"异步任务执行\",\"t\":[\"在开发带有 UI 的程序时，主线程用于处理 UI 更新和用户交互，如果在主线程中执行耗时任务会导致界面卡顿。因此，需要使用异步任务来减轻主线程的压力。以下是一个使用 Qt 实现异步任务的示例，展示了如何在不阻塞 UI 线程的情况下执行耗时任务，并更新进度条。\"]},\"52\":{\"h\":\"背景介绍\",\"t\":[\"在 Qt 中，GUI 控件通常只能在创建它们的线程中进行操作，因为它们是线程不安全的。我们可以使用 QMetaObject::invokeMethod 来跨线程调用主线程上的控件方法，从而在其他线程中安全地更新 UI 控件。以下代码示例展示了如何通过 QMetaObject::invokeMethod 确保 UI 控件的更新操作在主线程中执行。\",\"void task(){ future = std::async(std::launch::async, [=] { QMetaObject::invokeMethod(this, [this] { button->setEnabled(false); progressBar->setRange(0, 1000); button->setText(\\\"正在执行...\\\"); }); for (int i = 0; i < 1000; ++i) { std::this_thread::sleep_for(10ms); QMetaObject::invokeMethod(this, [this, i] { progressBar->setValue(i); }); } QMetaObject::invokeMethod(this, [this] { button->setText(\\\"start\\\"); button->setEnabled(true); }); }); } \",\"上面的代码创建了一个异步任务，并指明了执行策略。任务在线程中执行，不会阻塞 UI 线程。如果不这样做，界面将会卡顿（可以尝试将函数的第一行与最后一行注释掉以验证这一点）。\",\"在启动进度条后，能够正常点击“测试”按钮并触发弹窗，说明 UI 没有被阻塞。相反，如果不使用线程，界面将会卡住，无法点击“测试”按钮或移动窗口。\"]},\"53\":{\"h\":\"项目说明\",\"t\":[\"项目使用 Visual Studio + CMake，可以直接安装 Qt 插件后打开此项目。项目结构简单，所有界面与设置均通过代码控制，无需进行其他 UI 操作。只需关注 async_progress_bar.h、async_progress_bar.cpp 和 main.cpp 这三个文件，它们位于仓库的 code 文件夹中。\"]},\"54\":{\"h\":\"完整代码实现\",\"t\":[\"class async_progress_bar : public QMainWindow{ Q_OBJECT public: async_progress_bar(QWidget *parent = nullptr); ~async_progress_bar(); void task(){ future = std::async(std::launch::async, [=] { QMetaObject::invokeMethod(this, [this] { // 这里显示的线程 ID 就是主线程，代表这些任务就是在主线程，即 UI 线程执行 QMessageBox::information(nullptr, \\\"线程ID\\\", std::to_string(_Thrd_id()).c_str()); button->setEnabled(false); progress_bar->setRange(0, 1000); button->setText(\\\"正在执行...\\\"); }); for (int i = 0; i <= 1000; ++i) { std::this_thread::sleep_for(10ms); QMetaObject::invokeMethod(this, [this, i] { progress_bar->setValue(i); }); } QMetaObject::invokeMethod(this, [this] { button->setText(\\\"start\\\"); button->setEnabled(true); }); // 不在 invokeMethod 中获取线程 ID，这里显示的是子线程的ID auto s = std::to_string(_Thrd_id()); QMetaObject::invokeMethod(this, [=] { QMessageBox::information(nullptr, \\\"线程ID\\\", s.c_str()); }); }); } private: QString progress_bar_style = \\\"QProgressBar {\\\" \\\" border: 2px solid grey;\\\" \\\" border-radius: 5px;\\\" \\\" background-color: lightgrey;\\\" \\\" text-align: center;\\\" // 文本居中 \\\" color: #000000;\\\" // 文本颜色 \\\"}\\\" \\\"QProgressBar::chunk {\\\" \\\" background-color: #7FFF00;\\\" \\\" width: 10px;\\\" // 设置每个进度块的宽度 \\\" font: bold 14px;\\\" // 设置进度条文本字体 \\\"}\\\"; QString button_style = \\\"QPushButton {\\\" \\\" text-align: center;\\\" // 文本居中 \\\"}\\\"; QProgressBar* progress_bar{}; QPushButton* button{}; QPushButton* button2{}; Ui::async_progress_barClass ui{}; std::future<void>future; }; // 创建控件 设置布局、样式 连接信号 async_progress_bar::async_progress_bar(QWidget *parent) : QMainWindow{ parent }, progress_bar{ new QProgressBar(this) }, button{ new QPushButton(\\\"start\\\",this) },button2{ new QPushButton(\\\"测试\\\",this) } { ui.setupUi(this); progress_bar->setStyleSheet(progress_bar_style); progress_bar->setRange(0, 1000); button->setMinimumSize(100, 50); button->setMaximumWidth(100); button->setStyleSheet(button_style); button->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed); button2->setMinimumSize(100, 50); button2->setMaximumWidth(100); button2->setStyleSheet(button_style); button2->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Fixed); QVBoxLayout* layout = new QVBoxLayout; layout->addWidget(progress_bar); layout->addWidget(button, 0, Qt::AlignHCenter); layout->addWidget(button2, 0, Qt::AlignHCenter); // 设置窗口布局为垂直布局管理器 centralWidget()->setLayout(layout); connect(button, &QPushButton::clicked, this, &async_progress_bar::task); connect(button2, &QPushButton::clicked, []{ QMessageBox::information(nullptr, \\\"测试\\\", \\\"没有卡界面！\\\"); }); } \"]},\"55\":{\"h\":\"注意事项\",\"t\":[\"QMetaObject::invokeMethod 的 lambda 是在主线程运行的，通过显示的线程 ID 可以验证这一点。\",\"使用 std::async 的 std::launch::async 参数强制异步执行任务，以确保任务在新线程中运行。\"]},\"56\":{\"h\":\"跨平台兼容性\",\"t\":[\"C++11 的 std::this_thread::get_id() 返回的内部类型没办法直接转换为 unsigned int，我们就直接使用了 win32 的 API _Thrd_id() 了。如果您是 Linux 之类的环境，使用 POSIX 接口 pthread_self()。\"]},\"57\":{\"h\":\"实践建议\",\"t\":[\"这个例子其实很好的展示了多线程异步的作用，因为有 UI，所以很直观，毕竟如果你不用线程，那么不就卡界面了，用了就没事。\",\"建议下载并运行此项目，通过实际操作理解代码效果。同时，可以尝试修改代码，观察不同情况下 UI 的响应情况，以加深对异步任务处理的理解。\"]},\"58\":{\"h\":\"C++20 信号量\",\"t\":[\"C++20 引入了信号量，对于那些熟悉操作系统或其它并发支持库的开发者来说，这个同步设施的概念应该不会感到陌生。信号量源自操作系统，是一个古老而广泛应用的同步设施，在各种编程语言中都有自己的抽象实现。然而，C++ 标准库对其的支持却来得很晚，在 C++20 中才得以引入。\",\"信号量是一个非常轻量简单的同步设施，它维护一个计数，这个计数不能小于 0。信号量提供两种基本操作：释放（增加计数）和等待（减少计数）。如果当前信号量的计数值为 0，那么执行“等待”操作的线程将会一直阻塞，直到计数大于 0，也就是其它线程执行了“释放”操作。\",\"C++ 提供了两个信号量类型：std::counting_semaphore 与 std::binary_semaphore，定义在 <semaphore> 中。\",\"binary_semaphore[2] 只是 counting_semaphore 的一个特化别名：\",\"using binary_semaphore = counting_semaphore<1>; \",\"好了，我们举一个简单的例子来使用一下：\",\"// 全局二元信号量对象 // 设置对象初始计数为 0 std::binary_semaphore smph_signal_main_to_thread{ 0 }; std::binary_semaphore smph_signal_thread_to_main{ 0 }; void thread_proc() { smph_signal_main_to_thread.acquire(); std::cout << \\\"[线程] 获得信号\\\" << std::endl; std::this_thread::sleep_for(3s); std::cout << \\\"[线程] 发送信号\\\\n\\\"; smph_signal_thread_to_main.release(); } int main() { std::jthread thr_worker{ thread_proc }; std::cout << \\\"[主] 发送信号\\\\n\\\"; smph_signal_main_to_thread.release(); smph_signal_thread_to_main.acquire(); std::cout << \\\"[主] 获得信号\\\\n\\\"; } \",\"运行结果：\",\"[主] 发送信号 [线程] 获得信号 [线程] 发送信号 [主] 获得信号 \",\"acquire 函数就是我们先前说的“等待”（原子地减少计数），release 函数就是\\\"释放\\\"（原子地增加计数）。\",\"信号量常用于发信/提醒而非互斥，通过初始化该信号量为 0 从而阻塞尝试 acquire() 的接收者，直至提醒者通过调用 release(n) “发信”。在此方面可把信号量当作条件变量的替代品，通常它有更好的性能。\",\"假设我们有一个 Web 服务器，它只能处理有限数量的并发请求。为了防止服务器过载，我们可以使用信号量来限制并发请求的数量。\",\"// 定义一个信号量，最大并发数为 3 std::counting_semaphore<3> semaphore{ 3 }; void handle_request(int request_id) { // 请求到达，尝试获取信号量 std::cout << \\\"进入 handle_request 尝试获取信号量\\\\n\\\"; semaphore.acquire(); std::cout << \\\"成功获取信号量\\\\n\\\"; // 此处延时三秒可以方便测试，会看到先输出 3 个“成功获取信号量”，因为只有三个线程能成功调用 acquire，剩余的会被阻塞 std::this_thread::sleep_for(3s); // 模拟处理时间 std::random_device rd; std::mt19937 gen{ rd() }; std::uniform_int_distribution<> dis(1, 5); int processing_time = dis(gen); std::this_thread::sleep_for(std::chrono::seconds(processing_time)); std::cout << std::format(\\\"请求 {} 已被处理\\\\n\\\", request_id); semaphore.release(); } int main() { // 模拟 10 个并发请求 std::vector<std::jthread> threads; for (int i = 0; i < 10; ++i) { threads.emplace_back(handle_request, i); } } \",\"运行测试。\",\"这段代码很简单，以至于我们可以在这里来再说一条概念：\",\"counting_semaphore 是一个轻量同步原语，能控制对共享资源的访问。不同于 std::mutex，counting_semaphore允许同一资源进行多个并发的访问，至少允许 LeastMaxValue 个同时的访问者。\",\"binary_semaphore 是 std::counting_semaphore 的特化的别名，其 LeastMaxValue 为 1。\",\"LeastMaxValue 是我们设置的非类型模板参数，意思是信号量维护的计数最大值。我们这段代码设置的是 3，也就是允许 3 个同时访问者。事实上我们的代码就是这样做的。\",\"牢记信号量的基本的概念不变，计数的值不能小于 0，如果当前信号量的计数值为 0，那么执行“等待”（acquire）操作的线程将会一直阻塞。明白这点，那么就都不存在问题。\",\"通过这种方式，可以有效控制 Web 服务器处理并发请求的数量，防止服务器过载。\"]},\"59\":{\"h\":\"C++20 闩与屏障\",\"t\":[\"闩 (latch) 与屏障 (barrier) 是线程协调机制，允许任何数量的线程阻塞直至期待数量的线程到达。闩不能重复使用，而屏障则可以。\",\"std::latch：单次使用的线程屏障\",\"std::barrier：可复用的线程屏障\",\"它们定义在标头 <latch>。\",\"与信号量类似，屏障也是一种古老而广泛应用的同步机制。许多系统 API 提供了对屏障机制的支持，例如 POSIX 和 Win32。此外，OpenMP 也提供了屏障机制来支持多线程编程。\"]},\"60\":{\"h\":\"\",\"t\":[\"“闩”，这个字其实个人觉得是不常见，“门闩” 是指们背后用来关门的棍子。好了好了，不用在意，在 C++ 中就是先前说的：单次使用的线程屏障。\",\"latch 类维护着一个 std::ptrdiff_t 类型的计数[3]，且只能减少计数，无法增加计数。在创建对象的时候初始化计数器的值。线程可以阻塞，直到 latch 对象的计数减少到零。由于无法增加计数，这使得 latch 成为一种单次使用的屏障。\",\"std::latch work_done{ 3 }; void work(){ std::cout << \\\"等待其它线程执行\\\\n\\\"; work_done.wait(); // 等待计数为 0 std::cout << \\\"任务开始执行\\\\n\\\"; } int main(){ std::jthread thread{ work }; std::this_thread::sleep_for(3s); work_done.count_down(); // 默认值是 1 work_done.count_down(2); // 传递参数 减少计数 2 } \",\"运行测试。\",\"通过调用 wait 函数阻塞子线程，直到主线程调用 count_down 函数原子地将计数减至 0 ，得以解除阻塞。相信这个例子就能很清楚的展示 latch 的使用，它的逻辑比信号量还要简单。\"]},\"61\":{\"h\":\"\"},\"62\":{\"h\":\"总结\",\"t\":[\"在并发编程中，同步操作对于并发编程至关重要。如果没有同步，线程基本上就是独立的，因其任务之间的相关性，才可作为一个整体执行（比如第二章的并行求和）。本章讨论了多种用于同步操作的工具，包括条件变量、future、promise、package_task、信号量。同时，详细介绍了 C++ 时间库的知识，以使用并发支持库中的“限时等待”。还使用 CMake + Qt 构建了一个带有 UI 界面的示例，展示异步多线程的必要性。\",\"在讨论了 C++ 中的高级工具之后，现在让我们来看看底层工具：C++ 内存模型与原子操作。\",\"注：多个线程能在不同的 shared_ptr 对象上调用所有成员函数（包含复制构造函数与复制赋值）而不附加同步，即使这些实例是同一对象的副本且共享所有权也是如此。若多个执行线程访问同一 shared_ptr 对象而不同步，且任一线程使用 shared_ptr 的非 const 成员函数，则将出现数据竞争；std::atomic<shared_ptr> 能用于避免数据竞争。文档。 ↩︎\",\"注：如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore），这就是这个类型名字的由来。 ↩︎\",\"注：通常的实现是直接保有一个 std::atomic<std::ptrdiff_t> 私有数据成员，以保证计数修改的原子性。原子类型在我们第五章的内容会详细展开。 ↩︎\"]},\"63\":{\"h\":\"内存模型与原子操作\",\"t\":[\"内存模型定义了多线程程序中，读写操作如何在不同线程之间可见，以及这些操作在何种顺序下执行。内存模型确保程序的行为在并发环境下是可预测的。\",\"原子操作即不可分割的操作。系统的所有线程，不可能观察到原子操作完成了一半。\",\"最基础的概念就是如此，这里不再过多赘述，后续还会详细展开内存模型的问题。\"]},\"64\":{\"h\":\"原子操作\",\"t\":[\"int a = 0; void f(){ ++a; } \",\"显然，++a 是非原子操作，也就是说在多线程中可能会被另一个线程观察到只完成一半。\",\"线程 A 和线程 B 同时开始修改变量 a 的值。\",\"线程 A 对 a 执行递增操作，但还未完成。\",\"在线程 A 完成递增操作之前，线程 B 也执行了递增操作。\",\"线程 C 读取 a 的值。\",\"线程 C 到底读取到多少不确定，a 的值是多少也不确定。显然，这构成了数据竞争，出现了未定义行为。\",\"在之前的内容中，我们讲述了使用很多同步设施，如互斥量，来保护共享资源。\",\"std::mutex m; void f() { std::lock_guard<std::mutex> lc{ m }; ++a; } \",\"通过互斥量的保护，即使 ++a 本身不是原子操作，逻辑上也可视为原子操作。互斥量确保了对共享资源的读写是线程安全的，避免了数据竞争问题。\",\"不过这显然不是我们的重点。我们想要的是一种原子类型，它的所有操作都直接是原子的，不需要额外的同步设施进行保护。C++11 引入了原子类型 std::atomic，在下节我们会详细讲解。\"]},\"65\":{\"h\":\"原子类型\",\"t\":[\"标准原子类型定义在头文件 <atomic> 中。这些类型的操作都是原子的，语言定义中只有这些类型的操作是原子的，虽然也可以用互斥量来模拟原子操作（见上文）。标准的原子的类型实现可能是：它们几乎都有一个 is_lock_free() 成员函数，这个函数可以让用户查询某原子类型的操作是直接用的原子指令（返回 true），还是内部用了锁实现（返回 false）。\",\"原子操作可以代替互斥量，来进行同步操作，也能带来更高的性能。但是如果它的内部使用互斥量实现，那么不可能有性能的提升。\",\"在 C++17 中，所有原子类型都有一个 static constexpr 的数据成员 is_always_lock_free 。如果当前环境上的原子类型 X 是无锁类型，那么 X::is_always_lock_free 将返回 true 。例如：\",\"std::atomic<int>::is_always_lock_free // true 或 false \",\"标准库还提供了一组宏 ATOMIC_xxx_LOCK_FREE ，在编译时对各种整数原子类型是否无锁进行判断。\",\"// (C++11 起) #define ATOMIC_BOOL_LOCK_FREE /* 未指定 */ #define ATOMIC_CHAR_LOCK_FREE /* 未指定 */ #define ATOMIC_CHAR16_T_LOCK_FREE /* 未指定 */ #define ATOMIC_CHAR32_T_LOCK_FREE /* 未指定 */ #define ATOMIC_WCHAR_T_LOCK_FREE /* 未指定 */ #define ATOMIC_SHORT_LOCK_FREE /* 未指定 */ #define ATOMIC_INT_LOCK_FREE /* 未指定 */ #define ATOMIC_LONG_LOCK_FREE /* 未指定 */ #define ATOMIC_LLONG_LOCK_FREE /* 未指定 */ #define ATOMIC_POINTER_LOCK_FREE /* 未指定 */ // (C++20 起) #define ATOMIC_CHAR8_T_LOCK_FREE /* 未指定 */ \",\"对于一定有锁的内建原子类型是 0；\",\"对于有时无锁的内建原子类型是 1；\",\"对于一定无锁的内建原子类型是 2。\",\"我们可以使用这些宏来对代码进行编译时的优化和检查，以确保在特定平台上原子操作的性能。例如，如果我们知道某些操作在目标平台上是无锁的，那么我们可以利用这一点进行性能优化。如果这些操作在目标平台上是有锁的，我们可能会选择其它同步机制。\",\"// 检查 std::atomic<int> 是否总是无锁 if constexpr(std::atomic<int>::is_always_lock_free) { std::cout << \\\"当前环境 std::atomic<int> 始终是无锁\\\" << std::endl; } else { std::cout << \\\"当前环境 std::atomic<int> 并不总是无锁\\\" << std::endl; } // 使用 ATOMIC_INT_LOCK_FREE 宏进行编译时检查 #if ATOMIC_INT_LOCK_FREE == 2 std::cout << \\\"int 类型的原子操作一定无锁的。\\\" << std::endl; #elif ATOMIC_INT_LOCK_FREE == 1 std::cout << \\\"int 类型的原子操作有时是无锁的。\\\" << std::endl; #else std::cout << \\\"int 类型的原子操作一定有锁的。\\\" << std::endl; #endif \",\"运行测试。\",\"如你所见，我们写了一个简单的示例，展示了如何使用 C++17 的静态数据成员 is_always_lock_free 和预处理宏来让程序执行不同的代码。\",\"因为 is_always_lock_free 是编译期常量，所以我们可以使用 C++17 引入的 constexpr if ，它可以在编译阶段进行决策，避免了运行时的判断开销，提高了性能。\",\"宏则更是简单了，最基本的预处理器判断，在预处理阶段就选择执行合适的代码。\",\"在实际应用中，如果一个类型的原子操作总是无锁的，我们可以更放心地在性能关键的代码路径中使用它。例如，在高频交易系统、实时系统或者其它需要高并发性能的场景中，无锁的原子操作可以显著减少锁的开销和争用，提高系统的吞吐量和响应时间。\",\"另一方面，如果发现某些原子类型在目标平台上是有锁的，我们可以考虑以下优化策略：\",\"使用不同的数据结构：有时可以通过改变数据结构来避免对原子操作的依赖。\",\"减少原子操作的频率：通过批处理等技术，减少对原子操作的调用次数。\",\"使用更高效的同步机制：在一些情况下，其它同步机制（如读写锁）可能比原子操作更高效。\",\"除了直接使用 std::atomic 模板外，也可以使用原子类型的别名。这个数量非常之多，见 MSVC STL。\",\"对于标准内建类型的别名，就是在原子类型的类型名前面加上 atomic_ 的前缀：atomic_T。不过 signed 缩写 s、unsigned 缩写 u、long long 缩写 llong。\",\"using atomic_char = atomic<char>; using atomic_schar = atomic<signed char>; using atomic_uchar = atomic<unsigned char>; using atomic_short = atomic<short>; using atomic_ushort = atomic<unsigned short>; using atomic_int = atomic<int>; using atomic_uint = atomic<unsigned int>; using atomic_long = atomic<long>; using atomic_ulong = atomic<unsigned long>; using atomic_llong = atomic<long long>; using atomic_ullong = atomic<unsigned long long>; \",\"通常 std::atomic 对象不可进行复制、移动、赋值，因为它们的复制构造与复制赋值运算符被定义为弃置的。不过可以隐式转换成对应的内置类型，因为它有转换函数。\",\"atomic(const atomic&) = delete; atomic& operator=(const atomic&) = delete; operator T() const noexcept; \",\"可以使用 load()、store()、exchange()、compare_exchange_weak() 和 compare_exchange_strong() 等成员函数对 std::atomic 进行操作。如果是整数类型的特化，还支持 ++、--、+=、-=、&=、|=、^= 、fetch_add、fetch_sub 等操作方式。在后面详细的展开使用。\",\"std::atomic 类模板不仅只能使用标准库为我们定义的特化类型，我们也完全可以自定义类型创建对应的原子对象。不过因为是通用模板，操作仅限 load()、store()、exchange()、compare_exchange_weak() 、 compare_exchange_strong()，以及一个转换函数。\",\"模板 std::atomic 可用任何满足可复制构造 (CopyConstructible)及可复制赋值 (CopyAssignable)的可平凡复制 (TriviallyCopyable)类型 T 实例化。\",\"struct trivial_type { int x{}; float y{}; trivial_type() {} trivial_type(int a, float b) : x{ a }, y{ b } {} trivial_type(const trivial_type& other) = default; trivial_type& operator=(const trivial_type& other) = default; ~trivial_type() = default; }; \",\"验证自己的类型是否满足 std::atomic 要求，我们可以使用静态断言：\",\"static_assert(std::is_trivially_copyable<trivial_type>::value, \\\"\\\"); static_assert(std::is_copy_constructible<trivial_type>::value, \\\"\\\"); static_assert(std::is_move_constructible<trivial_type>::value, \\\"\\\"); static_assert(std::is_copy_assignable<trivial_type>::value, \\\"\\\"); static_assert(std::is_move_assignable<trivial_type>::value, \\\"\\\"); \",\"程序能通过编译即代表满足要求。如果不满足要求，静态断言求值中第一个表达式求值为 false，则编译错误。显然我们的类型满足要求，我们可以尝试使用一下它：\",\"// 创建一个 std::atomic<trivial_type> 对象 std::atomic<trivial_type> atomic_my_type { trivial_type{ 10, 20.5f } }; // 使用 store 和 load 操作来设置和获取值 trivial_type new_value{ 30, 40.5f }; atomic_my_type.store(new_value); trivial_type loadedValue = atomic_my_type.load(); std::cout << \\\"x: \\\" << loadedValue.x << \\\", y: \\\" << loadedValue.y << std::endl; // 使用 exchange 操作 trivial_type exchanged_value = atomic_my_type.exchange(trivial_type{ 50, 60.5f }); std::cout << \\\"交换前的 x: \\\" << exchanged_value.x << \\\", 交换前的 y: \\\" << exchanged_value.y << std::endl; std::cout << \\\"交换后的 x: \\\" << atomic_my_type.load().x << \\\", 交换后的 y: \\\" << atomic_my_type.load().y << std::endl; \",\"运行测试。\",\"没有问题，不过其实我们的 trivial_type 直接改成：\",\"struct trivial_type { int x; float y; }; \",\"运行测试。\",\"也是完全可以的，满足要求。先前只是为了展示一下显式写明的情况。\",\"原子类型的每个操作函数，都有一个内存序参数，这个参数可以用来指定执行顺序，在后面的内容会详细讲述，现在只需要知道操作分为三类：\",\"Store 操作（存储操作）：可选的内存序包括 memory_order_relaxed、memory_order_release、memory_order_seq_cst。\",\"Load 操作（加载操作）：可选的内存序包括 memory_order_relaxed、memory_order_consume、memory_order_acquire、memory_order_seq_cst。\",\"Read-modify-write（读-改-写）操作：可选的内存序包括 memory_order_relaxed、memory_order_consume、memory_order_acquire、memory_order_release、memory_order_acq_rel、memory_order_seq_cst。\",\"本节主要广泛介绍 std::atomic，而未展开具体使用。在后续章节中，我们将更详细地讨论一些版本，如 std::atomic<bool>，并介绍其成员函数和使用方法。\"]},\"66\":{\"h\":\"\",\"t\":[\"std::atomic_flag 是最简单的原子类型，这个类型的对象可以在两个状态间切换：设置（true）和清除（false）。它很简单，通常只是用作构建一些库设施，不会单独使用或直接面向普通开发者。\",\"在 C++20 之前，std::atomic_flag 类型的对象需要以 ATOMIC_FLAG_INIT 初始化，可以确保此时对象处于 \\\"清除\\\"（false）状态。\",\"std::atomic_flag f = ATOMIC_FLAG_INIT; \",\"在 C++20 中 std::atomic_flag 的默认构造函数保证对象为“清除”（false）状态，就不再需要使用 ATOMIC_FLAG_INIT。\",\"ATOMIC_FLAG_INIT 其实并不是什么复杂的东西，它在不同的标准库实现中只是简单的初始化：在 MSVC STL 它只是一个 {}，在 libstdc++ 与 libc++ 它只是一个 { 0 }。也就是说我们可以这样初始化：\",\"std::atomic_flag f ATOMIC_FLAG_INIT; std::atomic_flag f2 = {}; std::atomic_flag f3{}; std::atomic_flag f4{ 0 }; \",\"使用 ATOMIC_FLAG_INIT 宏只是为了统一，我们知道即可。\",\"当标志对象已初始化，它只能做三件事情：销毁、清除、设置。这些操作对应的函数分别是：\",\"clear() （清除）：将标志对象的状态原子地更改为清除（false）\",\"test_and_set（测试并设置）：将标志对象的状态原子地更改为设置（true），并返回它先前保有的值。\",\"销毁：对象的生命周期结束时，自动调用析构函数进行销毁操作。\",\"每个操作都可以指定内存顺序。clear() 是一个“读-改-写”操作，可以应用任何内存顺序。默认的内存顺序是 memory_order_seq_cst。例如：\",\"f.clear(std::memory_order_release); bool r = f.test_and_set(); \",\"将 f 的状态原子地更改为清除（false），指明 memory_order_release 内存序。\",\"将 f 的状态原子地更改为设置（true），并返回它先前保有的值给 r。使用默认的 memory_order_seq_cst 内存序。\",\"不用着急，这里还不是详细展开聊内存序的时候。\",\"std::atomic_flag不可复制不可移动不可赋值。这不是 std::atomic_flag 特有的，而是所有原子类型共有的属性。原子类型的所有操作都是原子的，而赋值和复制涉及两个对象，破坏了操作的原子性。复制构造和复制赋值会先读取第一个对象的值，然后再写入另一个对象。对于两个独立的对象，这里实际上有两个独立的操作，合并这两个操作无法保证其原子性。因此，这些操作是不被允许的。\",\"有限的特性使得 std::atomic_flag 非常适合用作制作自旋锁。\",\"class spinlock_mutex { std::atomic_flag flag{}; public: spinlock_mutex()noexcept = default; void lock()noexcept { while (flag.test_and_set(std::memory_order_acquire)); } void unlock()noexcept { flag.clear(std::memory_order_release); } }; \",\"我们可以简单的使用测试一下，它是有效的：\",\"spinlock_mutex m; void f(){ std::lock_guard<spinlock_mutex> lc{ m }; std::cout << \\\"😅😅\\\" << \\\"❤️❤️\\\\n\\\"; } \",\"运行测试。\",\"稍微聊一下原理，我们的 spinlock_mutex 对象中存储的 flag 对象在默认构造时是清除 (false) 状态。在 lock() 函数中调用 test_and_set 函数，它是原子的，只有一个线程能成功调用并将 flag 的状态原子地更改为设置 (true)，并返回它先前的值 (false)。此时，该线程成功获取了锁，退出循环。\",\"当 flag 对象的状态为设置 (true) 时，其线程调用 test_and_set 函数会返回 true，导致它们继续在循环中自旋，无法退出。直到先前持有锁的线程调用 unlock() 函数，将 flag 对象的状态原子地更改为清除 (false) 状态。此时，等待的线程中会有一个线程成功调用 test_and_set 返回 false，然后退出循环，成功获取锁。\",\"值得注意的是，我们只是稍微的讲一下使用 std::atomic_flag 实现自旋锁。不过并不推荐各位在实践中使用它，具体可参见 Linus Torvalds 的文章。其中有一段话说得很直接：\",\"我再说一遍：不要在用户空间中使用自旋锁，除非你真的知道自己在做什么。请注意，你知道自己在做什么的可能性基本上为零。 I repeat: do not use spinlocks in user space, unless you actually know what you're doing. And be aware that the likelihood that you know what you are doing is basically nil.\",\"然后就是推荐使用 std::mutex、pthread_mutex ，比自旋好的多。\",\"std::atomic_flag 的局限性太强，甚至不能当普通的 bool 标志那样使用。一般最好使用 std::atomic<bool>，下节，我们来使用它。\"]},\"67\":{\"h\":\"\",\"t\":[\"std::atomic<bool> 是最基本的整数原子类型 ，它相较于 std::atomic_flag 提供了更加完善的布尔标志。虽然同样不可复制不可移动，但可以使用非原子的 bool 类型进行构造，初始化为 true 或 false，并且能从非原子的 bool 对象赋值给 std::atomic<bool>：\",\"std::atomic<bool> b{ true }; b = false; \",\"不过这个 operator= 不同于通常情况，赋值操作 b = false 返回一个普通的 bool 值。\",\"这个行为不仅仅适用于std::atomic<bool>，而是适用于所有std::atomic类型。\",\"如果原子变量的赋值操作返回了一个引用，那么依赖这个结果的代码需要显式地进行加载（load），以确保数据的正确性。例如：\",\"std::atomic<bool>b {true}; auto& ref = (b = false); // 假设返回 atomic 引用 bool flag = ref.load(); // 必须显式调用 load() 加载 \",\"通过返回非原子值进行赋值，可以避免多余的加载（load）过程，得到实际存储的值。\",\"std::atomic<bool> b{ true }; bool new_value = (b = false); // new_value 将是 false \",\"使用 store 原子的替换当前对象的值，远好于 std::atomic_flag 的 clear()。test_and_set() 也可以换为更加通用常见的 exchange，它可以原子的使用新的值替换已经存储的值，并返回旧值。\",\"获取 std::atomic<bool> 的值有两种方式，调用 load() 函数，或者隐式转换。\",\"store 是一个存储操作、load 是一个加载操作、exchange 是一个“读-改-写”操作：\",\"std::atomic<bool> b; bool x = b.load(std::memory_order_acquire); b.store(true); x = b.exchange(false, std::memory_order_acq_rel); \",\"std::atomic<bool> 提供多个“读-改-写”的操作，exchange 只是其中之一。它还提供了一种存储方式：当前值与预期一致时，存储新值。\",\"这种操作叫做“比较/交换”，它的形式表现为 compare_exchange_weak() 和 compare_exchang_strong()\",\"compare_exchange_weak：尝试将原子对象的当前值与预期值进行比较[1]，如果相等则将其更新为新值并返回 true；否则，将原子对象的值加载进 expected（进行加载操作）并返回 false。此操作可能会由于某些硬件的特性而出现假失败[2]，需要在循环中重试。\",\"std::atomic<bool> flag{ false }; bool expected = false; while (!flag.compare_exchange_weak(expected, true)); \",\"运行测试。\",\"返回 false 即代表出现了假失败，因此需要在循环中重试。。\",\"compare_exchange_strong：类似于 compare_exchange_weak，但不会出现假失败，因此不需要重试。适用于需要确保操作成功的场合。\",\"std::atomic<bool> flag{ false }; bool expected = false; void try_set_flag() { // 尝试将 flag 设置为 true，如果当前值为 false if (flag.compare_exchange_strong(expected, true)) { std::cout << \\\"flag 为 false，设为 true。\\\\n\\\"; } else { std::cout << \\\"flag 为 true, expected 设为 true。\\\\n\\\"; } } \",\"运行测试。\",\"假设有两个线程运行 try_set_flag 函数，那么第一个线程调用 compare_exchange_strong 将原子对象 flag 设置为 true。第二个线程调用 compare_exchange_strong，当前原子对象的值为 true，而 expected 为 false，不相等，将原子对象的值设置给 expected。此时 flag 与 expected 均为 true。\",\"与 exchange 的另一个不同是，compare_exchange_weak 和 compare_exchange_strong 允许指定成功和失败情况下的内存序。这意味着你可以根据成功或失败的情况，为原子操作指定不同的内存序。\",\"std::atomic<bool> data{ false }; bool expected = false; // 成功时的内存序为 memory_order_release，失败时的内存序为 memory_order_acquire if (data.compare_exchange_weak(expected, true, std::memory_order_release, std::memory_order_acquire)) { // 操作成功 } else { // 操作失败 } \",\"另一个简单的原子类型是特化的原子指针，即：std::atomic<T*>，下一节我们来看看它是如何工作的。\"]},\"68\":{\"h\":\"\"},\"69\":{\"h\":\"\"},\"70\":{\"h\":\"内存次序\"},\"71\":{\"h\":\"前言\",\"t\":[\"事实上我们在前面就用到了不少的内存次序，只不过一直没详细展开讲解。\",\"在开始学习之前，我们需要强调一些基本的认识：\",\"内存次序是非常底层知识：对于普通开发者来说，了解内存次序并非硬性需求。如果您主要关注业务开发，可以直接跳过本节内容。如果您对内存次序感兴趣，则需要注意其复杂性和难以观察的特性，这将使学习过程具有一定挑战性。\",\"内存次序错误的使用难以察觉：即使通过多次（数以万计）运行也难以发现。这是因为许多内存次序问题是由于极端的、少见的情况下的竞争条件引起的，而这些情况很难被重现。此外，即使程序在某些平台上运行正常，也不能保证它在其他平台上也能表现良好，因为不同的 CPU 和编译器可能对内存操作的顺序有不同的处理（例如 x86 架构内存模型：Total Store Order (TSO)，是比较严格的内存模型）。因此，开发者必须依赖自己的知识和经验，以及可能的测试和调试技术，来发现和解决内存次序错误。\",\"错误难以被我们观察到的原因其实可以简单的说：\",\"CPU 与编译器不是神经病，没有好处不会闲的没事给你指令重排。\",\"编译器重排：编译器在编译代码时，为了提高性能，可以按照一定规则重新安排代码的执行顺序。例如，可以将不相关的指令重排，使得 CPU 流水线更加高效地执行指令。编译器优化需要遵守一个“如同规则（as-if rule）”，即不可改变可观察的副作用。\",\"CPU 重排：CPU 在运行程序时，也会对指令进行重排，以提高执行效率，减少等待时间。这种重排通常遵循一些硬件层面的优化规则，如内存访问的优化。\",\"你们可能还有疑问：“单线程能不能指令重排？”\",\"CPU 的指令重排必须遵循一定的规则，以确保程序的可观察副作用不受影响。对于单线程程序，CPU 会保证外部行为的一致性。对于多线程程序，需要开发者使用同步原语来显式地控制内存操作的顺序和可见性，确保多线程环境下的正确性。而标准库中提供的原子对象的原子操作，还可以设置内存次序。\",\"那有没有可能：\",\"“end 重排到 start 前面了！指令重排了！”\",\"这也就是前面说的，把 CPU 与编译器当神经病。各位写代码难道还要考虑下面这段，会不会指令重排导致先输出 end 吗？这显然不现实。\",\"print(\\\"start\\\"); // 1 print(\\\"end\\\"); // 2 \",\"不禁止就是有可能，但是我们无需在乎，就算真的 CPU 将 end 重排到 start 前面了，也得在可观测行为发生前回溯了。所以我一直在强调，这些东西，我们无需在意。\",\"好了，到此，基本认识也就足够了，以上的示例更多的是泛指，知到其表达的意思就好，这些还是简单直接且符合直觉的。\",\"注： 比较和复制是逐位的（类似 std::memcmp 和 std::memcpy）；不使用构造函数、赋值运算符或比较运算符。 ↩︎\",\"注：即使 expected 与原子对象的值相等，表现如同 *this != expected↩︎\"]},\"72\":{\"h\":\"协程\",\"t\":[\"既然是“现代” C++ 并发编程教程，怎么能不聊协程呢？\",\"C++20 引入了协程语法，新增了三个用作协程的关键字：co_await、co_yield、co_return。但并未给出标准协程库。协程库在 C++23 被引入。\",\"希望您拥有 gcc14、clang18，最新的 MSVC。\"]},\"73\":{\"h\":\"阅读须知\",\"t\":[\" 本套教程侧重点在于使用 C++ 并发支持库进行多线程编程。我们假设读者最低水平为：C++11 + STL + template，可能没有接触过 C++ 标准并发库，假设略微了解操作系统基本知识。\",\" 我们强调了模板，因为并发支持库的很多设施其实现是较为简单的，概念与使用，再结合源码讲解会更加简单直观，然而要想阅读学习源码，模板的知识必不可少。不需要模板的水平有多高，也不需要会什么元编程，但是基本的需求得能做到，得会，这里推荐一下：《现代C++模板教程》。\",\" 本教程不保证你学习之后的成果，不过依然可以自信地说：本教程在中文社区的同类型教程中是绝对的第一。事实上只需要一句话就可以表达了——伟大无需多言。\"]},\"74\":{\"h\":\"学习注意事项\",\"t\":[\" 我们的教程中常包含许多外部链接，这并非当前描述不足或者不够严谨，而是为了考虑读者的水平和可能的扩展学习需求。同时，也希望者能让读者避免获取二手知识与理解，我们提供的链接基本都是较为专业的文档或官方网站。\",\" 虽然教程名为《现代 C++ 并发编程教程》，但我们也扩展涉及了许多其他知识，包括但不限于：Win32、POSIX API；MSVC STL、libstdc++、libc++ 对标准库的实现；GCC 与 MSVC 的编译器扩展，以及 Clang 对它们的兼容；使用 CMake + Qt 构建带 UI 的程序，展示多线程异步的必要性；不同架构的内存模型（例如 x86 架构内存模型：Total Store Order (TSO)，较为严格的内存模型）。\",\" 既然强调了“现代”，那自然是全方面的，具体的读者会在学习中感受到的。\",\" 另外我们的代码都会测试三大编译器 Clang、GCC、MSVC。通常都会是最新的，Clang18、GCC14。我们的教程中常常会提供 Complier Explorer 的运行测试链接以确保正确性，以及方便读者的测试与学习。如果你对此网站的使用不熟悉，可以阅读使用文档。\"]},\"75\":{\"h\":\"代码风格\",\"t\":[\" 我们的代码风格较为简洁明了，命名全部使用下划线连接，而不是驼峰命名法。花括号通常只占一行，简短的代码可以不额外占行。一般初始化时使用 {}，而非 () 或者 = 。这样简单直观，避免歧义和许多问题。#include 引入头文件时需要在尖括号或引号前后加空格。\",\"#include <iostream> // 空格 struct move_only { move_only() { std::puts(\\\"默认构造\\\"); } move_only(const move_only&) = delete; move_only(move_only&&)noexcept { std::puts(\\\"移动构造\\\"); } }; int main() { move_only m{}; char buffer[1024]{} // 全部初始化为 0 } \",\"如果是标量类型，可能考虑使用复制初始化，而非 {}，如：int n = 0;。\"]},\"76\":{\"h\":\"总结\",\"t\":[\" 本教程长期维护，接受 pr 与 issue。\",\" 好了，稍微了解了一下，我们可以开始进入正式的学习内容了。\"]},\"77\":{\"h\":\"\",\"t\":[\" 我们会收集捐赠者进行感谢，所以请您捐赠了可以选择备注，或者联系我，或者直接在捐赠初始记录名单中进行评论。\"]},\"78\":{\"h\":\"std::thread 的构造-源码解析\",\"t\":[\"我们这单章是为了专门解释一下 C++11 引入的 std::thread 是如何构造的，是如何创建线程传递参数的，让你彻底了解这个类。\",\"我们以 MSVC 实现的 std::thread 代码进行讲解，MSVC STL 很早之前就不支持 C++11 了，它的实现完全基于 C++14，出于某些原因 C++17 的一些库（如 invoke， _v 变量模板）被向后移植到了 C++14 模式，所以即使是 C++11 标准库设施，实现中可能也是使用到了 C++14、17 的东西。\"]},\"79\":{\"h\":\"的数据成员\",\"t\":[\"了解一个庞大的类，最简单的方式就是先看它的数据成员有什么。\",\"std::thread 只保有一个私有数据成员 _Thr：\",\"private: _Thrd_t _Thr; \",\"_Thrd_t 是一个结构体，它保有两个数据成员：\",\"using _Thrd_id_t = unsigned int; struct _Thrd_t { // thread identifier for Win32 void* _Hnd; // Win32 HANDLE _Thrd_id_t _Id; }; \",\"结构很明确，这个结构体的 _Hnd 成员是指向线程的句柄，_Id 成员就是保有线程的 ID。\",\"在64 位操作系统，因为内存对齐，指针 8 ，无符号 int 4，这个结构体 _Thrd_t 就是占据 16 个字节。也就是说 sizeof(std::thread) 的结果应该为 16。\"]},\"80\":{\"h\":\"的构造函数\",\"t\":[\"std::thread 有四个构造函数，分别是：\",\"默认构造函数，构造不关联线程的新 std::thread 对象。\",\"thread() noexcept : _Thr{} {} \",\"值初始化了数据成员 _Thr ，这里的效果相当于给其成员 _Hnd 和 _Id 都进行零初始化。\",\"移动构造函数，转移线程的所有权，构造 other 关联的执行线程的 std::thread 对象。此调用后 other 不再表示执行线程失去了线程的所有权。\",\"thread(thread&& _Other) noexcept : _Thr(_STD exchange(_Other._Thr, {})) {} \",\"_STD 是一个宏，展开就是 ::std::，也就是 ::std::exchange，将 _Other._Thr 赋为 {} （也就是置空），返回 _Other._Thr 的旧值用以初始化当前对象的数据成员 _Thr。\",\"复制构造函数被定义为弃置的，std::thread 不可复制。两个 std::thread 不可表示一个线程，std::thread 对线程资源是独占所有权。\",\"thread(const thread&) = delete; \",\"构造新的 std::thread 对象并将它与执行线程关联。表示新的执行线程开始执行。\",\"template <class _Fn, class... _Args, enable_if_t<!is_same_v<_Remove_cvref_t<_Fn>, thread>, int> = 0> _NODISCARD_CTOR_THREAD explicit thread(_Fn&& _Fx, _Args&&... _Ax) { _Start(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...); } \",\"前三个构造函数都没啥要特别聊的，非常简单，只有第四个构造函数较为复杂，且是我们本章重点，需要详细讲解。（注意 MSVC 使用标准库的内容很多时候不加 std::，脑补一下就行）\",\"如你所见，这个构造函数本身并没有做什么，它只是一个可变参数成员函数模板，增加了一些 SFINAE 进行约束我们传入的可调用对象的类型不能是 std::thread。函数体中调用了一个函数 _Start，将我们构造函数的参数全部完美转发，去调用它，这个函数才是我们的重点，如下：\",\"template <class _Fn, class... _Args> void _Start(_Fn&& _Fx, _Args&&... _Ax) { using _Tuple = tuple<decay_t<_Fn>, decay_t<_Args>...>; auto _Decay_copied = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...); constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{}); _Thr._Hnd = reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id)); if (_Thr._Hnd) { // ownership transferred to the thread (void) _Decay_copied.release(); } else { // failed to start thread _Thr._Id = 0; _Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN); } } \",\"它也是一个可变参数成员函数模板，接受一个可调用对象 _Fn 和一系列参数 _Args... ，这些东西用来创建一个线程。\",\"using _Tuple = tuple<decay_t<_Fn>, decay_t<_Args>...>\",\"定义了一个元组类型 _Tuple ，它包含了可调用对象和参数的类型，这里使用了 decay_t 来去除了类型的引用和 cv 限定。\",\"auto _Decay_copied = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...)\",\"使用 make_unique 创建了一个独占指针，指向的是 _Tuple 类型的对象，存储了传入的函数对象和参数的副本。\",\"constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{})\",\"调用 _Get_invoke 函数，传入 _Tuple 类型和一个参数序列的索引序列（为了遍历形参包）。这个函数用于获取一个函数指针，指向了一个静态成员函数 _Invoke，用来实际执行线程。这两个函数都非常的简单，我们来看看：\",\" template <class _Tuple, size_t... _Indices> _NODISCARD static constexpr auto _Get_invoke(index_sequence<_Indices...>) noexcept { return &_Invoke<_Tuple, _Indices...>; } template <class _Tuple, size_t... _Indices> static unsigned int __stdcall _Invoke(void* _RawVals) noexcept /* terminates */ { // adapt invoke of user's callable object to _beginthreadex's thread procedure const unique_ptr<_Tuple> _FnVals(static_cast<_Tuple*>(_RawVals)); _Tuple& _Tup = *_FnVals.get(); // avoid ADL, handle incomplete types _STD invoke(_STD move(_STD get<_Indices>(_Tup))...); _Cnd_do_broadcast_at_thread_exit(); // TRANSITION, ABI return 0; } \",\"_Get_invoke 函数很简单，就是接受一个元组类型，和形参包的索引，传递给 _Invoke 静态成员函数模板，实例化，获取它的函数指针。\",\"它的形参类型我们不再过多介绍，你只需要知道 index_sequence 这个东西可以用来接收一个由 make_index_sequence 创建的索引形参包，帮助我们进行遍历元组即可。示例代码。\",\"_Invoke 是重中之重，它是线程实际执行的函数，如你所见它的形参类型是 void* ，这是必须的，要符合 _beginthreadex 执行函数的类型要求。虽然是 void*，但是我可以将它转换为 _Tuple* 类型，构造一个独占智能指针，然后调用 get() 成员函数获取底层指针，解引用指针，得到元组的引用初始化_Tup 。\",\"此时，我们就可以进行调用了，使用 std::invoke + std::move（默认移动） ，这里有一个形参包展开，_STD get<_Indices>(_Tup))...，_Tup 就是 std::tuple 的引用，我们使用 std::get<> 获取元组存储的数据，需要传入一个索引，这里就用到了 _Indices。展开之后，就等于 invoke 就接受了我们构造 std::thread 传入的可调用对象，调用可调用对象的参数，invoke 就可以执行了。\",\"_Thr._Hnd = reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id))\",\"调用 _beginthreadex 函数来启动一个线程，并将线程句柄存储到 _Thr._Hnd 中。传递给线程的参数为 _Invoker_proc（一个静态函数指针，就是我们前面讲的 _Invoke）和 _Decay_copied.get()（存储了函数对象和参数的副本的指针）。\",\"if (_Thr._Hnd) {\",\"如果线程句柄 _Thr._Hnd 不为空，则表示线程已成功启动，将独占指针的所有权转移给线程。\",\"(void) _Decay_copied.release()\",\"释放独占指针的所有权，因为已经将参数传递给了线程。\",\"} else { // failed to start thread\",\"如果线程启动失败，则进入这个分支\",\"_Thr._Id = 0;\",\"将线程ID设置为0。\",\"_Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);\",\"抛出一个 C++ 错误，表示资源不可用，请再次尝试。\"]},\"81\":{\"h\":\"总结\",\"t\":[\"需要注意，libstdc++ 和 libc++ 可能不同，就比如它们 64 位环境下 sizeof(std::thread) 的结果就可能是 8。libstdc++ 的实现只保有一个 std::thread::id。参见。不过实测 gcc 不管是 win32 还是 POSIX 线程模型，线程对象的大小都是 8，宏 _GLIBCXX_HAS_GTHREADS 的值都为 1（GThread）。\",\" class thread { public: #ifdef _GLIBCXX_HAS_GTHREADS using native_handle_type = __gthread_t; #else using native_handle_type = int; #endif \",\"__gthread_t 即 void*。\",\"我们这里的源码解析涉及到的 C++ 技术很多，我们也没办法每一个都单独讲，那会显得文章很冗长，而且也不是重点。\",\"相信你也感受到了，不会模板，你阅读标准库源码，是无稽之谈，市面上很多教程教学，教导一些实现容器，过度简化了，真要去出错了去看标准库的代码，那是不现实的。不需要模板的水平有多高，也不需要会什么元编程，但是基本的需求得能做到，得会，这里推荐一下：现代C++模板教程。\"]},\"82\":{\"h\":\"std::scoped_lock 的源码实现与解析\",\"t\":[\"本单章专门介绍标准库在 C++17 引入的类模板 std::scoped_lock 的实现，让你对它再无疑问。\",\"这会涉及到不少的模板技术，这没办法，就如同我们先前聊 std::thread 的构造与源码分析最后说的：“不会模板，你阅读标准库源码，是无稽之谈”。建议学习现代C++模板教程。\",\"我们还是一样的，以 MSVC STL 实现的 std::scoped_lock 代码进行讲解，不用担心，我们也查看了 libstdc++ 、libc++的实现，并没有太多区别，更多的是一些风格上的。而且个人觉得 MSVC 的实现是最简单直观的。\"]},\"83\":{\"h\":\"的数据成员\",\"t\":[\"std::scoped_lock 是一个类模板，它有两个特化，也就是有三个版本，其中的数据成员也是不同的。并且它们都不可移动不可复制，“管理类”应该如此。\",\"主模板，是一个可变参数类模板，声明了一个类型形参包 _Mutexes，存储了一个 std::tuple，具体类型根据类型形参包决定。\",\"_EXPORT_STD template <class... _Mutexes> class _NODISCARD_LOCK scoped_lock { // class with destructor that unlocks mutexes public: explicit scoped_lock(_Mutexes&... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock _STD lock(_Mtxes...); } explicit scoped_lock(adopt_lock_t, _Mutexes&... _Mtxes) noexcept // strengthened : _MyMutexes(_Mtxes...) {} // construct but don't lock ~scoped_lock() noexcept { _STD apply([](_Mutexes&... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes); } scoped_lock(const scoped_lock&) = delete; scoped_lock& operator=(const scoped_lock&) = delete; private: tuple<_Mutexes&...> _MyMutexes; }; \",\"对模板类型形参包只有一个类型情况的偏特化，是不是很熟悉，和 lock_guard 几乎没有任何区别，保有一个互斥量的引用，构造上锁，析构解锁，提供一个额外的构造函数让构造的时候不上锁。所以用 scoped_lock 替代 lock_guard 不会造成任何额外开销。\",\"template <class _Mutex> class _NODISCARD_LOCK scoped_lock<_Mutex> { public: using mutex_type = _Mutex; explicit scoped_lock(_Mutex& _Mtx) : _MyMutex(_Mtx) { // construct and lock _MyMutex.lock(); } explicit scoped_lock(adopt_lock_t, _Mutex& _Mtx) noexcept // strengthened : _MyMutex(_Mtx) {} // construct but don't lock ~scoped_lock() noexcept { _MyMutex.unlock(); } scoped_lock(const scoped_lock&) = delete; scoped_lock& operator=(const scoped_lock&) = delete; private: _Mutex& _MyMutex; }; \",\"对类型形参包为空的情况的全特化，没有数据成员。\",\"template <> class scoped_lock<> { public: explicit scoped_lock() = default; explicit scoped_lock(adopt_lock_t) noexcept /* strengthened */ {} scoped_lock(const scoped_lock&) = delete; scoped_lock& operator=(const scoped_lock&) = delete; }; \",\"std::mutex m1,m2; std::scoped_lock<std::mutex>lc{ m1 }; // 匹配到偏特化版本 保有一个 std::mutex& std::scoped_lock<std::mutex, std::mutex>lc2{ m1,m2 }; // 匹配到主模板 保有一个 std::tuple<std::mutex&,std::mutex&> std::scoped_lock<> lc3; // 匹配到全特化版本 空 \"]},\"84\":{\"h\":\"的构造与析构\",\"t\":[\"在上一节讲 scoped_lock 的数据成员的时候已经把这个模板类的全部源码，三个版本的代码都展示了，就不再重复。\",\"这三个版本中，只有两个版本需要介绍，也就是\",\"形参包元素数量为一的偏特化，只管理一个互斥量的。\",\"主模板，可以管理任意个数的互斥量。\",\"那这两个的共同点是什么呢？构造上锁，析构解锁。这很明显，明确这一点我们就开始讲吧。\",\"std::mutex m; void f(){ m.lock(); std::lock_guard<std::mutex> lc{ m, std::adopt_lock }; } void f2(){ m.lock(); std::scoped_lock<std::mutex>sp{ std::adopt_lock,m }; } \",\"这段代码为你展示了 std::lock_guard 和 std::scoped_lock 形参包元素数量为一的偏特化的唯一区别：调用不会上锁的构造函数的参数顺序不同。那么到此也就够了。\",\"接下来我们进入 std::scoped_lock 主模板的讲解：\",\"explicit scoped_lock(_Mutexes&... _Mtxes) : _MyMutexes(_Mtxes...) { // construct and lock _STD lock(_Mtxes...); } \",\"这个构造函数做了两件事情，初始化数据成员 _MyMutexes让它保有这些互斥量的引用，以及给所有互斥量上锁，使用了 std::lock 帮助我们完成这件事情。\",\"explicit scoped_lock(adopt_lock_t, _Mutexes&... _Mtxes) noexcept // strengthened : _MyMutexes(_Mtxes...) {} // construct but don't lock \",\"这个构造函数不上锁，只是初始化数据成员 _MyMutexes让它保有这些互斥量的引用。\",\"~scoped_lock() noexcept { _STD apply([](_Mutexes&... _Mtxes) { (..., (void) _Mtxes.unlock()); }, _MyMutexes); } \",\"析构函数就要稍微聊一下了，主要是用 std::apply 去遍历 std::tuple ，让元组保有的互斥量引用都进行解锁。简单来说是 std::apply 可以将元组存储的参数全部拿出，用于调用这个可变参数的可调用对象，我们就能利用折叠表达式展开形参包并对其调用 unlock()。\",\"不在乎其返回类型只用来实施它的副作用，显式转换为 (void) 也就是弃值表达式。在我们之前讲的 std::thread 源码中也有这种用法。\",\"不过你可能有疑问：“我们的标准库的那些互斥量unlock() 返回类型都是 void 呀，为什么要这样？”\",\"的确，这是个好问题，libstdc++ 和 libc++ 都没这样做，或许 MSVC STL 想着会有人设计的互斥量让它的 unlock() 返回类型不为 void，毕竟 互斥体(Mutex) 没有要求 unlock() 的返回类型。\",\"template< class F, class Tuple > constexpr decltype(auto) apply( F&& f, Tuple&& t ); \",\"这个函数模板接受两个参数，一个可调用(Callable)对象 f，以及一个元组 t，用做调用 f 。我们可以自己简单实现一下它，其实不算难，这种遍历元组的方式在之前讲 std::thread 的源码的时候也提到过。\",\"template<class Callable, class Tuple, std::size_t...index> constexpr decltype(auto) Apply_impl(Callable&& obj,Tuple&& tuple,std::index_sequence<index...>){ return std::invoke(std::forward<Callable>(obj), std::get<index>(std::forward<Tuple>(tuple))...); } template<class Callable, class Tuple> constexpr decltype(auto) apply(Callable&& obj, Tuple&& tuple){ return Apply_impl(std::forward<Callable>(obj), std::forward<Tuple>(tuple), std::make_index_sequence<std::tuple_size_v<std::remove_reference_t<Tuple>>>{}); } \",\"其实就是把元组给解包了，利用了 std::index_sequence + std::make_index_sequence 然后就用 std::get 形参包展开用 std::invoke 调用可调用对象即可，非常经典的处理可变参数做法，这个非常重要，一定要会使用。\",\"举一个简单的调用例子：\",\"std::tuple<int, std::string, char> tuple{ 66,\\\"😅\\\",'c' }; ::apply([](const auto&... t) { ((std::cout << t << ' '), ...); }, tuple); \",\"运行测试。\",\"使用了折叠表达式展开形参包，打印了元组所有的元素。\"]},\"85\":{\"h\":\"总结\",\"t\":[\"如你所见，其实这很简单。至少使用与了解其设计原理是很简单的。唯一的难度或许只有那点源码，处理可变参数，这会涉及不少模板技术，既常见也通用。还是那句话：“不会模板，你阅读标准库源码，是无稽之谈”。\",\"相对于 std::thread 的源码解析，std::scoped_lock 还是简单的多。\"]},\"86\":{\"h\":\"st::async 与 std::future 源码解析\"},\"87\":{\"h\":\"详细分析\",\"t\":[\"放一些详细分析源码实现之类的内容。\"]},\"88\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"89\":{\"h\":\"Image\"}},\"dirtCount\":0,\"index\":[[\"放一些详细分析源码实现之类的内容\",{\"1\":{\"87\":1}}],[\"放弃线程的所有权不是一种选择\",{\"1\":{\"12\":1}}],[\"放弃了对线程资源的所有权\",{\"1\":{\"12\":1}}],[\"既常见也通用\",{\"1\":{\"85\":1}}],[\"既然强调了\",{\"1\":{\"74\":1}}],[\"既然是\",{\"1\":{\"72\":1}}],[\"唯一的难度或许只有那点源码\",{\"1\":{\"85\":1}}],[\"唯一需要注意的是我们使用了\",{\"1\":{\"44\":1}}],[\"利用了\",{\"1\":{\"84\":1}}],[\"想着会有人设计的互斥量让它的\",{\"1\":{\"84\":1}}],[\"想要在线程中执行异步任务\",{\"1\":{\"44\":1}}],[\"想要解决这个问题很简单\",{\"1\":{\"14\":1}}],[\"呀\",{\"1\":{\"84\":1}}],[\"去遍历\",{\"1\":{\"84\":1}}],[\"去调用它\",{\"1\":{\"80\":1}}],[\"匹配到全特化版本\",{\"1\":{\"83\":1}}],[\"匹配到主模板\",{\"1\":{\"83\":1}}],[\"匹配到偏特化版本\",{\"1\":{\"83\":1}}],[\"匹配次数后\",{\"1\":{\"35\":1}}],[\"替代\",{\"1\":{\"83\":1}}],[\"替换了库的版本\",{\"1\":{\"36\":1}}],[\"替换了库的全局版本\",{\"1\":{\"36\":1}}],[\"替换掉\",{\"1\":{\"30\":1}}],[\"替换为\",{\"1\":{\"12\":1,\"14\":1}}],[\"几乎没有任何区别\",{\"1\":{\"83\":1}}],[\"几乎完全相同\",{\"1\":{\"27\":1}}],[\"真要去出错了去看标准库的代码\",{\"1\":{\"81\":1}}],[\"教导一些实现容器\",{\"1\":{\"81\":1}}],[\"教程\",{\"1\":{\"33\":1}}],[\"市面上很多教程教学\",{\"1\":{\"81\":1}}],[\"技术很多\",{\"1\":{\"81\":1}}],[\"参见\",{\"1\":{\"81\":1}}],[\"参数强制异步执行任务\",{\"1\":{\"55\":1}}],[\"参数的构造函数\",{\"1\":{\"46\":1}}],[\"参数传递的事\",{\"1\":{\"43\":1}}],[\"参数\",{\"1\":{\"30\":1}}],[\"示例代码\",{\"1\":{\"80\":1}}],[\"示例如下\",{\"1\":{\"45\":1}}],[\"脑补一下就行\",{\"1\":{\"80\":1}}],[\"赋为\",{\"1\":{\"80\":1}}],[\"赋值运算符或比较运算符\",{\"1\":{\"71\":1}}],[\"赋值操作\",{\"1\":{\"67\":1}}],[\"赋值\",{\"1\":{\"41\":1,\"65\":1}}],[\"位操作系统\",{\"1\":{\"79\":1}}],[\"位环境下\",{\"1\":{\"81\":1}}],[\"位环境\",{\"1\":{\"20\":1}}],[\"结构很明确\",{\"1\":{\"79\":1}}],[\"结果是两个时间点的时间差\",{\"1\":{\"50\":1}}],[\"结果将仅在明确请求时计算\",{\"1\":{\"49\":1}}],[\"变量模板\",{\"1\":{\"78\":1}}],[\"变为\",{\"1\":{\"40\":2}}],[\"出于某些原因\",{\"1\":{\"78\":1}}],[\"出现了未定义行为\",{\"1\":{\"64\":1}}],[\"空\",{\"1\":{\"83\":1}}],[\"空格\",{\"1\":{\"75\":1}}],[\"空才需要初始化\",{\"1\":{\"33\":1}}],[\"花括号通常只占一行\",{\"1\":{\"75\":1}}],[\"命名全部使用下划线连接\",{\"1\":{\"75\":1}}],[\"命名空间内为时间段提供了一系列的类型\",{\"1\":{\"49\":1}}],[\"命名空间中的四个函数的基本用法\",{\"1\":{\"15\":1}}],[\"命名空间中的时间对象\",{\"1\":{\"15\":1}}],[\"命名空间中\",{\"1\":{\"15\":1,\"49\":1}}],[\"学习注意事项\",{\"0\":{\"74\":1}}],[\"学完本章后\",{\"1\":{\"23\":1}}],[\"伟大无需多言\",{\"1\":{\"73\":1}}],[\"怎么能不聊协程呢\",{\"1\":{\"72\":1}}],[\"知到其表达的意思就好\",{\"1\":{\"71\":1}}],[\"吗\",{\"1\":{\"71\":1}}],[\"各位写代码难道还要考虑下面这段\",{\"1\":{\"71\":1}}],[\"各个任务通常需要通过同步操作进行相互协调和等待\",{\"1\":{\"39\":1}}],[\"把\",{\"1\":{\"71\":1}}],[\"重排到\",{\"1\":{\"71\":2}}],[\"重排\",{\"1\":{\"71\":1}}],[\"重载决议简单来说就是编译器必须要根据规则选择最合适的函数重载进行调用\",{\"1\":{\"23\":1}}],[\"流水线更加高效地执行指令\",{\"1\":{\"71\":1}}],[\"流保证是线程安全的\",{\"1\":{\"25\":1}}],[\"开发者必须依赖自己的知识和经验\",{\"1\":{\"71\":1}}],[\"开始迭代器不断向前\",{\"1\":{\"10\":1,\"44\":1}}],[\"架构内存模型\",{\"1\":{\"71\":1,\"74\":1}}],[\"少见的情况下的竞争条件引起的\",{\"1\":{\"71\":1}}],[\"数以万计\",{\"1\":{\"71\":1}}],[\"适用于需要确保操作成功的场合\",{\"1\":{\"67\":1}}],[\"远好于\",{\"1\":{\"67\":1}}],[\"过度简化了\",{\"1\":{\"81\":1}}],[\"过程\",{\"1\":{\"67\":1}}],[\"过一会儿再来判断是否完成\",{\"1\":{\"15\":1}}],[\"know\",{\"1\":{\"66\":2}}],[\"key\",{\"1\":{\"34\":4,\"37\":3}}],[\"导致它们继续在循环中自旋\",{\"1\":{\"66\":1}}],[\"导致抛出异常\",{\"1\":{\"25\":1}}],[\"该线程成功获取了锁\",{\"1\":{\"66\":1}}],[\"稍微了解了一下\",{\"1\":{\"76\":1}}],[\"稍微聊一下原理\",{\"1\":{\"66\":1}}],[\"稍微注意一下构造函数和赋值运算符的实现即可\",{\"1\":{\"18\":1}}],[\"非常经典的处理可变参数做法\",{\"1\":{\"84\":1}}],[\"非常简单\",{\"1\":{\"80\":1}}],[\"非常适合用作制作自旋锁\",{\"1\":{\"66\":1}}],[\"非静态成员\",{\"1\":{\"14\":1}}],[\"破坏了操作的原子性\",{\"1\":{\"66\":1}}],[\"销毁\",{\"1\":{\"66\":2}}],[\"清除\",{\"1\":{\"66\":4}}],[\"写\",{\"1\":{\"65\":1,\"66\":1,\"67\":2}}],[\"写入到标准输出流\",{\"1\":{\"9\":1}}],[\"加载\",{\"1\":{\"67\":1}}],[\"加载操作\",{\"1\":{\"65\":1}}],[\"加上\",{\"1\":{\"14\":1}}],[\"满足要求\",{\"1\":{\"65\":1}}],[\"满足第二个\",{\"1\":{\"31\":1}}],[\"验证自己的类型是否满足\",{\"1\":{\"65\":1}}],[\"及可复制赋值\",{\"1\":{\"65\":1}}],[\"^=\",{\"1\":{\"65\":1}}],[\"移动\",{\"1\":{\"65\":1}}],[\"移动构造函数\",{\"1\":{\"80\":1}}],[\"移动构造转移线程资源的所有权到\",{\"1\":{\"16\":1}}],[\"移动构造\",{\"1\":{\"14\":1,\"43\":1,\"75\":1}}],[\"缩写\",{\"1\":{\"65\":3}}],[\"宏\",{\"1\":{\"81\":1}}],[\"宏只是为了统一\",{\"1\":{\"66\":1}}],[\"宏则更是简单了\",{\"1\":{\"65\":1}}],[\"宏进行编译时检查\",{\"1\":{\"65\":1}}],[\"始终是无锁\",{\"1\":{\"65\":1}}],[\"检查\",{\"1\":{\"65\":1}}],[\"检查是否已经收到停止请求\",{\"1\":{\"21\":1}}],[\"逻辑上也可视为原子操作\",{\"1\":{\"64\":1}}],[\"读\",{\"1\":{\"65\":1,\"66\":1,\"67\":2}}],[\"读取\",{\"1\":{\"64\":1}}],[\"读写操作如何在不同线程之间可见\",{\"1\":{\"63\":1}}],[\"读写锁\",{\"1\":{\"34\":1}}],[\"系统的所有线程\",{\"1\":{\"63\":1}}],[\"私有数据成员\",{\"1\":{\"62\":1}}],[\"称为二进制信号量\",{\"1\":{\"62\":1}}],[\"称这些表达式冲突\",{\"1\":{\"25\":1}}],[\"现在只需要知道操作分为三类\",{\"1\":{\"65\":1}}],[\"现在让我们来看看底层工具\",{\"1\":{\"62\":1}}],[\"现代c++模板教程\",{\"1\":{\"0\":1,\"73\":1,\"81\":1}}],[\"现代c++并发编程教程\",{\"0\":{\"0\":1}}],[\"现代\",{\"1\":{\"0\":1,\"72\":1,\"74\":2}}],[\"界面的示例\",{\"1\":{\"62\":1}}],[\"界面将会卡住\",{\"1\":{\"52\":1}}],[\"界面将会卡顿\",{\"1\":{\"52\":1}}],[\"构建带\",{\"1\":{\"74\":1}}],[\"构建了一个带有\",{\"1\":{\"62\":1}}],[\"构造上锁\",{\"1\":{\"83\":1,\"84\":1}}],[\"构造一个独占智能指针\",{\"1\":{\"80\":1}}],[\"构造新的\",{\"1\":{\"80\":1}}],[\"构造不关联线程的新\",{\"1\":{\"80\":1}}],[\"构造不表示线程的新\",{\"1\":{\"12\":1}}],[\"构造和析构不涉及共享资源\",{\"1\":{\"36\":1}}],[\"构造都额外传递了一个\",{\"1\":{\"30\":1}}],[\"构造了一个临时对象\",{\"1\":{\"16\":1}}],[\"构造\",{\"1\":{\"16\":1,\"31\":1,\"80\":1}}],[\"构造是代表\",{\"1\":{\"14\":1}}],[\"构造参数的传递的时候会decay\",{\"1\":{\"14\":1}}],[\"构造出一个临时的\",{\"1\":{\"14\":1}}],[\"构造线程对象\",{\"1\":{\"14\":1}}],[\"构造函数\",{\"1\":{\"36\":1}}],[\"构造函数不上锁\",{\"1\":{\"31\":2}}],[\"构造函数中初始化这个引用\",{\"1\":{\"27\":1}}],[\"构造函数中初始化副本\",{\"1\":{\"14\":1}}],[\"构造函数的源码即可\",{\"1\":{\"16\":1}}],[\"构造函数申请资源\",{\"1\":{\"13\":1}}],[\"详细介绍了\",{\"1\":{\"62\":1}}],[\"详细分析\",{\"0\":{\"87\":1},\"1\":{\"1\":1}}],[\"得到元组的引用初始化\",{\"1\":{\"80\":1}}],[\"得到实际存储的值\",{\"1\":{\"67\":1}}],[\"得会\",{\"1\":{\"73\":1,\"81\":1}}],[\"得以解除阻塞\",{\"1\":{\"60\":1}}],[\"得不到正确的结果\",{\"1\":{\"33\":1}}],[\"门闩\",{\"1\":{\"60\":1}}],[\"许多系统\",{\"1\":{\"59\":1}}],[\"屏障也是一种古老而广泛应用的同步机制\",{\"1\":{\"59\":1}}],[\"闩不能重复使用\",{\"1\":{\"59\":1}}],[\"闩\",{\"1\":{\"59\":1,\"60\":1}}],[\"闩与屏障\",{\"0\":{\"59\":1}}],[\"防止服务器过载\",{\"1\":{\"58\":1}}],[\"明白这点\",{\"1\":{\"58\":1}}],[\"明确这一点我们就开始讲吧\",{\"1\":{\"84\":1}}],[\"明确这一点\",{\"1\":{\"44\":1}}],[\"计数的值不能小于\",{\"1\":{\"58\":1}}],[\"计算平方并设置值到\",{\"1\":{\"45\":1}}],[\"计算函数\",{\"1\":{\"45\":1}}],[\"计算每个线程处理的元素数量\",{\"1\":{\"10\":1,\"44\":1}}],[\"计算机中的并发有两种方式\",{\"1\":{\"5\":1}}],[\"牢记信号量的基本的概念不变\",{\"1\":{\"58\":1}}],[\"意思是信号量维护的计数最大值\",{\"1\":{\"58\":1}}],[\"意思也很简单\",{\"1\":{\"14\":1}}],[\"剩余的会被阻塞\",{\"1\":{\"58\":1}}],[\"尝试将\",{\"1\":{\"67\":1}}],[\"尝试将原子对象的当前值与预期值进行比较\",{\"1\":{\"67\":1}}],[\"尝试获取信号量\",{\"1\":{\"58\":2}}],[\"尝试加锁\",{\"1\":{\"28\":1}}],[\"服务器处理并发请求的数量\",{\"1\":{\"58\":1}}],[\"服务器\",{\"1\":{\"58\":1}}],[\"发信\",{\"1\":{\"58\":1}}],[\"发送信号\",{\"1\":{\"58\":4}}],[\"提高系统的吞吐量和响应时间\",{\"1\":{\"65\":1}}],[\"提高了性能\",{\"1\":{\"65\":1}}],[\"提醒而非互斥\",{\"1\":{\"58\":1}}],[\"提供一个额外的构造函数让构造的时候不上锁\",{\"1\":{\"83\":1}}],[\"提供多个\",{\"1\":{\"67\":1}}],[\"提供此函数的\",{\"1\":{\"30\":1}}],[\"提供了更加完善的布尔标志\",{\"1\":{\"67\":1}}],[\"提供了对屏障机制的支持\",{\"1\":{\"59\":1}}],[\"提供了两个信号量类型\",{\"1\":{\"58\":1}}],[\"提供了三个成员函数进行所谓的线程停止\",{\"1\":{\"21\":1}}],[\"提供了一种优雅地请求线程停止的方式\",{\"1\":{\"21\":1}}],[\"提供的线程停止功能并不同于常见的\",{\"1\":{\"21\":1}}],[\"好了好了\",{\"1\":{\"60\":1}}],[\"好了\",{\"1\":{\"58\":1,\"71\":1,\"76\":1}}],[\"好像这些任务都在同时执行\",{\"1\":{\"5\":1}}],[\"增加了一些\",{\"1\":{\"80\":1}}],[\"增加计数\",{\"1\":{\"58\":1}}],[\"增加这两个功能\",{\"1\":{\"20\":1}}],[\"信号量常用于发信\",{\"1\":{\"58\":1}}],[\"信号量提供两种基本操作\",{\"1\":{\"58\":1}}],[\"信号量是一个非常轻量简单的同步设施\",{\"1\":{\"58\":1}}],[\"信号量源自操作系统\",{\"1\":{\"58\":1}}],[\"信号量\",{\"0\":{\"58\":1},\"1\":{\"62\":1}}],[\"观察不同情况下\",{\"1\":{\"57\":1}}],[\"观看\",{\"1\":{\"42\":1}}],[\"毕竟\",{\"1\":{\"84\":1}}],[\"毕竟如果你不用线程\",{\"1\":{\"57\":1}}],[\"毕竟是初学\",{\"1\":{\"10\":1}}],[\"跨平台兼容性\",{\"0\":{\"56\":1}}],[\"连接信号\",{\"1\":{\"54\":1}}],[\"样式\",{\"1\":{\"54\":1}}],[\"7fff00\",{\"1\":{\"54\":1}}],[\"文本颜色\",{\"1\":{\"54\":1}}],[\"文本居中\",{\"1\":{\"54\":2}}],[\"文件夹中\",{\"1\":{\"53\":1}}],[\"文档\",{\"1\":{\"12\":1,\"62\":1}}],[\"插件后打开此项目\",{\"1\":{\"53\":1}}],[\"项目结构简单\",{\"1\":{\"53\":1}}],[\"项目使用\",{\"1\":{\"53\":1}}],[\"项目说明\",{\"0\":{\"53\":1}}],[\"按钮或移动窗口\",{\"1\":{\"52\":1}}],[\"按钮并触发弹窗\",{\"1\":{\"52\":1}}],[\"按复制捕获\",{\"1\":{\"46\":1}}],[\"控件的更新操作在主线程中执行\",{\"1\":{\"52\":1}}],[\"控件\",{\"1\":{\"52\":1}}],[\"控件通常只能在创建它们的线程中进行操作\",{\"1\":{\"52\":1}}],[\"背景介绍\",{\"0\":{\"52\":1}}],[\"带超时功能\",{\"1\":{\"50\":1}}],[\"纳秒之后的时间\",{\"1\":{\"50\":1}}],[\"三个版本的代码都展示了\",{\"1\":{\"84\":1}}],[\"三个枚举项分别表示三种\",{\"1\":{\"49\":1}}],[\"三个阶段稍微介绍一下\",{\"1\":{\"47\":1}}],[\"节拍\",{\"1\":{\"49\":1}}],[\"概念与使用\",{\"1\":{\"73\":1}}],[\"概念\",{\"1\":{\"48\":1}}],[\"概念从来不是我们的重点\",{\"1\":{\"7\":1,\"26\":1}}],[\"根据我们的描述\",{\"1\":{\"48\":1}}],[\"根本不需要最外部\",{\"1\":{\"12\":1}}],[\"像\",{\"1\":{\"48\":1}}],[\"静态成员函数模板\",{\"1\":{\"80\":1}}],[\"静态断言求值中第一个表达式求值为\",{\"1\":{\"65\":1}}],[\"静态常量判断当前时钟是否是稳定时钟\",{\"1\":{\"48\":1}}],[\"静态局部变量初始化在\",{\"1\":{\"33\":2}}],[\"持续递增的时间流逝信息的时钟\",{\"1\":{\"48\":1}}],[\"分别是\",{\"1\":{\"80\":1}}],[\"分母有默认实参\",{\"1\":{\"48\":1}}],[\"分离的线程可能还在运行\",{\"1\":{\"12\":1}}],[\"分离\",{\"1\":{\"12\":2}}],[\"周期就可以表示为\",{\"1\":{\"48\":1}}],[\"稳定时钟的主要优点在于\",{\"1\":{\"48\":1}}],[\"稳定时钟\",{\"1\":{\"48\":2}}],[\"超时\",{\"1\":{\"49\":1,\"50\":1}}],[\"超过指定的时长或抵达指定的时间点\",{\"1\":{\"47\":1}}],[\"超线程技术被称为\",{\"1\":{\"10\":1}}],[\"超线程技术是一项硬件创新\",{\"1\":{\"10\":1}}],[\"超线程技术\",{\"1\":{\"10\":1}}],[\"处理可变参数\",{\"1\":{\"85\":1}}],[\"处理绝对时间的函数以\",{\"1\":{\"47\":1}}],[\"处理持续时间的函数以\",{\"1\":{\"47\":1}}],[\"处理步骤\",{\"1\":{\"28\":2}}],[\"毫秒内变为就绪状态\",{\"1\":{\"49\":1}}],[\"毫秒\",{\"1\":{\"47\":1,\"50\":1}}],[\"限定\",{\"1\":{\"80\":1}}],[\"限时等待\",{\"0\":{\"47\":1},\"1\":{\"62\":1}}],[\"限制了对象\",{\"1\":{\"27\":1}}],[\"隐式转移所有权\",{\"1\":{\"46\":1}}],[\"隐式转换为了指向这个数组的指针\",{\"1\":{\"14\":1}}],[\"隐式转换为\",{\"1\":{\"14\":2}}],[\"虽然是\",{\"1\":{\"80\":1}}],[\"虽然教程名为\",{\"1\":{\"74\":1}}],[\"虽然同样不可复制不可移动\",{\"1\":{\"67\":1}}],[\"虽然也可以用互斥量来模拟原子操作\",{\"1\":{\"65\":1}}],[\"虽然它的返回类型是\",{\"1\":{\"46\":1}}],[\"虽强调现代\",{\"1\":{\"0\":1}}],[\"收到数据\",{\"1\":{\"46\":4}}],[\"值初始化了数据成员\",{\"1\":{\"80\":1}}],[\"值\",{\"1\":{\"45\":2,\"67\":1}}],[\"值得注意的是\",{\"1\":{\"36\":1,\"44\":1,\"66\":1}}],[\"产生异常\",{\"1\":{\"45\":1}}],[\"产生线程\",{\"1\":{\"18\":1}}],[\"反之亦然\",{\"1\":{\"45\":1}}],[\"反面示例\",{\"1\":{\"30\":1}}],[\"二选一\",{\"1\":{\"45\":1}}],[\"制作任务\",{\"1\":{\"44\":1}}],[\"改\",{\"1\":{\"65\":1,\"66\":1,\"67\":2}}],[\"改成\",{\"1\":{\"44\":1}}],[\"改写一下\",{\"1\":{\"31\":1}}],[\"作函数形参\",{\"1\":{\"44\":1}}],[\"作为第二个参数\",{\"1\":{\"49\":1}}],[\"作为后缀\",{\"1\":{\"47\":2}}],[\"作为底层数据成员\",{\"1\":{\"18\":1}}],[\"作为\",{\"1\":{\"14\":1}}],[\"作为构造参数\",{\"1\":{\"14\":1}}],[\"作为它的可调用\",{\"1\":{\"9\":1}}],[\"老老实实执行我们传递的任务\",{\"1\":{\"44\":1}}],[\"幻想还有许多耗时的代码\",{\"1\":{\"44\":1}}],[\"目标\",{\"1\":{\"44\":1}}],[\"目标线程的可取消性状态和类型决定了取消何时生效\",{\"1\":{\"21\":1}}],[\"失败时的内存序为\",{\"1\":{\"67\":1}}],[\"失败就返回\",{\"1\":{\"28\":1}}],[\"失去共享状态\",{\"1\":{\"43\":1}}],[\"典型情况是\",{\"1\":{\"43\":1}}],[\"惰性求值\",{\"1\":{\"43\":1}}],[\"you\",{\"1\":{\"66\":4}}],[\"years\",{\"1\":{\"49\":1}}],[\"y\",{\"1\":{\"43\":5,\"65\":9}}],[\"yield\",{\"1\":{\"15\":5,\"72\":1}}],[\"异步任务执行\",{\"0\":{\"51\":1}}],[\"异步任务\",{\"1\":{\"43\":2}}],[\"异常之类的是例外\",{\"1\":{\"33\":1}}],[\"异常\",{\"1\":{\"33\":1,\"45\":1}}],[\"头文件\",{\"1\":{\"43\":1}}],[\"头文件中\",{\"1\":{\"40\":1,\"42\":1}}],[\"若多个执行线程访问同一\",{\"1\":{\"62\":1}}],[\"若每个线程都是通过其自身的\",{\"1\":{\"42\":1,\"46\":1}}],[\"若所有权层数为\",{\"1\":{\"35\":1}}],[\"共享状态在经过指定的等待时间内仍未就绪\",{\"1\":{\"49\":1}}],[\"共享状态就绪\",{\"1\":{\"49\":1}}],[\"共享状态持有的函数正在延迟运行\",{\"1\":{\"49\":1}}],[\"共享状态的\",{\"1\":{\"45\":2}}],[\"共享的\",{\"1\":{\"42\":1}}],[\"共享数据\",{\"0\":{\"24\":1},\"1\":{\"1\":1}}],[\"独占的\",{\"1\":{\"42\":1}}],[\"车到站\",{\"1\":{\"42\":1}}],[\"玩手机等\",{\"1\":{\"42\":1}}],[\"|=\",{\"1\":{\"65\":1}}],[\"|\",{\"1\":{\"41\":60,\"43\":2}}],[\"队列为空\",{\"1\":{\"41\":2}}],[\"初始状态\",{\"1\":{\"41\":1}}],[\"初始化数据成员\",{\"1\":{\"84\":1}}],[\"初始化为\",{\"1\":{\"67\":1}}],[\"初始化严格发生一次\",{\"1\":{\"33\":1}}],[\"初始化\",{\"1\":{\"33\":2,\"66\":1}}],[\"初始化函数f\",{\"1\":{\"16\":2}}],[\"qvboxlayout\",{\"1\":{\"54\":2}}],[\"qsizepolicy\",{\"1\":{\"54\":4}}],[\"qstring\",{\"1\":{\"54\":2}}],[\"qpushbutton\",{\"1\":{\"54\":7}}],[\"qprogressbar\",{\"1\":{\"54\":4}}],[\"qwidget\",{\"1\":{\"54\":2}}],[\"qmessagebox\",{\"1\":{\"54\":3}}],[\"qmetaobject\",{\"1\":{\"52\":5,\"54\":4,\"55\":1}}],[\"qmainwindow\",{\"1\":{\"54\":2}}],[\"qt\",{\"1\":{\"51\":1,\"52\":1,\"53\":1,\"54\":2,\"62\":1,\"74\":1}}],[\"q\",{\"1\":{\"41\":4,\"54\":1}}],[\"queue<int>\",{\"1\":{\"41\":2}}],[\"queue<t>\",{\"1\":{\"41\":1}}],[\"queue\",{\"1\":{\"41\":12}}],[\"消费\",{\"1\":{\"41\":1}}],[\"生产\",{\"1\":{\"41\":1}}],[\"生产者消费者模型\",{\"1\":{\"41\":1}}],[\"生存期结束\",{\"1\":{\"12\":1}}],[\"光写好了肯定不够\",{\"1\":{\"41\":1}}],[\"交换后的\",{\"1\":{\"65\":2}}],[\"交换前的\",{\"1\":{\"65\":2}}],[\"交换\",{\"1\":{\"41\":1,\"67\":1}}],[\"交出\",{\"1\":{\"15\":1}}],[\"阻塞调用会将线程挂起一段\",{\"1\":{\"47\":1}}],[\"阻塞\",{\"1\":{\"45\":1}}],[\"阻塞直到队列不为空\",{\"1\":{\"41\":2}}],[\"阻塞当前线程\",{\"1\":{\"40\":1}}],[\"阻塞当前线程直到线程对象关联的线程执行完毕\",{\"1\":{\"13\":1}}],[\"阻塞当前线程直至\",{\"1\":{\"12\":1}}],[\"基于时间段的等待都是由\",{\"1\":{\"49\":1}}],[\"基于以上思考\",{\"1\":{\"41\":1}}],[\"基本认识也就足够了\",{\"1\":{\"71\":1}}],[\"基本都是多核\",{\"1\":{\"5\":1}}],[\"基本上是二者都有\",{\"1\":{\"5\":1}}],[\"基本概念\",{\"0\":{\"2\":1},\"1\":{\"1\":1}}],[\"操作失败\",{\"1\":{\"67\":1}}],[\"操作成功\",{\"1\":{\"67\":1}}],[\"操作来设置和获取值\",{\"1\":{\"65\":1}}],[\"操作仅限\",{\"1\":{\"65\":1}}],[\"操作的线程将会一直阻塞\",{\"1\":{\"58\":2}}],[\"操作\",{\"1\":{\"41\":4,\"53\":1,\"58\":1,\"65\":4,\"66\":1,\"67\":1}}],[\"操作时队列不为空\",{\"1\":{\"41\":1}}],[\"操作时\",{\"1\":{\"41\":2}}],[\"操作受保护的数据\",{\"1\":{\"29\":1}}],[\"虚假唤醒\",{\"1\":{\"40\":1}}],[\"②等价于\",{\"1\":{\"40\":1}}],[\"唤醒了等待在条件变量上的线程\",{\"1\":{\"40\":1}}],[\"唤醒一个等待条件变量的线程\",{\"1\":{\"40\":1}}],[\"暂停当前线程\",{\"1\":{\"40\":1}}],[\"效果相同\",{\"1\":{\"40\":1}}],[\"版更加通用但是却有更多的性能开销\",{\"1\":{\"40\":1}}],[\"能用于避免数据竞争\",{\"1\":{\"62\":1}}],[\"能控制对共享资源的访问\",{\"1\":{\"58\":1}}],[\"能够正常点击\",{\"1\":{\"52\":1}}],[\"能关联多个事件\",{\"1\":{\"42\":1}}],[\"能在任何满足可基本锁定\",{\"1\":{\"40\":1}}],[\"能会有一些难以理解的地方\",{\"1\":{\"23\":1}}],[\"休眠\",{\"1\":{\"40\":1}}],[\"休眠②前函数对互斥量解锁①\",{\"1\":{\"40\":1}}],[\"循环中\",{\"1\":{\"40\":1}}],[\"忙等待\",{\"1\":{\"40\":1}}],[\"估算一下地铁到达目的地的时间\",{\"1\":{\"40\":1}}],[\"介绍两种指定超时的方式\",{\"1\":{\"47\":1}}],[\"介绍\",{\"1\":{\"39\":1}}],[\"介绍了一下\",{\"1\":{\"15\":1}}],[\"条件变量虚假唤醒是指在使用条件变量进行线程同步时\",{\"1\":{\"40\":1}}],[\"条件变量的\",{\"1\":{\"40\":1}}],[\"条件变量\",{\"1\":{\"39\":1,\"40\":1,\"41\":1,\"47\":1}}],[\"条件变量等设施\",{\"1\":{\"38\":1}}],[\"条件竞争\",{\"0\":{\"25\":1}}],[\"语言定义中只有这些类型的操作是原子的\",{\"1\":{\"65\":1}}],[\"语言特性\",{\"1\":{\"37\":1}}],[\"语言层面没有进程的概念\",{\"1\":{\"3\":1}}],[\"默认移动\",{\"1\":{\"80\":1}}],[\"默认的内存顺序是\",{\"1\":{\"66\":1}}],[\"默认值是\",{\"1\":{\"60\":1}}],[\"默认是根据第一个参数时钟得到的\",{\"1\":{\"50\":1}}],[\"默认情况就支持\",{\"1\":{\"37\":1}}],[\"默认构造函数\",{\"1\":{\"80\":1}}],[\"默认构造会上锁\",{\"1\":{\"31\":1}}],[\"默认构造\",{\"1\":{\"14\":1,\"16\":1,\"43\":1,\"75\":1}}],[\"两种\",{\"1\":{\"37\":1}}],[\"两个线程分别运行\",{\"1\":{\"41\":1}}],[\"两个线程需要对它们所有的互斥量做一些操作\",{\"1\":{\"30\":1}}],[\"两个线程共享一个\",{\"1\":{\"25\":1}}],[\"两个函数共享了一个锁\",{\"1\":{\"27\":1}}],[\"两个冲突的求值都是原子操作\",{\"1\":{\"25\":1}}],[\"两个求值都在同一线程上\",{\"1\":{\"25\":1}}],[\"两个\",{\"1\":{\"16\":1,\"80\":1}}],[\"机制\",{\"1\":{\"37\":1}}],[\"来去除了类型的引用和\",{\"1\":{\"80\":1}}],[\"来发现和解决内存次序错误\",{\"1\":{\"71\":1}}],[\"来进行同步操作\",{\"1\":{\"65\":1}}],[\"来保护共享资源\",{\"1\":{\"64\":1}}],[\"来跨线程调用主线程上的控件方法\",{\"1\":{\"52\":1}}],[\"来表示\",{\"1\":{\"50\":1}}],[\"来完成\",{\"1\":{\"49\":2}}],[\"来指定\",{\"1\":{\"48\":1}}],[\"来替代\",{\"1\":{\"46\":1}}],[\"来自\",{\"1\":{\"45\":2}}],[\"来自线程的异常\",{\"1\":{\"45\":2}}],[\"来实现线程局部存储\",{\"1\":{\"37\":1}}],[\"来管理线程局部存储\",{\"1\":{\"37\":1}}],[\"来处理这种情况\",{\"1\":{\"33\":1}}],[\"例如\",{\"1\":{\"37\":1,\"48\":1,\"49\":2,\"59\":1,\"65\":3,\"66\":1,\"67\":1,\"71\":2,\"74\":1}}],[\"例子\",{\"1\":{\"36\":1}}],[\"展示多线程异步的必要性\",{\"1\":{\"74\":1}}],[\"展示异步多线程的必要性\",{\"1\":{\"62\":1}}],[\"展示可以使用\",{\"1\":{\"44\":1}}],[\"展示了如何使用\",{\"1\":{\"65\":1}}],[\"展示了如何在不阻塞\",{\"1\":{\"51\":1}}],[\"展示了\",{\"1\":{\"37\":1}}],[\"展开之后\",{\"1\":{\"80\":1}}],[\"展开就是\",{\"1\":{\"80\":1}}],[\"展开\",{\"1\":{\"23\":1}}],[\"互斥体\",{\"1\":{\"84\":1}}],[\"互斥量确保了对共享资源的读写是线程安全的\",{\"1\":{\"64\":1}}],[\"互斥量才会真正释放\",{\"1\":{\"35\":1}}],[\"互斥量只是其中一种常见的方式而已\",{\"1\":{\"33\":1}}],[\"互斥量满足互斥体\",{\"1\":{\"32\":1}}],[\"互斥量主要也就是为了保护共享数据\",{\"1\":{\"29\":1}}],[\"互斥量\",{\"1\":{\"26\":1,\"41\":1}}],[\"互不干扰\",{\"1\":{\"37\":1}}],[\"广泛应用于各种编程语言\",{\"1\":{\"37\":1}}],[\"存在于\",{\"1\":{\"49\":1}}],[\"存在竞争条件\",{\"1\":{\"46\":2}}],[\"存在数据竞争\",{\"1\":{\"36\":2}}],[\"存储了一个\",{\"1\":{\"83\":1}}],[\"存储了函数对象和参数的副本的指针\",{\"1\":{\"80\":1}}],[\"存储了传入的函数对象和参数的副本\",{\"1\":{\"80\":1}}],[\"存储新值\",{\"1\":{\"67\":1}}],[\"存储操作\",{\"1\":{\"65\":1}}],[\"存储每个线程要执行的任务\",{\"1\":{\"44\":1}}],[\"存储每个线程的结果\",{\"1\":{\"10\":1}}],[\"存储关联线程的线程对象\",{\"1\":{\"10\":1,\"44\":1}}],[\"换句话说\",{\"1\":{\"36\":1}}],[\"换行并刷新\",{\"1\":{\"9\":1}}],[\"起\",{\"1\":{\"36\":1,\"65\":2}}],[\"全部初始化为\",{\"1\":{\"75\":1}}],[\"全局二元信号量对象\",{\"1\":{\"58\":1}}],[\"全局的\",{\"1\":{\"36\":1}}],[\"全局\",{\"1\":{\"36\":1}}],[\"全是\",{\"1\":{\"25\":1}}],[\"运算符\",{\"1\":{\"36\":1}}],[\"运算符的库函数实际是线程安全的\",{\"1\":{\"38\":1}}],[\"运算符的库版本\",{\"1\":{\"36\":2}}],[\"运算符的用户替换版本\",{\"1\":{\"36\":1}}],[\"运算符和\",{\"1\":{\"36\":2}}],[\"运行也难以发现\",{\"1\":{\"71\":1}}],[\"运行结果\",{\"1\":{\"15\":1,\"37\":1,\"45\":2,\"58\":1}}],[\"运行代码\",{\"1\":{\"14\":2}}],[\"运行测试\",{\"1\":{\"10\":2,\"14\":1,\"18\":2,\"21\":1,\"35\":2,\"37\":2,\"40\":1,\"43\":4,\"44\":4,\"45\":1,\"50\":2,\"58\":1,\"60\":1,\"65\":3,\"66\":1,\"67\":2,\"84\":1}}],[\"帮助我们完成这件事情\",{\"1\":{\"84\":1}}],[\"帮助我们进行遍历元组即可\",{\"1\":{\"80\":1}}],[\"帮助写出\",{\"1\":{\"30\":1}}],[\"帮我们管理\",{\"1\":{\"35\":1}}],[\"递归锁\",{\"1\":{\"38\":1}}],[\"递归调用\",{\"1\":{\"35\":1}}],[\"递归函数\",{\"1\":{\"35\":1}}],[\"规则\",{\"1\":{\"34\":1}}],[\"做的一样\",{\"1\":{\"34\":1}}],[\"每个操作都可以指定内存顺序\",{\"1\":{\"66\":1}}],[\"每个线程拥有自己独立的对象实例\",{\"1\":{\"37\":1}}],[\"每个线程都有一个\",{\"1\":{\"46\":1}}],[\"每个线程都有其自己的\",{\"1\":{\"36\":1}}],[\"每个线程都抢着完成自己的任务\",{\"1\":{\"25\":1}}],[\"每个线程只需要使用\",{\"1\":{\"33\":1}}],[\"每个线程只持有一个锁\",{\"1\":{\"30\":1}}],[\"每个线程的处理情况如下\",{\"1\":{\"10\":1}}],[\"每种时钟类型都提供了四种不同的信息\",{\"1\":{\"48\":1}}],[\"每一站都能知道\",{\"1\":{\"40\":1}}],[\"每一个线程都有独立的\",{\"1\":{\"37\":1}}],[\"每次递归都会锁定互斥量\",{\"1\":{\"35\":1}}],[\"每次用户打开程序的时候\",{\"1\":{\"34\":1}}],[\"此调用后\",{\"1\":{\"80\":1}}],[\"此操作可能会由于某些硬件的特性而出现假失败\",{\"1\":{\"67\":1}}],[\"此外\",{\"1\":{\"59\":1,\"71\":1}}],[\"此处延时三秒可以方便测试\",{\"1\":{\"58\":1}}],[\"此处获取返回值\",{\"1\":{\"44\":1}}],[\"此处执行任务\",{\"1\":{\"44\":1}}],[\"此策略表示由实现选择到底是否创建线程执行异步任务\",{\"1\":{\"43\":1}}],[\"此线程对\",{\"1\":{\"35\":1}}],[\"此方式也在单例中多见\",{\"1\":{\"33\":1}}],[\"此时线程\",{\"1\":{\"27\":1}}],[\"此时线程函数还持有函数局部对象的指针或引用\",{\"1\":{\"12\":1}}],[\"此时可以判断操作是否完成\",{\"1\":{\"15\":1}}],[\"此时我们的\",{\"1\":{\"12\":1}}],[\"此时分离的子线程可能没有执行完毕\",{\"1\":{\"12\":1}}],[\"此时\",{\"1\":{\"12\":1,\"14\":2,\"16\":1,\"25\":1,\"66\":2,\"67\":1,\"80\":1}}],[\"测试并设置\",{\"1\":{\"66\":1}}],[\"测试\",{\"1\":{\"52\":2,\"54\":2}}],[\"测试链接\",{\"1\":{\"33\":1,\"34\":1}}],[\"测试代码\",{\"1\":{\"12\":1,\"13\":1,\"30\":2}}],[\"次调用\",{\"1\":{\"33\":1}}],[\"次都是执行函数\",{\"1\":{\"27\":1}}],[\"第二个线程调用\",{\"1\":{\"67\":1}}],[\"第二个线程等待结果并访问数据\",{\"1\":{\"46\":1}}],[\"第二个模板参数用来表示时间单位\",{\"1\":{\"50\":1}}],[\"第二个参数就是先前提到的\",{\"1\":{\"49\":1}}],[\"第二种方法就是加个延时\",{\"1\":{\"40\":1}}],[\"第三种方式\",{\"1\":{\"40\":1}}],[\"第\",{\"1\":{\"33\":1}}],[\"第一个模板参数用来指定使用的时钟\",{\"1\":{\"50\":1}}],[\"第一个线程等待结果并访问数据\",{\"1\":{\"46\":1}}],[\"第一个调用\",{\"1\":{\"26\":1}}],[\"第一个功能很简单\",{\"1\":{\"21\":1}}],[\"比较和复制是逐位的\",{\"1\":{\"71\":1}}],[\"比较\",{\"1\":{\"67\":1}}],[\"比自旋好的多\",{\"1\":{\"66\":1}}],[\"比显式使用互斥量消耗的资源更少\",{\"1\":{\"33\":1}}],[\"比起锁住互斥量并显式检查指针\",{\"1\":{\"33\":1}}],[\"比如第二章的并行求和\",{\"1\":{\"62\":1}}],[\"比如到\",{\"1\":{\"47\":1}}],[\"比如抛出异常\",{\"1\":{\"47\":1}}],[\"比如学习现代\",{\"1\":{\"42\":1}}],[\"比如手机的地图\",{\"1\":{\"40\":1}}],[\"比如我们要讲的互斥量\",{\"1\":{\"38\":1}}],[\"比如我的\",{\"1\":{\"10\":1}}],[\"比如互斥量或原子操作\",{\"1\":{\"36\":1}}],[\"比如异常\",{\"1\":{\"33\":1}}],[\"比如对于共享数据的初始化过程的保护\",{\"1\":{\"33\":1}}],[\"比如当函数返回std\",{\"1\":{\"32\":1}}],[\"比如前面提到的\",{\"1\":{\"32\":1}}],[\"比如保护共享数据中的\",{\"1\":{\"30\":1}}],[\"比如一个遥控汽车\",{\"1\":{\"30\":1}}],[\"比如这段代码就是典型的恶性条件竞争\",{\"1\":{\"25\":1}}],[\"比如两个线程都要往标准输出输出一段字符\",{\"1\":{\"25\":1}}],[\"比如函数结束\",{\"1\":{\"12\":1}}],[\"比如重载了\",{\"1\":{\"12\":1}}],[\"比如\",{\"1\":{\"10\":2,\"25\":1,\"30\":1,\"47\":1,\"48\":1}}],[\"④\",{\"1\":{\"33\":1}}],[\"①\",{\"1\":{\"33\":1}}],[\"错误难以被我们观察到的原因其实可以简单的说\",{\"1\":{\"71\":1}}],[\"错误\",{\"1\":{\"33\":2,\"80\":1}}],[\"双检锁\",{\"1\":{\"33\":2}}],[\"举一个简单的调用例子\",{\"1\":{\"84\":1}}],[\"举一个使用\",{\"1\":{\"32\":1}}],[\"举个例子\",{\"1\":{\"10\":1,\"12\":1,\"42\":1}}],[\"故所有\",{\"1\":{\"32\":1}}],[\"除了直接使用\",{\"1\":{\"65\":1}}],[\"除了\",{\"1\":{\"45\":1}}],[\"除了类成员或函数形参\",{\"1\":{\"32\":1}}],[\"除非你真的知道自己在做什么\",{\"1\":{\"66\":1}}],[\"除非我们写成\",{\"1\":{\"31\":1}}],[\"除非其中一个孩子决定让另一个先玩\",{\"1\":{\"30\":1}}],[\"除非\",{\"1\":{\"25\":1}}],[\"除非给参数\",{\"1\":{\"14\":1}}],[\"说明\",{\"1\":{\"52\":1}}],[\"说明符只能搭配变量声明和函数声明\",{\"1\":{\"32\":1}}],[\"说实话挺麻烦的\",{\"1\":{\"15\":1}}],[\"切勿被词语迷惑\",{\"1\":{\"32\":1}}],[\"切勿将受保护数据的指针或引用传递到互斥量作用域之外\",{\"1\":{\"29\":1}}],[\"原子的替换当前对象的值\",{\"1\":{\"67\":1}}],[\"原子类型的所有操作都是原子的\",{\"1\":{\"66\":1}}],[\"原子类型的每个操作函数\",{\"1\":{\"65\":1}}],[\"原子类型\",{\"0\":{\"65\":1}}],[\"原子类型在我们第五章的内容会详细展开\",{\"1\":{\"62\":1}}],[\"原子操作可以代替互斥量\",{\"1\":{\"65\":1}}],[\"原子操作\",{\"0\":{\"64\":1}}],[\"原子操作即不可分割的操作\",{\"1\":{\"63\":1}}],[\"原子地增加计数\",{\"1\":{\"58\":1}}],[\"原子地减少计数\",{\"1\":{\"58\":1}}],[\"原来的\",{\"1\":{\"46\":1}}],[\"原来的置空\",{\"1\":{\"32\":1}}],[\"原因很简单\",{\"1\":{\"31\":1}}],[\"请再次尝试\",{\"1\":{\"80\":1}}],[\"请注意\",{\"1\":{\"66\":1}}],[\"请求\",{\"1\":{\"58\":1}}],[\"请求到达\",{\"1\":{\"58\":1}}],[\"请求线程停止\",{\"1\":{\"21\":2}}],[\"请无视我们省略的构造\",{\"1\":{\"41\":1}}],[\"请勿对移动语义和转移所有权抱有错误的幻想\",{\"1\":{\"32\":1}}],[\"环境也就是\",{\"1\":{\"31\":1}}],[\"很早之前就不支持\",{\"1\":{\"78\":1}}],[\"很多线程在等待的时候\",{\"1\":{\"46\":1}}],[\"很简单\",{\"1\":{\"31\":1}}],[\"很诡异的设计对吧\",{\"1\":{\"31\":1}}],[\"别的标准库也都有类似设计\",{\"1\":{\"31\":1}}],[\"设为\",{\"1\":{\"67\":2}}],[\"设计挺奇怪的对吧\",{\"1\":{\"31\":1}}],[\"设置对象初始计数为\",{\"1\":{\"58\":1}}],[\"设置窗口布局为垂直布局管理器\",{\"1\":{\"54\":1}}],[\"设置布局\",{\"1\":{\"54\":1}}],[\"设置进度条文本字体\",{\"1\":{\"54\":1}}],[\"设置每个进度块的宽度\",{\"1\":{\"54\":1}}],[\"设置值\",{\"1\":{\"45\":1}}],[\"设置\",{\"1\":{\"40\":1,\"66\":2}}],[\"设置了一个标志位\",{\"1\":{\"40\":1}}],[\"设置条件变量为\",{\"1\":{\"40\":1}}],[\"设置为\",{\"1\":{\"31\":3,\"67\":2}}],[\"设置取消点\",{\"1\":{\"23\":1}}],[\"设置时区麻烦\",{\"1\":{\"15\":1}}],[\"设置要等待的时间点为当前时间点之后的5秒\",{\"1\":{\"15\":1}}],[\"了解一个庞大的类\",{\"1\":{\"79\":1}}],[\"了解内存次序并非硬性需求\",{\"1\":{\"71\":1}}],[\"了解基本构成\",{\"1\":{\"48\":1}}],[\"了解其它\",{\"1\":{\"37\":1}}],[\"了解其实现\",{\"1\":{\"17\":1}}],[\"了\",{\"1\":{\"31\":2,\"46\":1,\"56\":1,\"78\":1}}],[\"尤其它还可以与我们下一章要讲的条件变量一起使用\",{\"1\":{\"31\":1}}],[\"尤其是某些说法准确性也一般\",{\"1\":{\"7\":1}}],[\"灵活的锁\",{\"0\":{\"31\":1}}],[\"固定的顺序上锁就不存在问题\",{\"1\":{\"30\":1}}],[\"外部程序可能做任何事情\",{\"1\":{\"30\":1}}],[\"约束开发者的行为\",{\"1\":{\"30\":1}}],[\"程序能通过编译即代表满足要求\",{\"1\":{\"65\":1}}],[\"程序都能正常完成工作\",{\"1\":{\"30\":1}}],[\"程序老老实实执行完毕\",{\"1\":{\"25\":1}}],[\"甚至不能当普通的\",{\"1\":{\"66\":1}}],[\"甚至估算错误导致坐过站\",{\"1\":{\"40\":1}}],[\"甚至难以复现\",{\"1\":{\"30\":1}}],[\"甚至深入阅读了部分的\",{\"1\":{\"24\":1}}],[\"新增了三个用作协程的关键字\",{\"1\":{\"72\":1}}],[\"新增了\",{\"1\":{\"30\":1}}],[\"哪个都没办法往下执行\",{\"1\":{\"30\":1}}],[\"往下执行需要上锁\",{\"1\":{\"30\":1}}],[\"完成递增操作之前\",{\"1\":{\"64\":1}}],[\"完成前不开始\",{\"1\":{\"43\":1}}],[\"完整代码实现\",{\"0\":{\"54\":1}}],[\"完整代码\",{\"1\":{\"34\":1}}],[\"完整代码测试\",{\"1\":{\"27\":1}}],[\"完全可能线程\",{\"1\":{\"30\":1}}],[\"😅😅\",{\"1\":{\"66\":1}}],[\"😅\",{\"1\":{\"30\":1,\"84\":1}}],[\"😢\",{\"1\":{\"25\":1}}],[\"🤣🤣\",{\"1\":{\"32\":1}}],[\"🤣\",{\"1\":{\"30\":1}}],[\"考虑用户调用的时候将参数交换\",{\"1\":{\"30\":1}}],[\"依旧会产生问题\",{\"1\":{\"30\":1}}],[\"依然实际是复制\",{\"1\":{\"14\":1}}],[\"要符合\",{\"1\":{\"80\":1}}],[\"要注意的是\",{\"1\":{\"37\":1}}],[\"要求\",{\"1\":{\"65\":1}}],[\"要求的锁上工作\",{\"1\":{\"40\":1}}],[\"要求下列函数是线程安全的\",{\"1\":{\"36\":1}}],[\"要求构造函数之前和构造函数之后都不能再次上锁\",{\"1\":{\"31\":1}}],[\"要求构造之后上锁\",{\"1\":{\"31\":1}}],[\"要求在构造之前互斥量上锁\",{\"1\":{\"31\":1}}],[\"要想调用\",{\"1\":{\"31\":1}}],[\"要么一个都不锁\",{\"1\":{\"30\":1}}],[\"要么将互斥量都上锁\",{\"1\":{\"30\":1}}],[\"要往下执行\",{\"1\":{\"30\":1}}],[\"要走\",{\"1\":{\"28\":1}}],[\"总而言之\",{\"1\":{\"36\":1}}],[\"总而言之就是\",{\"1\":{\"35\":1}}],[\"总在互斥量\",{\"1\":{\"30\":1}}],[\"总结\",{\"0\":{\"7\":1,\"23\":1,\"38\":1,\"62\":1,\"76\":1,\"81\":1,\"85\":1}}],[\"问题取决于程序和系统的具体实现\",{\"1\":{\"40\":1}}],[\"问题就出现了\",{\"1\":{\"30\":1}}],[\"问题与解决\",{\"0\":{\"30\":1}}],[\"遥控器和玩具车被放在两个不同的地方\",{\"1\":{\"30\":1}}],[\"他把自己的那个部分给另一个小孩\",{\"1\":{\"30\":1}}],[\"他就得等待另一个小孩玩完才行\",{\"1\":{\"30\":1}}],[\"他们都想玩这个玩具\",{\"1\":{\"30\":1}}],[\"试想一下\",{\"1\":{\"30\":1,\"34\":1}}],[\"死锁是多线程编程中令人相当头疼的问题\",{\"1\":{\"30\":1}}],[\"死锁\",{\"0\":{\"30\":1},\"1\":{\"30\":1,\"38\":1}}],[\"受保护的数据被传递\",{\"1\":{\"29\":1}}],[\"受保护数据传递给函数\",{\"1\":{\"29\":1}}],[\"修改指针\",{\"1\":{\"36\":1}}],[\"修改\",{\"1\":{\"30\":1}}],[\"修改数据成员等\",{\"1\":{\"29\":1}}],[\"修改的\",{\"1\":{\"27\":1}}],[\"释放独占指针的所有权\",{\"1\":{\"80\":1}}],[\"释放\",{\"1\":{\"40\":1,\"58\":3}}],[\"释放操作是线程安全\",{\"1\":{\"36\":1}}],[\"释放锁\",{\"1\":{\"28\":2}}],[\"释放所有获取的资源并执行其它必要的清理操作\",{\"1\":{\"12\":1}}],[\"模式\",{\"1\":{\"78\":1}}],[\"模拟\",{\"1\":{\"58\":1}}],[\"模拟处理时间\",{\"1\":{\"58\":1}}],[\"模拟耗时操作\",{\"1\":{\"46\":2}}],[\"模拟一些计算\",{\"1\":{\"45\":1}}],[\"模拟地铁到站\",{\"1\":{\"40\":2}}],[\"模拟临界区操作\",{\"1\":{\"28\":1}}],[\"模板的知识必不可少\",{\"1\":{\"73\":1}}],[\"模板外\",{\"1\":{\"65\":1}}],[\"模板教程\",{\"1\":{\"42\":1}}],[\"模板\",{\"1\":{\"27\":1,\"65\":1}}],[\"临时量的析构函数等待\",{\"1\":{\"43\":1}}],[\"临时对象初始化\",{\"1\":{\"16\":1}}],[\"临时对象是右值表达式\",{\"1\":{\"16\":2}}],[\"临界区\",{\"1\":{\"38\":1}}],[\"临界区代码\",{\"1\":{\"28\":1}}],[\"获得信号\",{\"1\":{\"58\":4}}],[\"获得的\",{\"1\":{\"43\":1}}],[\"获得锁\",{\"1\":{\"28\":2}}],[\"获取元组存储的数据\",{\"1\":{\"80\":1}}],[\"获取它的函数指针\",{\"1\":{\"80\":1}}],[\"获取当前时间\",{\"1\":{\"50\":1}}],[\"获取当前时间点\",{\"1\":{\"15\":1}}],[\"获取\",{\"1\":{\"45\":2,\"48\":1,\"67\":1}}],[\"获取任务的返回值加起来即可\",{\"1\":{\"44\":1}}],[\"获取任务返回值罢了\",{\"1\":{\"44\":1}}],[\"获取访问权\",{\"1\":{\"34\":1}}],[\"获取锁失败\",{\"1\":{\"28\":2}}],[\"获取的值自然也会是\",{\"1\":{\"10\":1}}],[\"特有的\",{\"1\":{\"66\":1}}],[\"特定的时间点则可以通过\",{\"1\":{\"48\":1}}],[\"特别是当初始化完成之后\",{\"1\":{\"33\":1}}],[\"特别是在需要保护临界区的同时\",{\"1\":{\"28\":1}}],[\"特性\",{\"1\":{\"20\":1}}],[\"添加了一个新的特性\",{\"1\":{\"27\":1}}],[\"添加元素\",{\"1\":{\"25\":1}}],[\"给两个互斥量上锁\",{\"1\":{\"30\":1}}],[\"给\",{\"1\":{\"30\":2}}],[\"给整个函数上锁\",{\"1\":{\"27\":1}}],[\"给互斥量上锁\",{\"1\":{\"26\":1,\"27\":1}}],[\"避免歧义和许多问题\",{\"1\":{\"75\":1}}],[\"避免了运行时的判断开销\",{\"1\":{\"65\":1}}],[\"避免了数据竞争问题\",{\"1\":{\"64\":1}}],[\"避免了数据竞争\",{\"1\":{\"27\":1}}],[\"避免另一线程在第一次检查后再做初始化\",{\"1\":{\"33\":1}}],[\"避免在持有锁时调用外部代码\",{\"1\":{\"30\":1}}],[\"避免嵌套锁\",{\"1\":{\"30\":1}}],[\"避免死锁的一般建议是让两个互斥量以相同的顺序上锁\",{\"1\":{\"30\":1}}],[\"避免程序被抛出的异常所终止\",{\"1\":{\"12\":1}}],[\"成为一种单次使用的屏障\",{\"1\":{\"60\":1}}],[\"成功时的内存序为\",{\"1\":{\"67\":1}}],[\"成功获取锁\",{\"1\":{\"66\":1}}],[\"成功获取信号量\",{\"1\":{\"58\":2}}],[\"成功链接上\",{\"1\":{\"32\":1}}],[\"成功调用\",{\"1\":{\"27\":1}}],[\"成员就是保有线程的\",{\"1\":{\"79\":1}}],[\"成员是指向线程的句柄\",{\"1\":{\"79\":1}}],[\"成员函数获取底层指针\",{\"1\":{\"80\":1}}],[\"成员函数获取这个值\",{\"1\":{\"45\":1}}],[\"成员函数获得计次数\",{\"1\":{\"49\":1}}],[\"成员函数一样有两个重载\",{\"1\":{\"47\":1}}],[\"成员函数一样可以用来构造\",{\"1\":{\"46\":1}}],[\"成员函数检查\",{\"1\":{\"43\":1}}],[\"成员函数有两个版本\",{\"1\":{\"40\":1}}],[\"成员函数即可\",{\"1\":{\"32\":1}}],[\"成员函数\",{\"1\":{\"31\":2,\"43\":2,\"45\":1,\"62\":1,\"65\":1}}],[\"成员函数的时候执行任务\",{\"1\":{\"43\":1}}],[\"成员函数的时候\",{\"1\":{\"31\":1}}],[\"成员函数的代码\",{\"1\":{\"31\":1}}],[\"成员函数的\",{\"1\":{\"31\":1}}],[\"成员函数模板\",{\"1\":{\"29\":1}}],[\"成员函数指针也是可调用\",{\"1\":{\"14\":1}}],[\"成员指针不可以转换到函数指针单独使用\",{\"1\":{\"14\":1}}],[\"成员指针必须和对象一起使用\",{\"1\":{\"14\":1}}],[\"希望您拥有\",{\"1\":{\"72\":1}}],[\"希望您是已经较为熟练使用模板\",{\"1\":{\"0\":1}}],[\"希望大家分清楚\",{\"1\":{\"27\":1}}],[\"包含复制构造函数与复制赋值\",{\"1\":{\"62\":1}}],[\"包含在其中的代码是线程安全的\",{\"1\":{\"26\":1}}],[\"包括但不限于\",{\"1\":{\"74\":1}}],[\"包括条件变量\",{\"1\":{\"62\":1}}],[\"包括支持使用\",{\"1\":{\"43\":1}}],[\"包括虚假唤醒\",{\"1\":{\"40\":1}}],[\"包括管理互斥量的管理类\",{\"1\":{\"38\":1}}],[\"包括获取锁\",{\"1\":{\"30\":1}}],[\"包装任何可调用\",{\"1\":{\"44\":1}}],[\"包装\",{\"1\":{\"30\":1,\"44\":1}}],[\"包起来了\",{\"1\":{\"27\":1}}],[\"涉及读写共享资源\",{\"1\":{\"36\":1}}],[\"涉及到了对共享数据的修改\",{\"1\":{\"27\":1}}],[\"涉及共享资源的修改的代码\",{\"1\":{\"27\":1,\"31\":1}}],[\"较为严格的内存模型\",{\"1\":{\"74\":1}}],[\"较小的粒度意味着锁定的范围更小\",{\"1\":{\"27\":1}}],[\"较少\",{\"1\":{\"15\":1}}],[\"粒度\",{\"1\":{\"27\":1,\"38\":1}}],[\"离开作用域析构的时候解锁\",{\"1\":{\"27\":1}}],[\"式的管理\",{\"1\":{\"27\":1}}],[\"简短的代码可以不额外占行\",{\"1\":{\"75\":1}}],[\"简而言之\",{\"1\":{\"26\":1,\"29\":1,\"30\":1,\"31\":1,\"33\":1,\"44\":1,\"45\":1}}],[\"简单来说是\",{\"1\":{\"84\":1}}],[\"简单来说也就是\",{\"1\":{\"20\":1}}],[\"简单使用一下\",{\"1\":{\"18\":1}}],[\"简单直观\",{\"1\":{\"15\":1}}],[\"简单的说就是不一定会调用析构\",{\"1\":{\"13\":1}}],[\"简单的说是\",{\"1\":{\"13\":1}}],[\"简单的测试运行的确没问题\",{\"1\":{\"12\":1}}],[\"简单点说\",{\"1\":{\"12\":1}}],[\"简单\",{\"1\":{\"0\":1}}],[\"直至提醒者通过调用\",{\"1\":{\"58\":1}}],[\"直至获得锁\",{\"1\":{\"26\":1}}],[\"直到先前持有锁的线程调用\",{\"1\":{\"66\":1}}],[\"直到主线程调用\",{\"1\":{\"60\":1}}],[\"直到\",{\"1\":{\"60\":1}}],[\"直到计数大于\",{\"1\":{\"58\":1}}],[\"直到对应的事件发生\",{\"1\":{\"47\":1}}],[\"直到被设置为止\",{\"1\":{\"45\":1}}],[\"直到结果可用\",{\"1\":{\"45\":1}}],[\"直到条件被满足\",{\"1\":{\"40\":1}}],[\"直到条件满足时被唤醒\",{\"1\":{\"40\":1}}],[\"直到线程执行\",{\"1\":{\"26\":1}}],[\"直接改成\",{\"1\":{\"65\":1}}],[\"直接执行了\",{\"1\":{\"33\":1}}],[\"直接创建临时对象即可\",{\"1\":{\"12\":1}}],[\"状态\",{\"1\":{\"26\":2,\"49\":1,\"66\":4}}],[\"锁定了\",{\"1\":{\"30\":2}}],[\"锁\",{\"1\":{\"26\":1,\"40\":1}}],[\"未指定\",{\"1\":{\"65\":11}}],[\"未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步\",{\"1\":{\"33\":1}}],[\"未定义行为\",{\"1\":{\"25\":2}}],[\"未发布\",{\"1\":{\"21\":1}}],[\"标志那样使用\",{\"1\":{\"66\":1}}],[\"标志位\",{\"1\":{\"26\":1}}],[\"标准并发库\",{\"1\":{\"73\":1}}],[\"标准原子类型定义在头文件\",{\"1\":{\"65\":1}}],[\"标准的原子的类型实现可能是\",{\"1\":{\"65\":1}}],[\"标准的\",{\"1\":{\"37\":1}}],[\"标准输出可能交错\",{\"1\":{\"34\":1}}],[\"标准委员会也认为处理此问题很重要\",{\"1\":{\"33\":1}}],[\"标准库设施\",{\"1\":{\"78\":1}}],[\"标准库还提供了一组宏\",{\"1\":{\"65\":1}}],[\"标准库对其的支持却来得很晚\",{\"1\":{\"58\":1}}],[\"标准库对条件变量有两套实现\",{\"1\":{\"40\":1}}],[\"标准库增加了时间字面量\",{\"1\":{\"49\":1}}],[\"标准库在\",{\"1\":{\"49\":1}}],[\"标准库通过它定义了很多的时间类型\",{\"1\":{\"48\":1}}],[\"标准库有两种\",{\"1\":{\"42\":1}}],[\"标准库有很多办法解决这个问题\",{\"1\":{\"30\":1}}],[\"标准库将这种事件称为\",{\"1\":{\"42\":1}}],[\"标准库则没有这个烦恼了\",{\"1\":{\"40\":1}}],[\"标准库提供的一种互斥量类型\",{\"1\":{\"35\":1}}],[\"标准库自然为我们提供了\",{\"1\":{\"34\":1}}],[\"标准库引入的\",{\"1\":{\"27\":1}}],[\"标准库进行多线程编程\",{\"1\":{\"23\":1}}],[\"标准库中\",{\"1\":{\"11\":1,\"48\":2}}],[\"标量类型等都同理\",{\"1\":{\"25\":1}}],[\"另一方面\",{\"1\":{\"65\":1}}],[\"另一种是\",{\"1\":{\"47\":1}}],[\"另一种情况就是得显式使用\",{\"1\":{\"32\":1}}],[\"另一个简单的原子类型是特化的原子指针\",{\"1\":{\"67\":1}}],[\"另一个拿到了玩具车\",{\"1\":{\"30\":1}}],[\"另一个\",{\"1\":{\"25\":1}}],[\"另外我们的代码都会测试三大编译器\",{\"1\":{\"74\":1}}],[\"另外再聊一聊开销吧\",{\"1\":{\"31\":1}}],[\"另外提示一下\",{\"1\":{\"12\":1}}],[\"见上文\",{\"1\":{\"65\":1}}],[\"见\",{\"1\":{\"25\":2,\"49\":1,\"65\":1}}],[\"拥有两个冲突的求值的程序就有数据竞争\",{\"1\":{\"25\":1}}],[\"又不想线程因为等待锁而阻塞的情况下\",{\"1\":{\"28\":1}}],[\"又称为互斥锁\",{\"1\":{\"26\":1}}],[\"又去执行另一个线程\",{\"1\":{\"25\":1}}],[\"又或者闹钟没电了睡过站\",{\"1\":{\"40\":1}}],[\"又或者\",{\"1\":{\"25\":1}}],[\"又或者一边看电视一边吃零食\",{\"1\":{\"4\":1}}],[\"等成员函数对\",{\"1\":{\"65\":1}}],[\"等价于\",{\"1\":{\"48\":1}}],[\"等操作方式\",{\"1\":{\"65\":1}}],[\"等操作\",{\"1\":{\"41\":1}}],[\"等标准库设施用作同步操作\",{\"1\":{\"39\":1}}],[\"等\",{\"1\":{\"32\":1}}],[\"等等\",{\"1\":{\"25\":1}}],[\"等待的线程中会有一个线程成功调用\",{\"1\":{\"66\":1}}],[\"等待的同时也可以执行其它的任务\",{\"1\":{\"42\":1}}],[\"等待计数为\",{\"1\":{\"60\":1}}],[\"等待其它线程执行\",{\"1\":{\"60\":1}}],[\"等待条件变量满足条件\",{\"1\":{\"50\":1}}],[\"等待结果\",{\"1\":{\"49\":1}}],[\"等待一个\",{\"1\":{\"49\":1}}],[\"等待数据中\",{\"1\":{\"46\":4}}],[\"等待\",{\"1\":{\"40\":1,\"43\":1,\"58\":3}}],[\"等待事件或条件\",{\"0\":{\"40\":1}}],[\"等待异步任务执行完毕\",{\"1\":{\"43\":1}}],[\"等待异步任务\",{\"1\":{\"39\":1}}],[\"等待线程执行\",{\"1\":{\"45\":4}}],[\"等待线程执行结束\",{\"1\":{\"18\":1}}],[\"等待线程对象\",{\"1\":{\"9\":1}}],[\"等待到指定的时间点\",{\"1\":{\"15\":1}}],[\"等待所有线程执行完毕\",{\"1\":{\"10\":1,\"44\":1}}],[\"恶性的条件竞争\",{\"1\":{\"25\":1}}],[\"才可作为一个整体执行\",{\"1\":{\"62\":1}}],[\"才会考虑\",{\"1\":{\"40\":1}}],[\"才会真正解锁互斥量\",{\"1\":{\"35\":1}}],[\"才会导致\",{\"1\":{\"25\":1}}],[\"才需要获取锁\",{\"1\":{\"33\":1}}],[\"才能传递引用\",{\"1\":{\"43\":1}}],[\"才能实际应用多线程编程\",{\"1\":{\"23\":1}}],[\"才能更好的使用它\",{\"1\":{\"17\":1}}],[\"才能调用\",{\"1\":{\"12\":1}}],[\"才能进行真正的并行\",{\"1\":{\"5\":1}}],[\"从网络获取的数据\",{\"1\":{\"46\":2}}],[\"从\",{\"1\":{\"45\":1}}],[\"从队列中弹出元素\",{\"1\":{\"41\":2}}],[\"从多个线程输出的单独字符可能交错\",{\"1\":{\"25\":1}}],[\"从而阻塞尝试\",{\"1\":{\"58\":1}}],[\"从而在其他线程中安全地更新\",{\"1\":{\"52\":1}}],[\"从而允许主线程捕获并处理它\",{\"1\":{\"45\":1}}],[\"从而使得\",{\"1\":{\"40\":1}}],[\"从而造成死锁\",{\"1\":{\"30\":1}}],[\"从而引发未定义的结果\",{\"1\":{\"25\":1}}],[\"从而避免线程对象析构产生问题\",{\"1\":{\"12\":1}}],[\"从而提升程序性能\",{\"1\":{\"10\":1}}],[\"❤️❤️\",{\"1\":{\"66\":1}}],[\"❤️\",{\"1\":{\"25\":1}}],[\"谁先谁后并不会有什么太大影响\",{\"1\":{\"25\":1}}],[\"保有一个\",{\"1\":{\"83\":2}}],[\"保有一个互斥量的引用\",{\"1\":{\"83\":1}}],[\"保有的数据成员\",{\"1\":{\"31\":1}}],[\"保护不常更新的数据结构\",{\"0\":{\"34\":1},\"1\":{\"38\":1}}],[\"保护共享数据并非必须使用互斥量\",{\"1\":{\"33\":1}}],[\"保护共享数据的初始化过程\",{\"0\":{\"33\":1},\"1\":{\"38\":1}}],[\"保护共享数据的其它方案\",{\"1\":{\"24\":1}}],[\"保护共享数据\",{\"0\":{\"29\":1},\"1\":{\"38\":1}}],[\"保证了\",{\"1\":{\"36\":1}}],[\"保证写线程的独占访问\",{\"1\":{\"34\":1}}],[\"保证线程安全的一次初始化\",{\"1\":{\"33\":1}}],[\"保证他们的执行\",{\"1\":{\"18\":1}}],[\"保证这里少一次移动构造的开销\",{\"1\":{\"16\":1}}],[\"注\",{\"1\":{\"23\":2,\"62\":3,\"71\":2}}],[\"注意事项\",{\"0\":{\"55\":1}}],[\"注意\",{\"1\":{\"14\":1,\"31\":1,\"80\":1}}],[\"↩︎\",{\"1\":{\"23\":3,\"38\":1,\"62\":3,\"71\":1}}],[\"至少使用与了解其设计原理是很简单的\",{\"1\":{\"85\":1}}],[\"至少允许\",{\"1\":{\"58\":1}}],[\"至少还需要学习到使用互斥量来保护共享数据\",{\"1\":{\"23\":1}}],[\"至于到底哪个函数哪个线程会先执行\",{\"1\":{\"27\":1}}],[\"至于到底哪个线程才会成功调用\",{\"1\":{\"26\":1}}],[\"至于\",{\"1\":{\"21\":1}}],[\"至于这个函数产生的异常\",{\"1\":{\"12\":1}}],[\"关联\",{\"1\":{\"44\":4}}],[\"关联的执行线程的\",{\"1\":{\"80\":1}}],[\"关联的\",{\"1\":{\"21\":2}}],[\"关联的线程执行完毕\",{\"1\":{\"9\":1}}],[\"关键字的使用以及它的作用\",{\"1\":{\"37\":1}}],[\"关键字的使用\",{\"1\":{\"37\":1}}],[\"关键在于理解其设计与概念\",{\"1\":{\"22\":1}}],[\"已被处理\",{\"1\":{\"58\":1}}],[\"已存储值\",{\"1\":{\"45\":1}}],[\"已请求停止\",{\"1\":{\"21\":2}}],[\"已经存储值或者异常\",{\"1\":{\"45\":1}}],[\"已经没有关联线程资源\",{\"1\":{\"12\":1}}],[\"已经结束\",{\"1\":{\"12\":1}}],[\"方法时\",{\"1\":{\"21\":1}}],[\"源码中也有这种用法\",{\"1\":{\"84\":1}}],[\"源码\",{\"1\":{\"24\":1}}],[\"源码一眼便可发现\",{\"1\":{\"21\":1}}],[\"源码解析详细聊过其不同标准库对其保有的成员不同\",{\"1\":{\"20\":1}}],[\"源码解析\",{\"0\":{\"78\":1,\"86\":1},\"1\":{\"1\":2,\"14\":1,\"17\":1}}],[\"上面的代码创建了一个异步任务\",{\"1\":{\"52\":1}}],[\"上面这段代码并未出现这三个函数的任何一个调用\",{\"1\":{\"21\":1}}],[\"上工作的\",{\"1\":{\"40\":1}}],[\"上锁互斥量\",{\"1\":{\"40\":2}}],[\"上锁时若抛出异常\",{\"1\":{\"30\":1}}],[\"上锁了\",{\"1\":{\"30\":1}}],[\"上锁\",{\"1\":{\"30\":2}}],[\"上一节的使用互斥量也已经为各位展示了一些\",{\"1\":{\"29\":1}}],[\"上亿的话差不多\",{\"1\":{\"10\":1}}],[\"启用不稳定库功能和实验库功能\",{\"1\":{\"21\":1}}],[\"启动一个线程进行计算\",{\"1\":{\"45\":1}}],[\"启动一个异步任务\",{\"1\":{\"43\":1}}],[\"启动线程执行\",{\"1\":{\"44\":1}}],[\"启动线程\",{\"1\":{\"12\":1,\"14\":2,\"16\":2}}],[\"启动线程后\",{\"1\":{\"12\":1}}],[\"启动新线程\",{\"0\":{\"12\":1}}],[\"截止目前\",{\"1\":{\"21\":1}}],[\"首先我们要明白\",{\"1\":{\"32\":1}}],[\"首先\",{\"1\":{\"31\":1}}],[\"首先管理类\",{\"1\":{\"27\":1}}],[\"首先顾名思义\",{\"1\":{\"27\":1}}],[\"首先要明确\",{\"1\":{\"21\":1}}],[\"首页\",{\"1\":{\"1\":1}}],[\"符合零开销原则\",{\"1\":{\"20\":1}}],[\"先关联任务\",{\"1\":{\"44\":1}}],[\"先上锁了互斥量\",{\"1\":{\"31\":1}}],[\"先上锁\",{\"1\":{\"30\":2}}],[\"先锁定\",{\"1\":{\"30\":2}}],[\"先看\",{\"1\":{\"27\":1}}],[\"先执行\",{\"1\":{\"25\":1}}],[\"先执行完\",{\"1\":{\"14\":1}}],[\"先前只是为了展示一下显式写明的情况\",{\"1\":{\"65\":1}}],[\"先前提到的静态成员函数\",{\"1\":{\"50\":1}}],[\"先前\",{\"1\":{\"20\":1}}],[\"字节\",{\"1\":{\"20\":1,\"31\":1}}],[\"字符串字面量具有静态存储期\",{\"1\":{\"14\":1}}],[\"字符串字面量的类型是\",{\"1\":{\"14\":1}}],[\"均为\",{\"1\":{\"67\":1}}],[\"均是如此\",{\"1\":{\"20\":1}}],[\"均会在致谢列表中铭记您的贡献\",{\"1\":{\"0\":1}}],[\"付出额外的开销\",{\"1\":{\"20\":1}}],[\"零开销原则应当很好理解\",{\"1\":{\"22\":1}}],[\"零开销原则\",{\"0\":{\"20\":1},\"1\":{\"20\":1}}],[\"停止状态\",{\"1\":{\"23\":1}}],[\"停止\",{\"1\":{\"19\":1}}],[\"管理类\",{\"1\":{\"27\":3,\"83\":1}}],[\"管理的一种标志\",{\"1\":{\"23\":1}}],[\"管理\",{\"1\":{\"19\":1}}],[\"管理线程对象也就是管理线程\",{\"1\":{\"18\":1}}],[\"相对于\",{\"1\":{\"85\":1}}],[\"相对于只在\",{\"1\":{\"40\":1}}],[\"相反\",{\"1\":{\"52\":1}}],[\"相比之下\",{\"1\":{\"48\":1}}],[\"相比于之前\",{\"1\":{\"44\":1}}],[\"相比于\",{\"1\":{\"19\":1}}],[\"相信你也感受到了\",{\"1\":{\"81\":1}}],[\"相信你注意到了\",{\"1\":{\"18\":1}}],[\"相信这个例子就能很清楚的展示\",{\"1\":{\"60\":1}}],[\"相信这个时候就已经想到了\",{\"1\":{\"34\":1}}],[\"jthread>\",{\"1\":{\"21\":1,\"58\":1}}],[\"jthread\",{\"1\":{\"19\":1,\"20\":3,\"21\":12,\"58\":1,\"60\":1}}],[\"joining\",{\"1\":{\"18\":11}}],[\"joinable\",{\"1\":{\"9\":2,\"12\":3,\"13\":1,\"16\":4,\"18\":4,\"21\":1}}],[\"join\",{\"1\":{\"9\":3,\"10\":2,\"12\":26,\"13\":4,\"14\":7,\"15\":1,\"16\":11,\"18\":8,\"19\":1,\"21\":4,\"25\":4,\"26\":2,\"27\":4,\"28\":2,\"35\":2,\"37\":2,\"43\":1,\"44\":3,\"45\":3,\"46\":4}}],[\"没办法直接被那样传递使用\",{\"1\":{\"44\":1}}],[\"没提供直接从线程获取返回值的机制\",{\"1\":{\"43\":1}}],[\"没事找事\",{\"1\":{\"33\":1}}],[\"没什么规律\",{\"1\":{\"18\":1}}],[\"没有要求\",{\"1\":{\"84\":1}}],[\"没有数据成员\",{\"1\":{\"83\":1}}],[\"没有好处不会闲的没事给你指令重排\",{\"1\":{\"71\":1}}],[\"没有卡界面\",{\"1\":{\"54\":1}}],[\"没有被阻塞\",{\"1\":{\"52\":1}}],[\"没有被移动或绑定到引用\",{\"1\":{\"43\":1}}],[\"没有这么精确\",{\"1\":{\"50\":1}}],[\"没有所有权\",{\"1\":{\"43\":1}}],[\"没有所有权自然构造函数就不会上锁\",{\"1\":{\"31\":1}}],[\"没有线程工作\",{\"1\":{\"30\":1}}],[\"没有线程资源\",{\"1\":{\"16\":1}}],[\"没有关联活跃线程\",{\"1\":{\"16\":1}}],[\"没有问题\",{\"1\":{\"12\":1,\"65\":1}}],[\"没有\",{\"1\":{\"12\":1,\"14\":1}}],[\"没有直接管理线程的机制\",{\"1\":{\"11\":1}}],[\"则进入这个分支\",{\"1\":{\"80\":1}}],[\"则表示线程已成功启动\",{\"1\":{\"80\":1}}],[\"则需要注意其复杂性和难以观察的特性\",{\"1\":{\"71\":1}}],[\"则编译错误\",{\"1\":{\"65\":1}}],[\"则将出现数据竞争\",{\"1\":{\"62\":1}}],[\"则返回\",{\"1\":{\"49\":1}}],[\"则\",{\"1\":{\"45\":1}}],[\"则可以通过编译\",{\"1\":{\"43\":1}}],[\"则是安全的\",{\"1\":{\"42\":1,\"46\":1}}],[\"则解锁互斥体\",{\"1\":{\"35\":1}}],[\"则在重抛前对任何已锁的对象调用\",{\"1\":{\"30\":1}}],[\"则要上锁\",{\"1\":{\"30\":1}}],[\"则毫无意义\",{\"1\":{\"30\":1}}],[\"则不会阻塞当前线程\",{\"1\":{\"28\":1}}],[\"则不需要最后的循环\",{\"1\":{\"18\":1}}],[\"则构造函数不会上锁\",{\"1\":{\"27\":1}}],[\"则会产生一个编译错误\",{\"1\":{\"14\":1}}],[\"退出循环\",{\"1\":{\"66\":1}}],[\"退出\",{\"1\":{\"18\":1}}],[\"~scoped\",{\"1\":{\"83\":2,\"84\":1}}],[\"~trivial\",{\"1\":{\"65\":1}}],[\"~thread\",{\"1\":{\"12\":1,\"13\":1}}],[\"~async\",{\"1\":{\"54\":1}}],[\"~unique\",{\"1\":{\"31\":1}}],[\"~lock\",{\"1\":{\"27\":1}}],[\"~jthread\",{\"1\":{\"21\":1}}],[\"~joining\",{\"1\":{\"18\":1}}],[\"实例化\",{\"1\":{\"65\":1,\"80\":1}}],[\"实时系统或者其它需要高并发性能的场景中\",{\"1\":{\"65\":1}}],[\"实践建议\",{\"0\":{\"57\":1}}],[\"实现中可能也是使用到了\",{\"1\":{\"78\":1}}],[\"实现的\",{\"1\":{\"78\":1,\"82\":1}}],[\"实现自旋锁\",{\"1\":{\"66\":1}}],[\"实现异步任务的示例\",{\"1\":{\"51\":1}}],[\"实现选择的执行方式\",{\"1\":{\"43\":1}}],[\"实现\",{\"0\":{\"18\":1}}],[\"实际存储数据的队列\",{\"1\":{\"41\":1}}],[\"实际上就是使用条件变量了\",{\"1\":{\"40\":1}}],[\"实际上并没有按引用传递\",{\"1\":{\"14\":1}}],[\"实际需要的是一个\",{\"1\":{\"14\":1}}],[\"后续还会详细展开内存模型的问题\",{\"1\":{\"63\":1}}],[\"后缀\",{\"1\":{\"40\":1}}],[\"后者有更高的性能优势\",{\"1\":{\"34\":1}}],[\"后\",{\"1\":{\"17\":1}}],[\"后正常析构\",{\"1\":{\"16\":2}}],[\"形参包展开用\",{\"1\":{\"84\":1}}],[\"形参包元素数量为一的偏特化的唯一区别\",{\"1\":{\"84\":1}}],[\"形参包元素数量为一的偏特化\",{\"1\":{\"84\":1}}],[\"形参\",{\"1\":{\"16\":2}}],[\"强制的复制消除\",{\"1\":{\"16\":1}}],[\"具有\",{\"1\":{\"34\":1}}],[\"具有线程资源的所有权\",{\"1\":{\"16\":1}}],[\"具体类型根据类型形参包决定\",{\"1\":{\"83\":1}}],[\"具体的读者会在学习中感受到的\",{\"1\":{\"74\":1}}],[\"具体可参见\",{\"1\":{\"66\":1}}],[\"具体来说\",{\"1\":{\"25\":1}}],[\"具体什么时候执行\",{\"1\":{\"14\":1}}],[\"具体如何\",{\"1\":{\"13\":1}}],[\"选择到了移动构造转移线程资源的所有权\",{\"1\":{\"16\":1}}],[\"选择到了移动构造\",{\"1\":{\"16\":1}}],[\"堵塞让其线程执行完毕\",{\"1\":{\"16\":1}}],[\"堵塞什么\",{\"1\":{\"12\":1}}],[\"转移线程的所有权\",{\"1\":{\"80\":1}}],[\"转移线程资源的所有权到\",{\"1\":{\"16\":1}}],[\"转移共享状态\",{\"1\":{\"46\":1}}],[\"转移\",{\"1\":{\"32\":1,\"46\":1}}],[\"转移所有权\",{\"0\":{\"16\":1}}],[\"转换为了一个右值表达式\",{\"1\":{\"16\":1}}],[\"转换为\",{\"1\":{\"14\":1}}],[\"转换为std\",{\"1\":{\"14\":1}}],[\"输出语句\",{\"1\":{\"26\":1}}],[\"输出等待结束后的时间\",{\"1\":{\"15\":1}}],[\"输出等待的时间点\",{\"1\":{\"15\":1}}],[\"输出当前时间\",{\"1\":{\"15\":1}}],[\"输出的值会为\",{\"1\":{\"10\":1}}],[\"5f\",{\"1\":{\"65\":3}}],[\"5px\",{\"1\":{\"54\":1}}],[\"500ms\",{\"1\":{\"50\":2}}],[\"500\",{\"1\":{\"50\":3}}],[\"50\",{\"1\":{\"44\":1,\"54\":2,\"65\":1}}],[\"5s\",{\"1\":{\"15\":1}}],[\"5\",{\"1\":{\"15\":1,\"21\":1,\"40\":3,\"41\":2,\"45\":1,\"48\":1,\"58\":1}}],[\"减少等待时间\",{\"1\":{\"71\":1}}],[\"减少对原子操作的调用次数\",{\"1\":{\"65\":1}}],[\"减少原子操作的频率\",{\"1\":{\"65\":1}}],[\"减少计数\",{\"1\":{\"58\":1,\"60\":1}}],[\"减少浪费的执行时间\",{\"1\":{\"40\":1}}],[\"减少错误发生\",{\"1\":{\"30\":1}}],[\"减少\",{\"1\":{\"15\":1}}],[\"秒一次\",{\"1\":{\"48\":1}}],[\"秒就是\",{\"1\":{\"15\":1}}],[\"秒\",{\"1\":{\"15\":1,\"21\":1,\"40\":1,\"48\":2}}],[\"延时\",{\"1\":{\"15\":1}}],[\"使得\",{\"1\":{\"71\":1}}],[\"使得能异步调用它\",{\"1\":{\"44\":1}}],[\"使受保护数据传递给外部\",{\"1\":{\"29\":1}}],[\"使当前线程执行停止到指定的时间点\",{\"1\":{\"15\":1}}],[\"使当前线程停止执行指定时间\",{\"1\":{\"15\":1}}],[\"使用了折叠表达式展开形参包\",{\"1\":{\"84\":1}}],[\"使用了\",{\"1\":{\"84\":1}}],[\"使用标准库的内容很多时候不加\",{\"1\":{\"80\":1}}],[\"使用默认的\",{\"1\":{\"66\":1}}],[\"使用更高效的同步机制\",{\"1\":{\"65\":1}}],[\"使用不同的数据结构\",{\"1\":{\"65\":1}}],[\"使用读写锁\",{\"1\":{\"38\":1}}],[\"使用它可以将之前使用\",{\"1\":{\"31\":1}}],[\"使用固定顺序获取锁\",{\"1\":{\"30\":1}}],[\"使用互斥量创建了一个独占锁\",{\"1\":{\"40\":1}}],[\"使用互斥量\",{\"0\":{\"26\":1}}],[\"使用互斥量保护共享数据\",{\"1\":{\"24\":1}}],[\"使用互斥量可以解决这些问题\",{\"1\":{\"18\":1}}],[\"使用我们这节实现的\",{\"1\":{\"18\":1}}],[\"使用容器管理线程对象\",{\"1\":{\"18\":1}}],[\"使用\",{\"0\":{\"42\":1,\"45\":1},\"1\":{\"10\":1,\"12\":2,\"15\":3,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":2,\"31\":2,\"33\":3,\"37\":4,\"38\":1,\"40\":1,\"43\":1,\"48\":1,\"55\":1,\"56\":1,\"65\":3,\"66\":1,\"67\":1,\"74\":1,\"80\":2}}],[\"使用硬件提高数据处理速度时\",{\"1\":{\"6\":1}}],[\"使用线程也就是使用\",{\"1\":{\"8\":1}}],[\"使用线程\",{\"0\":{\"8\":1},\"1\":{\"1\":1,\"23\":1}}],[\"建议学习现代c++模板教程\",{\"1\":{\"82\":1}}],[\"建议下载并运行此项目\",{\"1\":{\"57\":1}}],[\"建议阅读std\",{\"1\":{\"30\":1}}],[\"建议你多思考\",{\"1\":{\"23\":1}}],[\"建议实现重新调度各执行线程\",{\"1\":{\"15\":1}}],[\"建议使用时间字面量\",{\"1\":{\"15\":1}}],[\"建议使用\",{\"1\":{\"12\":1,\"21\":1}}],[\"显式转换为\",{\"1\":{\"84\":1}}],[\"显式转换可以由\",{\"1\":{\"49\":1}}],[\"显式将\",{\"1\":{\"14\":1}}],[\"显而易见\",{\"1\":{\"40\":1}}],[\"显然我们的类型满足要求\",{\"1\":{\"65\":1}}],[\"显然逻辑不对\",{\"1\":{\"12\":1}}],[\"显然\",{\"1\":{\"12\":1,\"64\":2}}],[\"取决于操作系统的调度\",{\"1\":{\"14\":1}}],[\"下一节我们来看看它是如何工作的\",{\"1\":{\"67\":1}}],[\"下一章\",{\"1\":{\"38\":1}}],[\"下节\",{\"1\":{\"66\":1}}],[\"下可能为\",{\"1\":{\"14\":1}}],[\"下面我的\",{\"1\":{\"12\":1}}],[\"确保多线程环境下的正确性\",{\"1\":{\"71\":1}}],[\"确保\",{\"1\":{\"52\":1}}],[\"确保在多线程环境下的数据同步\",{\"1\":{\"40\":1}}],[\"确保全局对象的线程安全访问通常需要额外的同步措施\",{\"1\":{\"36\":1}}],[\"确保每个对象的互斥量都锁住自己要保护的区域\",{\"1\":{\"30\":1}}],[\"确保实参在按值传递时会退化\",{\"1\":{\"14\":1}}],[\"确保线程执行完成\",{\"1\":{\"13\":1}}],[\"确保线程正常执行完成\",{\"1\":{\"12\":1}}],[\"动态\",{\"1\":{\"14\":1}}],[\"被向后移植到了\",{\"1\":{\"78\":1}}],[\"被引入\",{\"1\":{\"72\":1}}],[\"被清空\",{\"1\":{\"46\":1}}],[\"被移动的\",{\"1\":{\"43\":1}}],[\"被设置为\",{\"1\":{\"40\":1}}],[\"被唤醒\",{\"1\":{\"40\":1}}],[\"被\",{\"1\":{\"26\":1}}],[\"被线程对象保存\",{\"1\":{\"14\":1}}],[\"被销毁\",{\"1\":{\"12\":1}}],[\"或许\",{\"1\":{\"84\":1}}],[\"或\",{\"1\":{\"20\":1,\"21\":1,\"25\":2,\"30\":1,\"32\":1,\"37\":1,\"41\":2,\"43\":2,\"49\":1,\"62\":1,\"65\":1,\"67\":1}}],[\"或者直接在捐赠初始记录名单中进行评论\",{\"1\":{\"77\":1}}],[\"或者直接被称作\",{\"1\":{\"26\":1}}],[\"或者联系我\",{\"1\":{\"77\":1}}],[\"或者隐式转换\",{\"1\":{\"67\":1}}],[\"或者延迟执行可以提高性能或节省资源\",{\"1\":{\"43\":1}}],[\"或者任务已经执行完\",{\"1\":{\"43\":1}}],[\"或者依赖各家编译器的扩展\",{\"1\":{\"37\":1}}],[\"或者外部的\",{\"1\":{\"36\":1}}],[\"或者在同一信号处理函数中执行\",{\"1\":{\"25\":1}}],[\"或者\",{\"1\":{\"20\":1,\"75\":1}}],[\"或者以任何形式转换到a\",{\"1\":{\"14\":1}}],[\"或某个函数类型\",{\"1\":{\"12\":1}}],[\"x86\",{\"1\":{\"71\":1,\"74\":1}}],[\"xxx\",{\"1\":{\"65\":1}}],[\"xx\",{\"1\":{\"41\":1}}],[\"x64\",{\"1\":{\"31\":1}}],[\"x\",{\"1\":{\"14\":15,\"30\":11,\"31\":2,\"36\":4,\"43\":5,\"48\":2,\"65\":11,\"67\":2}}],[\"解引用指针\",{\"1\":{\"80\":1}}],[\"解决\",{\"1\":{\"42\":1}}],[\"解决方案\",{\"1\":{\"14\":1}}],[\"解决方法很简单\",{\"1\":{\"12\":1,\"40\":1}}],[\"解释这段代码最简单的方式就是直接展示标准库的源码\",{\"1\":{\"31\":1}}],[\"解释清楚\",{\"1\":{\"14\":1}}],[\"解锁并释放所有权\",{\"1\":{\"31\":1}}],[\"解锁互斥量\",{\"1\":{\"31\":1,\"35\":1,\"40\":2}}],[\"解锁\",{\"1\":{\"27\":1,\"28\":1,\"30\":3}}],[\"记住\",{\"1\":{\"14\":1}}],[\"of\",{\"1\":{\"80\":1}}],[\"ownership\",{\"1\":{\"80\":1}}],[\"owns\",{\"1\":{\"31\":11,\"32\":3}}],[\"openmp\",{\"1\":{\"59\":1}}],[\"operation\",{\"1\":{\"31\":1}}],[\"operator<<\",{\"1\":{\"25\":1}}],[\"operator=\",{\"1\":{\"13\":1,\"18\":1,\"27\":1,\"65\":2,\"67\":1,\"83\":3}}],[\"operator\",{\"1\":{\"12\":5,\"36\":9,\"43\":1,\"44\":3,\"65\":1}}],[\"ok\",{\"1\":{\"43\":1}}],[\"one\",{\"1\":{\"40\":3,\"41\":1,\"49\":6}}],[\"once\",{\"1\":{\"33\":13,\"38\":1}}],[\"only\",{\"1\":{\"14\":8,\"43\":8,\"75\":7}}],[\"occur\",{\"1\":{\"31\":1}}],[\"order\",{\"1\":{\"25\":1,\"65\":13,\"66\":6,\"67\":6,\"71\":1,\"74\":1}}],[\"other\",{\"1\":{\"18\":6,\"32\":5,\"65\":2,\"80\":6}}],[\"object\",{\"1\":{\"30\":8,\"31\":2,\"54\":1,\"80\":1}}],[\"obj\",{\"1\":{\"14\":2,\"84\":4}}],[\"左值引用没办法引用右值表达式\",{\"1\":{\"14\":1,\"43\":1}}],[\"内存次序错误的使用难以察觉\",{\"1\":{\"71\":1}}],[\"内存次序是非常底层知识\",{\"1\":{\"71\":1}}],[\"内存次序\",{\"0\":{\"70\":1}}],[\"内存序\",{\"1\":{\"66\":2}}],[\"内存模型确保程序的行为在并发环境下是可预测的\",{\"1\":{\"63\":1}}],[\"内存模型定义了多线程程序中\",{\"1\":{\"63\":1}}],[\"内存模型与原子操作\",{\"0\":{\"63\":1},\"1\":{\"1\":1,\"62\":1}}],[\"内存分配\",{\"1\":{\"36\":1}}],[\"内存对齐\",{\"1\":{\"31\":1}}],[\"内部会将保有的参数副本转换为右值表达式进行传递\",{\"1\":{\"14\":1,\"17\":1,\"43\":1}}],[\"呢\",{\"1\":{\"14\":1}}],[\"顾名思义\",{\"1\":{\"14\":1}}],[\"引用的就是\",{\"1\":{\"14\":2}}],[\"引用\",{\"1\":{\"14\":2,\"67\":1}}],[\"引入头文件时需要在尖括号或引号前后加空格\",{\"1\":{\"75\":1}}],[\"引入了协程语法\",{\"1\":{\"72\":1}}],[\"引入了原子类型\",{\"1\":{\"64\":1}}],[\"引入了信号量\",{\"1\":{\"58\":1}}],[\"引入了thread\",{\"1\":{\"37\":1}}],[\"引入\",{\"1\":{\"10\":1,\"20\":1,\"43\":1}}],[\"引入的类模板\",{\"1\":{\"82\":1}}],[\"引入的一种通用互斥包装器\",{\"1\":{\"31\":1}}],[\"引入的求和算法\",{\"1\":{\"10\":1}}],[\"引入的\",{\"1\":{\"10\":1,\"12\":1,\"19\":1,\"65\":1,\"78\":1}}],[\"引入线程支持头文件\",{\"1\":{\"9\":1}}],[\"打印了元组所有的元素\",{\"1\":{\"84\":1}}],[\"打印函数\",{\"1\":{\"27\":1}}],[\"打印的时候\",{\"1\":{\"27\":1}}],[\"打印的是乱序的\",{\"1\":{\"18\":1}}],[\"打印的地址截然不同\",{\"1\":{\"14\":1}}],[\"打印\",{\"1\":{\"16\":2,\"21\":1,\"27\":1}}],[\"打印地址完全相同\",{\"1\":{\"14\":1}}],[\"打印日志\",{\"1\":{\"13\":1}}],[\"需要注意\",{\"1\":{\"81\":1}}],[\"需要注意的是\",{\"1\":{\"14\":1}}],[\"需要传入一个索引\",{\"1\":{\"80\":1}}],[\"需要传递一个\",{\"1\":{\"49\":1}}],[\"需要详细讲解\",{\"1\":{\"80\":1}}],[\"需要开发者使用同步原语来显式地控制内存操作的顺序和可见性\",{\"1\":{\"71\":1}}],[\"需要在循环中重试\",{\"1\":{\"67\":1}}],[\"需要使用异步任务来减轻主线程的压力\",{\"1\":{\"51\":1}}],[\"需要限定线程等待的时间\",{\"1\":{\"47\":1}}],[\"需要确保没有其他线程正在执行\",{\"1\":{\"41\":1}}],[\"需要设置\",{\"1\":{\"37\":1}}],[\"需要进行额外的同步措施进行保护\",{\"1\":{\"36\":1}}],[\"需要进行保护\",{\"1\":{\"27\":1}}],[\"需要遥控器和玩具车才能玩\",{\"1\":{\"30\":1}}],[\"需要更高的标准会进行强调\",{\"1\":{\"0\":1}}],[\"向可调用对象或函数传递参数很简单\",{\"1\":{\"14\":1}}],[\"传递给线程的参数为\",{\"1\":{\"80\":1}}],[\"传递给\",{\"1\":{\"80\":1}}],[\"传递给这个函数\",{\"1\":{\"14\":1}}],[\"传递\",{\"1\":{\"43\":1}}],[\"传递了一个恶意的函数\",{\"1\":{\"29\":1}}],[\"传递的\",{\"1\":{\"21\":1}}],[\"传递参数一节中的\",{\"1\":{\"17\":1}}],[\"传递参数\",{\"0\":{\"14\":1},\"1\":{\"17\":1,\"60\":1}}],[\"传入的可调用对象\",{\"1\":{\"80\":1}}],[\"传入了一个谓词\",{\"1\":{\"40\":1}}],[\"传入可调用对象以及参数\",{\"1\":{\"16\":1}}],[\"传入成员函数指针\",{\"1\":{\"14\":1}}],[\"传入\",{\"1\":{\"12\":1,\"80\":1}}],[\"严格来说其实这里倒也不算\",{\"1\":{\"13\":1}}],[\"单线程能不能指令重排\",{\"1\":{\"71\":1}}],[\"单次使用的线程屏障\",{\"1\":{\"59\":1,\"60\":1}}],[\"单纯的做好\",{\"1\":{\"13\":1}}],[\"单核机器的任务切换\",{\"1\":{\"5\":1}}],[\"看似有一些没有使用\",{\"1\":{\"49\":1}}],[\"看到无序的输出\",{\"1\":{\"36\":1}}],[\"看到它一定打印\",{\"1\":{\"13\":1}}],[\"看起来一点问题也没有\",{\"1\":{\"29\":1}}],[\"看一遍描述就可以了\",{\"1\":{\"26\":1}}],[\"看情况分析\",{\"1\":{\"13\":1}}],[\"难以掌控\",{\"1\":{\"13\":1}}],[\"前三个构造函数都没啥要特别聊的\",{\"1\":{\"80\":1}}],[\"前面了\",{\"1\":{\"71\":2}}],[\"前面的内容也都提到了\",{\"1\":{\"36\":1}}],[\"前者是需要指定等待一段时间\",{\"1\":{\"47\":1}}],[\"前者支持更多的操作方式\",{\"1\":{\"34\":1}}],[\"前提是你捕获了这个异常\",{\"1\":{\"13\":1}}],[\"前言\",{\"0\":{\"3\":1,\"71\":1}}],[\"抛出一个\",{\"1\":{\"80\":1}}],[\"抛出了一个异常\",{\"1\":{\"13\":1}}],[\"抛出异常并设置\",{\"1\":{\"45\":4}}],[\"抛出异常\",{\"1\":{\"12\":2,\"43\":1}}],[\"抛出异常的代码\",{\"1\":{\"12\":1}}],[\"析构解锁\",{\"1\":{\"83\":1,\"84\":1}}],[\"析构同理\",{\"1\":{\"36\":1}}],[\"析构函数就要稍微聊一下了\",{\"1\":{\"84\":1}}],[\"析构函数\",{\"1\":{\"36\":1}}],[\"析构函数不会再\",{\"1\":{\"31\":1}}],[\"析构函数中解锁\",{\"1\":{\"27\":1}}],[\"析构函数释放资源\",{\"1\":{\"13\":1}}],[\"析构\",{\"1\":{\"13\":2}}],[\"gthread\",{\"1\":{\"81\":3}}],[\"gthreads\",{\"1\":{\"81\":2}}],[\"glibcxx\",{\"1\":{\"81\":2}}],[\"global\",{\"1\":{\"37\":5}}],[\"gen\",{\"1\":{\"58\":2}}],[\"get<index>\",{\"1\":{\"84\":1}}],[\"get<>\",{\"1\":{\"80\":1}}],[\"get<\",{\"1\":{\"80\":2}}],[\"getspecific\",{\"1\":{\"37\":1}}],[\"get\",{\"1\":{\"15\":5,\"16\":1,\"18\":4,\"21\":4,\"26\":2,\"27\":1,\"32\":1,\"33\":2,\"34\":1,\"35\":2,\"43\":11,\"44\":11,\"45\":8,\"46\":6,\"49\":2,\"56\":1,\"80\":10,\"84\":1}}],[\"grey\",{\"1\":{\"54\":1}}],[\"gui\",{\"1\":{\"52\":1}}],[\"guard<spinlock\",{\"1\":{\"66\":1}}],[\"guard<std\",{\"1\":{\"27\":5,\"29\":1,\"30\":8,\"33\":1,\"34\":1,\"35\":1,\"40\":1,\"41\":2,\"64\":1,\"84\":1}}],[\"guard的区别在于\",{\"1\":{\"27\":1}}],[\"guard\",{\"1\":{\"13\":12,\"27\":16,\"29\":2,\"30\":2,\"31\":4,\"34\":1,\"35\":1,\"38\":1,\"83\":2,\"84\":1}}],[\"g\",{\"1\":{\"13\":2,\"43\":1}}],[\"gcc14\",{\"1\":{\"72\":1,\"74\":1}}],[\"gcc\",{\"1\":{\"0\":1,\"37\":6,\"74\":2,\"81\":1}}],[\"资源获取即初始化\",{\"1\":{\"13\":1}}],[\"rule\",{\"1\":{\"71\":1}}],[\"runtime\",{\"1\":{\"33\":1,\"45\":2}}],[\"run\",{\"1\":{\"14\":7}}],[\"rd\",{\"1\":{\"58\":2}}],[\"rawvals\",{\"1\":{\"80\":2}}],[\"random\",{\"1\":{\"58\":1}}],[\"radius\",{\"1\":{\"54\":1}}],[\"ratio\",{\"1\":{\"48\":1,\"49\":6}}],[\"ratio<3600>>\",{\"1\":{\"49\":1}}],[\"ratio<60>>\",{\"1\":{\"48\":1,\"49\":1}}],[\"ratio<60>\",{\"1\":{\"48\":1}}],[\"ratio<5\",{\"1\":{\"48\":1}}],[\"ratio<12>>>\",{\"1\":{\"49\":1}}],[\"ratio<1>\",{\"1\":{\"48\":1}}],[\"ratio<1>>\",{\"1\":{\"48\":1}}],[\"ratio<1\",{\"1\":{\"48\":2,\"49\":1,\"50\":1}}],[\"raii\",{\"0\":{\"13\":1},\"1\":{\"13\":3,\"19\":1,\"27\":1,\"30\":1}}],[\"rhs\",{\"1\":{\"30\":15,\"31\":4}}],[\"rvo\",{\"1\":{\"16\":1}}],[\"rt\",{\"1\":{\"16\":6}}],[\"r\",{\"1\":{\"14\":6,\"44\":1,\"66\":2}}],[\"reinterpret\",{\"1\":{\"80\":2}}],[\"remove\",{\"1\":{\"80\":1,\"84\":1}}],[\"remainder\",{\"1\":{\"10\":5,\"44\":2}}],[\"re\",{\"1\":{\"66\":1}}],[\"rel\",{\"1\":{\"65\":1,\"67\":1}}],[\"relaxed\",{\"1\":{\"65\":3}}],[\"release\",{\"1\":{\"58\":5,\"65\":2,\"66\":3,\"67\":2,\"80\":2}}],[\"read\",{\"1\":{\"65\":1}}],[\"ready\",{\"1\":{\"49\":2}}],[\"realloc\",{\"1\":{\"36\":1}}],[\"repeat\",{\"1\":{\"66\":1}}],[\"rep\",{\"1\":{\"48\":1}}],[\"requires\",{\"1\":{\"44\":1}}],[\"request\",{\"1\":{\"21\":5,\"58\":5}}],[\"requested\",{\"1\":{\"21\":2}}],[\"recursive\",{\"1\":{\"35\":12,\"38\":1}}],[\"reference\",{\"1\":{\"14\":5,\"84\":1}}],[\"ref\",{\"1\":{\"14\":8,\"17\":1,\"27\":2,\"43\":4,\"67\":2}}],[\"result\",{\"1\":{\"45\":2,\"50\":2}}],[\"results\",{\"1\":{\"10\":4}}],[\"res\",{\"1\":{\"41\":1}}],[\"reset\",{\"1\":{\"33\":3}}],[\"resource\",{\"1\":{\"13\":1,\"31\":1,\"33\":4,\"80\":2}}],[\"reduce\",{\"1\":{\"10\":1}}],[\"return\",{\"1\":{\"10\":2,\"12\":1,\"16\":2,\"18\":5,\"30\":3,\"31\":1,\"32\":2,\"33\":1,\"34\":1,\"36\":1,\"40\":2,\"41\":4,\"43\":3,\"44\":7,\"46\":2,\"49\":1,\"50\":2,\"72\":1,\"80\":2,\"84\":2}}],[\"你阅读标准库源码\",{\"1\":{\"81\":1,\"82\":1,\"85\":1}}],[\"你只需要知道\",{\"1\":{\"80\":1}}],[\"你们可能还有疑问\",{\"1\":{\"71\":1}}],[\"你知道自己在做什么的可能性基本上为零\",{\"1\":{\"66\":1}}],[\"你始终在等待一件事情\",{\"1\":{\"42\":1}}],[\"你可能会想着再写一行\",{\"1\":{\"45\":1}}],[\"你可能会做一些别的事情打发时间\",{\"1\":{\"42\":1}}],[\"你可能对这段代码还有一些疑问\",{\"1\":{\"45\":1}}],[\"你可能还无法在实际环境利用多线程提升程序效率\",{\"1\":{\"23\":1}}],[\"你有一个数据结构存储了用户的设置信息\",{\"1\":{\"34\":1}}],[\"你不需要为你没有用到的\",{\"1\":{\"20\":1}}],[\"你是否感到奇怪\",{\"1\":{\"16\":1}}],[\"你是否觉得这样也可以\",{\"1\":{\"12\":1}}],[\"你简单认为reference\",{\"1\":{\"14\":1}}],[\"你要注意我们的注释\",{\"1\":{\"12\":1}}],[\"你在一个函数中构造了一个\",{\"1\":{\"12\":1}}],[\"块中最后一行写一个\",{\"1\":{\"12\":1}}],[\"由它调用\",{\"1\":{\"16\":1}}],[\"由调用方进行处理\",{\"1\":{\"12\":1}}],[\"由于无法增加计数\",{\"1\":{\"60\":1}}],[\"由于求和不涉及数据竞争之类的问题\",{\"1\":{\"10\":1}}],[\"由于\",{\"1\":{\"10\":2,\"25\":1}}],[\"以\",{\"1\":{\"82\":1}}],[\"以提高执行效率\",{\"1\":{\"71\":1}}],[\"以保证计数修改的原子性\",{\"1\":{\"62\":1}}],[\"以使用并发支持库中的\",{\"1\":{\"62\":1}}],[\"以至于我们可以在这里来再说一条概念\",{\"1\":{\"58\":1}}],[\"以加深对异步任务处理的理解\",{\"1\":{\"57\":1}}],[\"以上的示例更多的是泛指\",{\"1\":{\"71\":1}}],[\"以上示例已经足够\",{\"1\":{\"41\":1}}],[\"以上代码使用的就是第二个版本\",{\"1\":{\"40\":1}}],[\"以上代码是线程安全的\",{\"1\":{\"36\":1}}],[\"以上代码\",{\"1\":{\"33\":1}}],[\"以上代码可能导致一些问题\",{\"1\":{\"14\":1}}],[\"以上代码void\",{\"1\":{\"14\":1}}],[\"以确保程序的可观察副作用不受影响\",{\"1\":{\"71\":1}}],[\"以确保数据的正确性\",{\"1\":{\"67\":1}}],[\"以确保数据的一致性和正确性\",{\"1\":{\"39\":1}}],[\"以确保在特定平台上原子操作的性能\",{\"1\":{\"65\":1}}],[\"以确保在执行\",{\"1\":{\"41\":1}}],[\"以确保任务在新线程中运行\",{\"1\":{\"55\":1}}],[\"以巩固我们对条件变量的学习\",{\"1\":{\"41\":1}}],[\"以下代码示例展示了如何通过\",{\"1\":{\"52\":1}}],[\"以下是一个使用\",{\"1\":{\"51\":1}}],[\"以下是一个示例代码\",{\"1\":{\"37\":1}}],[\"以下内容不会对您构成任何的难度\",{\"1\":{\"18\":1}}],[\"以及一个元组\",{\"1\":{\"84\":1}}],[\"以及一个转换函数\",{\"1\":{\"65\":1}}],[\"以及给所有互斥量上锁\",{\"1\":{\"84\":1}}],[\"以及方便读者的测试与学习\",{\"1\":{\"74\":1}}],[\"以及\",{\"1\":{\"74\":1}}],[\"以及可能的测试和调试技术\",{\"1\":{\"71\":1}}],[\"以及这些操作在何种顺序下执行\",{\"1\":{\"63\":1}}],[\"以及实现之复杂\",{\"1\":{\"48\":1}}],[\"以及支持只能移动的类型\",{\"1\":{\"43\":1}}],[\"以及传递调用参数\",{\"1\":{\"43\":1,\"44\":1}}],[\"以及线程存储期\",{\"1\":{\"38\":1}}],[\"以及线程对象正确析构\",{\"1\":{\"12\":1}}],[\"以及特殊情况可能用到的互斥量\",{\"1\":{\"38\":1}}],[\"以及编译器扩展有助于理解历史上线程存储期的演进\",{\"1\":{\"37\":1}}],[\"以及还有很多其他的时间类型\",{\"1\":{\"15\":1}}],[\"以及为什么我们要两个\",{\"1\":{\"12\":1}}],[\"以更好地利用当前硬件\",{\"1\":{\"10\":1}}],[\"接下来我们进入\",{\"1\":{\"84\":1}}],[\"接下来我们聊\",{\"1\":{\"43\":1}}],[\"接口\",{\"1\":{\"56\":1}}],[\"接口的就不再介绍了\",{\"1\":{\"37\":1}}],[\"接住了\",{\"1\":{\"12\":1}}],[\"接住了异常\",{\"1\":{\"12\":1}}],[\"接受\",{\"1\":{\"76\":1}}],[\"接受一个可调用对象\",{\"1\":{\"80\":1}}],[\"接受一个整数并返回它的平方\",{\"1\":{\"45\":1}}],[\"接受一个返回\",{\"1\":{\"12\":1}}],[\"接受两个迭代器计算它们范围中对象的和\",{\"1\":{\"10\":1}}],[\"复制构造函数被定义为弃置的\",{\"1\":{\"80\":1}}],[\"复制构造和复制赋值会先读取第一个对象的值\",{\"1\":{\"66\":1}}],[\"复制赋值和复制构造定义为\",{\"1\":{\"13\":1}}],[\"复用之前\",{\"1\":{\"12\":1}}],[\"复杂的\",{\"1\":{\"0\":1}}],[\"顺带的\",{\"1\":{\"12\":1}}],[\"必然有一个线程无法成功上锁\",{\"1\":{\"28\":1}}],[\"必然余\",{\"1\":{\"10\":1}}],[\"必须显式调用\",{\"1\":{\"67\":1}}],[\"必须使用\",{\"1\":{\"43\":1}}],[\"必须使用互斥量或类似同步机制进行保护\",{\"1\":{\"42\":1}}],[\"必须和\",{\"1\":{\"35\":1}}],[\"必须得是当前对象拥有互斥量的所有权析构函数才会调用\",{\"1\":{\"31\":1}}],[\"必须同时拿到两部分才能玩\",{\"1\":{\"30\":1}}],[\"必须等待线程\",{\"1\":{\"27\":1}}],[\"必须是当前没有所有权\",{\"1\":{\"31\":1}}],[\"必须是\",{\"1\":{\"12\":1}}],[\"必要标头\",{\"1\":{\"26\":1}}],[\"所在的函数有异常被抛出\",{\"1\":{\"45\":1}}],[\"所有原子类型都有一个\",{\"1\":{\"65\":1}}],[\"所有界面与设置均通过代码控制\",{\"1\":{\"53\":1}}],[\"所有元素已被弹出\",{\"1\":{\"41\":1}}],[\"所有权才会得到释放\",{\"1\":{\"35\":1}}],[\"所有权\",{\"1\":{\"32\":1}}],[\"所有权也可以在函数内部传递\",{\"1\":{\"16\":1}}],[\"所谓的在不同作用域传递互斥量\",{\"1\":{\"32\":2}}],[\"所谓的线程停止只是一种基于用户代码的控制机制\",{\"1\":{\"21\":1}}],[\"所关联的线程正常的执行完毕以及线程对象的正常析构\",{\"1\":{\"13\":1}}],[\"所标识的线程结束其执行\",{\"1\":{\"12\":1}}],[\"所以用\",{\"1\":{\"83\":1}}],[\"所以即使是\",{\"1\":{\"78\":1}}],[\"所以请您捐赠了可以选择备注\",{\"1\":{\"77\":1}}],[\"所以我一直在强调\",{\"1\":{\"71\":1}}],[\"所以我们使用了\",{\"1\":{\"45\":1}}],[\"所以我们可以使用\",{\"1\":{\"43\":1,\"65\":1}}],[\"所以我们能写出如下代码\",{\"1\":{\"31\":1}}],[\"所以我们前面的代码可以改写为\",{\"1\":{\"30\":1}}],[\"所以我们甚至可以在刚讲完\",{\"1\":{\"10\":1}}],[\"所以很直观\",{\"1\":{\"57\":1}}],[\"所以假设有类型\",{\"1\":{\"50\":1}}],[\"所以如果不使用\",{\"1\":{\"43\":1}}],[\"所以如果你好好学习了上一章\",{\"1\":{\"24\":1}}],[\"所以通常首选std\",{\"1\":{\"40\":1}}],[\"所以增加了\",{\"1\":{\"40\":1}}],[\"所以以下函数在多线程运行是线程安全的\",{\"1\":{\"36\":1}}],[\"所以以上代码可以随意更换这两个互斥量\",{\"1\":{\"34\":1}}],[\"所以提供了std\",{\"1\":{\"35\":1}}],[\"所以依然必须得使用互斥量进行保护\",{\"1\":{\"34\":1}}],[\"所以为了效率\",{\"1\":{\"34\":1}}],[\"所以标准库提供了\",{\"1\":{\"33\":1}}],[\"所以要特别注意互斥量的生存期\",{\"1\":{\"32\":1}}],[\"所以调用者可以在这个锁保护的范围内执行代码\",{\"1\":{\"32\":1}}],[\"所以正常的用法其实是\",{\"1\":{\"31\":1}}],[\"所以抛出异常\",{\"1\":{\"31\":1}}],[\"所以\",{\"1\":{\"31\":1,\"48\":1}}],[\"所以可以直接传递给\",{\"1\":{\"31\":1}}],[\"所以可称作\",{\"1\":{\"16\":1}}],[\"所以没办法确定外部要做什么\",{\"1\":{\"30\":1}}],[\"所以后的\",{\"1\":{\"30\":1}}],[\"所以死锁\",{\"1\":{\"30\":1}}],[\"所以在等待\",{\"1\":{\"30\":1}}],[\"所以在本教程中\",{\"1\":{\"3\":1}}],[\"所以有的时候你可能会看到一些这样的代码\",{\"1\":{\"27\":1}}],[\"所以有两次移动构造\",{\"1\":{\"14\":1}}],[\"所以完全有可能函数\",{\"1\":{\"14\":1}}],[\"所以产生编译错误\",{\"1\":{\"14\":1}}],[\"所以总而言之\",{\"1\":{\"12\":1}}],[\"所以这个线程只处理平均数量的元素\",{\"1\":{\"10\":1}}],[\"所以这个线程会多分配一个元素\",{\"1\":{\"10\":1}}],[\"所以还定义了一个对象\",{\"1\":{\"10\":1}}],[\"所以只对元素个数大于\",{\"1\":{\"10\":1}}],[\"认为这样可以确保被分离的线程在这里阻塞执行完\",{\"1\":{\"12\":1}}],[\"之类的环境\",{\"1\":{\"56\":1}}],[\"之类的就行\",{\"1\":{\"15\":1}}],[\"之前的例子中都在用\",{\"1\":{\"46\":1}}],[\"之前\",{\"1\":{\"44\":1,\"66\":1}}],[\"之前呢\",{\"1\":{\"37\":1}}],[\"之前锁住互斥量\",{\"1\":{\"30\":1}}],[\"之后通过\",{\"1\":{\"45\":1}}],[\"之后\",{\"1\":{\"12\":1}}],[\"之所以我们看着抽象是因为这里的形参是无名的\",{\"1\":{\"12\":1}}],[\"应该如此\",{\"1\":{\"83\":1}}],[\"应该在所有场景中使用\",{\"1\":{\"12\":1}}],[\"应该也会提到\",{\"1\":{\"10\":1}}],[\"因其任务之间的相关性\",{\"1\":{\"62\":1}}],[\"因此不需要重试\",{\"1\":{\"67\":1}}],[\"因此需要在循环中重试\",{\"1\":{\"67\":1}}],[\"因此在某些情况下可能不适合对时间间隔进行精确测量\",{\"1\":{\"48\":1}}],[\"因此适用于需要保持时间顺序和不受系统时间变化影响的应用场景\",{\"1\":{\"48\":1}}],[\"因此一个周期为\",{\"1\":{\"48\":1}}],[\"因此它们不会共享同一个对象\",{\"1\":{\"36\":1}}],[\"因此就会产生条件竞争\",{\"1\":{\"33\":1}}],[\"因此有更好的性能和更少的竞争\",{\"1\":{\"27\":1}}],[\"因此当多个线程同时访问并修改\",{\"1\":{\"25\":1}}],[\"因此\",{\"1\":{\"12\":1,\"13\":1,\"36\":1,\"41\":1,\"51\":1,\"66\":1,\"71\":1}}],[\"因为已经将参数传递给了线程\",{\"1\":{\"80\":1}}],[\"因为内存对齐\",{\"1\":{\"79\":1}}],[\"因为并发支持库的很多设施其实现是较为简单的\",{\"1\":{\"73\":1}}],[\"因为不同的\",{\"1\":{\"71\":1}}],[\"因为不见得你能教会他们\",{\"1\":{\"33\":1}}],[\"因为它有转换函数\",{\"1\":{\"65\":1}}],[\"因为它们的复制构造与复制赋值运算符被定义为弃置的\",{\"1\":{\"65\":1}}],[\"因为它们是线程不安全的\",{\"1\":{\"52\":1}}],[\"因为它们都在等待对方释放互斥量\",{\"1\":{\"30\":1}}],[\"因为只有三个线程能成功调用\",{\"1\":{\"58\":1}}],[\"因为有\",{\"1\":{\"57\":1}}],[\"因为有潜在的条件竞争\",{\"1\":{\"33\":1}}],[\"因为一分钟等于\",{\"1\":{\"48\":1}}],[\"因为无限期地等待事件发生可能会导致性能下降或资源浪费\",{\"1\":{\"47\":1}}],[\"因为临时对象的生存期就在这一行\",{\"1\":{\"43\":1}}],[\"因为修改函数和等待函数共用一个互斥量\",{\"1\":{\"40\":1}}],[\"因为本文不是详尽的文档\",{\"1\":{\"33\":1}}],[\"因为对象还没构造\",{\"1\":{\"33\":1}}],[\"因为代码是外部提供的\",{\"1\":{\"30\":1}}],[\"因为在大部分时间里\",{\"1\":{\"30\":1}}],[\"因为前面已经使用了\",{\"1\":{\"30\":1}}],[\"因为互斥量上锁顺序不同\",{\"1\":{\"30\":1}}],[\"因为我们的函数中的参数是引用\",{\"1\":{\"14\":1}}],[\"因为你要是不抛出\",{\"1\":{\"12\":1}}],[\"因为程序员必须确保所有创建的线程正常退出\",{\"1\":{\"12\":1}}],[\"因为\",{\"1\":{\"12\":1,\"13\":1,\"31\":2,\"36\":1,\"44\":1,\"65\":1}}],[\"因为要执行的任务非常之多\",{\"1\":{\"5\":1}}],[\"通知等待的线程\",{\"1\":{\"40\":1}}],[\"通过返回非原子值进行赋值\",{\"1\":{\"67\":1}}],[\"通过批处理等技术\",{\"1\":{\"65\":1}}],[\"通过互斥量的保护\",{\"1\":{\"64\":1}}],[\"通过这种方式\",{\"1\":{\"58\":1}}],[\"通过初始化该信号量为\",{\"1\":{\"58\":1}}],[\"通过实际操作理解代码效果\",{\"1\":{\"57\":1}}],[\"通过显示的线程\",{\"1\":{\"55\":1}}],[\"通过另一线程触发等待事件的机制是最基本的唤醒方式\",{\"1\":{\"40\":1}}],[\"通过函数\",{\"1\":{\"37\":1}}],[\"通过调用\",{\"1\":{\"21\":1,\"60\":1}}],[\"通过该对象来管理线程\",{\"1\":{\"11\":1}}],[\"通常都会是最新的\",{\"1\":{\"74\":1}}],[\"通常只是用作构建一些库设施\",{\"1\":{\"66\":1}}],[\"通常\",{\"1\":{\"65\":1}}],[\"通常的实现是直接保有一个\",{\"1\":{\"62\":1}}],[\"通常情况下\",{\"1\":{\"47\":1}}],[\"通常它有更好的性能\",{\"1\":{\"58\":1}}],[\"通常它会和\",{\"1\":{\"44\":1}}],[\"通常它比裸调用\",{\"1\":{\"30\":1}}],[\"通常会使用同步机制\",{\"1\":{\"38\":1}}],[\"通常建议优先\",{\"1\":{\"31\":1}}],[\"通常用于描述锁定的范围大小\",{\"1\":{\"27\":1}}],[\"通常说某个特定的线程正持有这个锁\",{\"1\":{\"26\":1}}],[\"通常需要线程执行的函数中有一些系统调用\",{\"1\":{\"23\":1}}],[\"通常占\",{\"1\":{\"20\":1}}],[\"通常非常不推荐使用\",{\"1\":{\"12\":1}}],[\"正在执行\",{\"1\":{\"52\":1,\"54\":1}}],[\"正在延迟执行\",{\"1\":{\"49\":1}}],[\"正常情况会保证传入的可调用对象只调用一次\",{\"1\":{\"33\":1}}],[\"正常\",{\"1\":{\"31\":1}}],[\"正常上锁\",{\"1\":{\"31\":1}}],[\"正常析构\",{\"1\":{\"12\":1,\"16\":2}}],[\"正是通过\",{\"1\":{\"9\":1}}],[\"正是任务切换使得这些后台任务可以运行\",{\"1\":{\"5\":1}}],[\"造成未定义行为\",{\"1\":{\"12\":1}}],[\"访问悬空引用\",{\"1\":{\"12\":1}}],[\"用做调用\",{\"1\":{\"84\":1}}],[\"用了就没事\",{\"1\":{\"57\":1}}],[\"用户非要做这些事情也是防不住的\",{\"1\":{\"29\":1}}],[\"用来实际执行线程\",{\"1\":{\"80\":1}}],[\"用来引用互斥量\",{\"1\":{\"27\":1}}],[\"用来管理互斥量的上锁与解锁\",{\"1\":{\"27\":1}}],[\"用来计算\",{\"1\":{\"10\":1}}],[\"用一段对比代码为你直观的展示互斥量的作用\",{\"1\":{\"26\":1}}],[\"用于指示当前线程中抛出的异常\",{\"1\":{\"45\":1}}],[\"用于存储计算结果\",{\"1\":{\"45\":1}}],[\"用于存储一个值或一个异常\",{\"1\":{\"45\":1}}],[\"用于获取返回值\",{\"1\":{\"44\":1}}],[\"用于在队列为空时等待\",{\"1\":{\"41\":1}}],[\"用于保护队列操作的独占访问\",{\"1\":{\"41\":1}}],[\"用于保护共享数据的访问\",{\"1\":{\"40\":1}}],[\"用于线程间的同步\",{\"1\":{\"40\":1}}],[\"用于声明具有线程存储期的对象\",{\"1\":{\"37\":1}}],[\"用于搭配\",{\"1\":{\"33\":1}}],[\"用于通知线程应该停止执行\",{\"1\":{\"23\":1}}],[\"用于调用这个可变参数的可调用对象\",{\"1\":{\"84\":1}}],[\"用于调用\",{\"1\":{\"12\":1}}],[\"局部对象就要逆序销毁了\",{\"1\":{\"13\":1}}],[\"局部对象\",{\"1\":{\"12\":2}}],[\"执行函数的类型要求\",{\"1\":{\"80\":1}}],[\"执行递增操作\",{\"1\":{\"64\":1}}],[\"执行传递的\",{\"1\":{\"44\":1}}],[\"执行一些任务\",{\"1\":{\"32\":1}}],[\"执行的时候\",{\"1\":{\"30\":2}}],[\"执行多少次\",{\"1\":{\"27\":1}}],[\"执行多个任务\",{\"1\":{\"5\":1}}],[\"执行完里面的代码\",{\"1\":{\"27\":1}}],[\"执行完毕\",{\"1\":{\"13\":1}}],[\"执行我们的\",{\"1\":{\"26\":1}}],[\"执行了一半\",{\"1\":{\"25\":2}}],[\"执行\",{\"1\":{\"12\":1,\"30\":2,\"44\":1}}],[\"执行什么呢\",{\"1\":{\"12\":1}}],[\"执行任务是没有返回值的\",{\"1\":{\"42\":1}}],[\"执行任务\",{\"1\":{\"12\":1}}],[\"主模板的讲解\",{\"1\":{\"84\":1}}],[\"主模板\",{\"1\":{\"83\":1,\"84\":1}}],[\"主\",{\"1\":{\"58\":4}}],[\"主要是用\",{\"1\":{\"84\":1}}],[\"主要是复杂性和需求\",{\"1\":{\"31\":1}}],[\"主要的内容就是我们上面讲的类模板\",{\"1\":{\"49\":1}}],[\"主要的难度其实在于对\",{\"1\":{\"10\":1}}],[\"主要在于类型之多\",{\"1\":{\"48\":1}}],[\"主线程用于处理\",{\"1\":{\"51\":1}}],[\"主线程延时\",{\"1\":{\"15\":1}}],[\"主线程不等待\",{\"1\":{\"12\":1}}],[\"主线程\",{\"1\":{\"12\":1}}],[\"可选的内存序包括\",{\"1\":{\"65\":3}}],[\"可用任何满足可复制构造\",{\"1\":{\"65\":1}}],[\"可复用的线程屏障\",{\"1\":{\"59\":1}}],[\"可能不同\",{\"1\":{\"81\":1}}],[\"可能考虑使用复制初始化\",{\"1\":{\"75\":1}}],[\"可能没有接触过\",{\"1\":{\"73\":1}}],[\"可能比原子操作更高效\",{\"1\":{\"65\":1}}],[\"可能别的翻译单元\",{\"1\":{\"32\":1}}],[\"可能的运行结果是\",{\"1\":{\"41\":1}}],[\"可能的运行结果\",{\"1\":{\"28\":1}}],[\"可能会导致数据竞争\",{\"1\":{\"25\":1}}],[\"可能会发生未定义的行为\",{\"1\":{\"25\":1}}],[\"可能导致许多问题\",{\"1\":{\"25\":1}}],[\"可能抛出异常\",{\"1\":{\"13\":1}}],[\"可能悬空引用\",{\"1\":{\"12\":1}}],[\"可以管理任意个数的互斥量\",{\"1\":{\"84\":1}}],[\"可以阅读使用文档\",{\"1\":{\"74\":1}}],[\"可以按照一定规则重新安排代码的执行顺序\",{\"1\":{\"71\":1}}],[\"可以直接跳过本节内容\",{\"1\":{\"71\":1}}],[\"可以直接安装\",{\"1\":{\"53\":1}}],[\"可以避免多余的加载\",{\"1\":{\"67\":1}}],[\"可以应用任何内存顺序\",{\"1\":{\"66\":1}}],[\"可以确保此时对象处于\",{\"1\":{\"66\":1}}],[\"可以有效控制\",{\"1\":{\"58\":1}}],[\"可以尝试修改代码\",{\"1\":{\"57\":1}}],[\"可以尝试将函数的第一行与最后一行注释掉以验证这一点\",{\"1\":{\"52\":1}}],[\"可以验证这一点\",{\"1\":{\"55\":1}}],[\"可以减去一个时间点\",{\"1\":{\"50\":1}}],[\"可以对两个时间段进行加减乘除\",{\"1\":{\"49\":1}}],[\"可以将元组存储的参数全部拿出\",{\"1\":{\"84\":1}}],[\"可以将不相关的指令重排\",{\"1\":{\"71\":1}}],[\"可以将时间点转换为\",{\"1\":{\"48\":1}}],[\"可以将所有\",{\"1\":{\"30\":1}}],[\"可以通过\",{\"1\":{\"48\":1}}],[\"可以通过编译\",{\"1\":{\"14\":2,\"43\":1}}],[\"可以选择是否传递一个谓词\",{\"1\":{\"47\":1}}],[\"可以改为\",{\"1\":{\"46\":1}}],[\"可以执行后续的操作\",{\"1\":{\"40\":1}}],[\"可以下车了\",{\"1\":{\"40\":1}}],[\"可以看一下时间\",{\"1\":{\"40\":1}}],[\"可以获取互斥量的所有权\",{\"1\":{\"32\":1}}],[\"可以利用各种类来进行传递\",{\"1\":{\"32\":1}}],[\"可以在没有被互斥量保护的情况下调用\",{\"1\":{\"29\":1}}],[\"可以根据传入的参数自行推导\",{\"1\":{\"27\":1}}],[\"可以说已经比较了解了\",{\"1\":{\"24\":1}}],[\"可以添加\",{\"1\":{\"21\":1}}],[\"可以再回过头来问问自己是否能够回答这些问题\",{\"1\":{\"17\":1}}],[\"可以传递给\",{\"1\":{\"14\":1}}],[\"可以观看视频\",{\"1\":{\"14\":1}}],[\"可以隐式转换为被包装对象的引用\",{\"1\":{\"14\":1}}],[\"可以防止编译器隐式生成\",{\"1\":{\"13\":1}}],[\"可以简化代码并避免引入不必要的局部对象\",{\"1\":{\"12\":1}}],[\"可以使用\",{\"1\":{\"10\":1,\"30\":1,\"34\":1,\"65\":1}}],[\"可以指代线程\",{\"1\":{\"8\":1}}],[\"可以先学习\",{\"1\":{\"0\":1}}],[\"为原子操作指定不同的内存序\",{\"1\":{\"67\":1}}],[\"为就绪为止\",{\"1\":{\"43\":1}}],[\"为例\",{\"1\":{\"31\":1}}],[\"为了遍历形参包\",{\"1\":{\"80\":1}}],[\"为了提高性能\",{\"1\":{\"71\":1}}],[\"为了防止服务器过载\",{\"1\":{\"58\":1}}],[\"为了实现一个线程安全的队列\",{\"1\":{\"41\":1}}],[\"为了保证数据交换的正确性\",{\"1\":{\"30\":1}}],[\"为了观测运行我们可以为\",{\"1\":{\"41\":1}}],[\"为了观测\",{\"1\":{\"13\":1}}],[\"为什么要这样\",{\"1\":{\"84\":1}}],[\"为什么\",{\"1\":{\"20\":1}}],[\"为什么需要\",{\"1\":{\"17\":1}}],[\"为什么默认按值复制\",{\"1\":{\"17\":1}}],[\"为什么还要\",{\"1\":{\"12\":1}}],[\"为\",{\"1\":{\"12\":3,\"20\":1,\"31\":2,\"40\":1,\"58\":1,\"67\":3}}],[\"为其处理器引入了全新的\",{\"1\":{\"10\":1}}],[\"允许指定成功和失败情况下的内存序\",{\"1\":{\"67\":1}}],[\"允许任何数量的线程阻塞直至期待数量的线程到达\",{\"1\":{\"59\":1}}],[\"允许检查是否有停止请求\",{\"1\":{\"21\":1}}],[\"允许从外部请求线程停止\",{\"1\":{\"21\":1}}],[\"允许其他操作没有价值\",{\"1\":{\"13\":1}}],[\"允许此线程独立的运行\",{\"1\":{\"12\":1}}],[\"允许在每个内核上运行多个线程\",{\"1\":{\"10\":1}}],[\"dis\",{\"1\":{\"58\":2}}],[\"distribution<>\",{\"1\":{\"58\":1}}],[\"distance\",{\"1\":{\"10\":6,\"44\":5}}],[\"divide<years\",{\"1\":{\"49\":1}}],[\"days\",{\"1\":{\"49\":3}}],[\"date\",{\"1\":{\"30\":1}}],[\"data\",{\"1\":{\"18\":2,\"29\":14,\"32\":3,\"34\":4,\"41\":13,\"46\":22,\"67\":2}}],[\"dll\",{\"1\":{\"32\":1}}],[\"d\",{\"1\":{\"29\":2}}],[\"doing\",{\"1\":{\"66\":2}}],[\"down\",{\"1\":{\"60\":3}}],[\"done\",{\"1\":{\"50\":2,\"60\":4}}],[\"don\",{\"1\":{\"27\":1,\"31\":1,\"83\":2,\"84\":1}}],[\"do\",{\"1\":{\"18\":3,\"29\":3,\"66\":1,\"80\":1}}],[\"duration>\",{\"1\":{\"50\":1}}],[\"duration<>\",{\"1\":{\"49\":1,\"50\":1}}],[\"duration<int\",{\"1\":{\"49\":6}}],[\"duration<long\",{\"1\":{\"49\":4,\"50\":1}}],[\"duration<\",{\"1\":{\"48\":1}}],[\"duration\",{\"1\":{\"15\":1,\"47\":1,\"48\":2,\"49\":4,\"50\":3}}],[\"device\",{\"1\":{\"58\":1}}],[\"decltype\",{\"1\":{\"84\":3}}],[\"declspec\",{\"1\":{\"37\":4}}],[\"decay\",{\"1\":{\"21\":1,\"80\":10}}],[\"deadlock\",{\"1\":{\"31\":1}}],[\"define\",{\"1\":{\"65\":11}}],[\"deferred\",{\"1\":{\"43\":4,\"49\":5}}],[\"defer\",{\"1\":{\"31\":5}}],[\"default\",{\"1\":{\"18\":1,\"65\":3,\"66\":1,\"83\":1}}],[\"destructor\",{\"1\":{\"27\":1,\"83\":1}}],[\"delete\",{\"1\":{\"13\":2,\"14\":1,\"27\":2,\"36\":9,\"37\":1,\"38\":1,\"43\":1,\"65\":2,\"75\":1,\"80\":1,\"83\":6}}],[\"detach\",{\"1\":{\"12\":12,\"13\":1,\"14\":3,\"18\":2}}],[\"还可以设置内存次序\",{\"1\":{\"71\":1}}],[\"还支持\",{\"1\":{\"65\":1}}],[\"还使用\",{\"1\":{\"62\":1}}],[\"还未关联\",{\"1\":{\"43\":1}}],[\"还讲了一下互斥量所有权转移\",{\"1\":{\"38\":1}}],[\"还有一个\",{\"1\":{\"45\":1}}],[\"还有一个就是表示对象是否拥有互斥量所有权的\",{\"1\":{\"31\":1}}],[\"还有它的形参是函数类型而不是函数指针类型\",{\"1\":{\"12\":1}}],[\"还引入了一个新的\",{\"1\":{\"27\":1}}],[\"还没有元素\",{\"1\":{\"25\":1}}],[\"还是简单的多\",{\"1\":{\"85\":1}}],[\"还是那句话\",{\"1\":{\"85\":1}}],[\"还是内部用了锁实现\",{\"1\":{\"65\":1}}],[\"还是\",{\"1\":{\"12\":1,\"81\":1}}],[\"合并这两个操作无法保证其原子性\",{\"1\":{\"66\":1}}],[\"合并\",{\"1\":{\"12\":1}}],[\"决定它的执行策略\",{\"1\":{\"12\":1}}],[\"即不可改变可观察的副作用\",{\"1\":{\"71\":1}}],[\"即代表出现了假失败\",{\"1\":{\"67\":1}}],[\"即可\",{\"1\":{\"44\":1,\"48\":1}}],[\"即可在析构的时候正常解锁\",{\"1\":{\"31\":1}}],[\"即是否当前关联任务\",{\"1\":{\"43\":1}}],[\"即任务执行完毕\",{\"1\":{\"43\":1}}],[\"即输出提示信息\",{\"1\":{\"40\":1}}],[\"即初始化只有一次\",{\"1\":{\"33\":1}}],[\"即表示当前对象拥有互斥量的所有权\",{\"1\":{\"31\":1}}],[\"即线程对象有活跃线程\",{\"1\":{\"12\":1}}],[\"即\",{\"1\":{\"12\":1,\"25\":1,\"31\":1,\"33\":1,\"36\":1,\"40\":1,\"47\":1,\"54\":1,\"67\":1,\"81\":1}}],[\"即使程序在某些平台上运行正常\",{\"1\":{\"71\":1}}],[\"即使通过多次\",{\"1\":{\"71\":1}}],[\"即使这些实例是同一对象的副本且共享所有权也是如此\",{\"1\":{\"62\":1}}],[\"即使在系统休眠或时钟调整的情况下\",{\"1\":{\"48\":1}}],[\"即使\",{\"1\":{\"36\":1,\"64\":1,\"71\":1}}],[\"即使会改变执行顺序\",{\"1\":{\"25\":1}}],[\"即使你早已学习乃至使用\",{\"1\":{\"23\":1}}],[\"即使你从来没使用过\",{\"1\":{\"0\":1}}],[\"即使我们的成员函数形参类型为引用\",{\"1\":{\"14\":1}}],[\"即使我还没有为你讲述概念\",{\"1\":{\"12\":1}}],[\"即使是非静态成员函数没有使用任何数据成员\",{\"1\":{\"14\":1}}],[\"即使函数中的参数是引用\",{\"1\":{\"14\":1}}],[\"即使函数\",{\"1\":{\"13\":1}}],[\"表现如同\",{\"1\":{\"71\":1}}],[\"表示资源不可用\",{\"1\":{\"80\":1}}],[\"表示新的执行线程开始执行\",{\"1\":{\"80\":1}}],[\"表示时间间隔\",{\"1\":{\"48\":1}}],[\"表示是否到达目的地\",{\"1\":{\"40\":1}}],[\"表示到达目的地\",{\"1\":{\"40\":2}}],[\"表示没有互斥量所有权\",{\"1\":{\"31\":1}}],[\"表示线程对象目前没有关联活跃线程\",{\"1\":{\"9\":1}}],[\"表达式或其它函数对象\",{\"1\":{\"44\":1}}],[\"表达式线程安全考虑两方面\",{\"1\":{\"36\":1}}],[\"表达式线程安全要考虑三方面\",{\"1\":{\"36\":1}}],[\"表达式\",{\"1\":{\"12\":1,\"44\":1}}],[\"再结合源码讲解会更加简单直观\",{\"1\":{\"73\":1}}],[\"再放到线程中执行\",{\"1\":{\"44\":1}}],[\"再执行任务\",{\"1\":{\"44\":1}}],[\"再休眠结束后再对互斥量上锁\",{\"1\":{\"40\":1}}],[\"再次上锁是错误的\",{\"1\":{\"35\":1}}],[\"再次调用\",{\"1\":{\"12\":1,\"45\":1}}],[\"再上锁\",{\"1\":{\"30\":2}}],[\"再锁定\",{\"1\":{\"30\":1}}],[\"再试想\",{\"1\":{\"30\":1}}],[\"再调用\",{\"1\":{\"16\":1}}],[\"再然后\",{\"1\":{\"15\":1}}],[\"再将函数类型写成函数指针类型\",{\"1\":{\"12\":1}}],[\"再加上我们的余数\",{\"1\":{\"10\":1}}],[\"省略了形参的名称\",{\"1\":{\"12\":1}}],[\"和形参包的索引\",{\"1\":{\"80\":1}}],[\"和一系列参数\",{\"1\":{\"80\":1}}],[\"和编译器可能对内存操作的顺序有不同的处理\",{\"1\":{\"71\":1}}],[\"和清除\",{\"1\":{\"66\":1}}],[\"和预处理宏来让程序执行不同的代码\",{\"1\":{\"65\":1}}],[\"和线程\",{\"1\":{\"64\":1}}],[\"和等待\",{\"1\":{\"58\":1}}],[\"和每一个任务进行关联的\",{\"1\":{\"44\":1}}],[\"和pthread\",{\"1\":{\"37\":1}}],[\"和相关的函数\",{\"1\":{\"37\":1}}],[\"和\",{\"1\":{\"12\":2,\"21\":2,\"22\":1,\"23\":1,\"26\":1,\"27\":1,\"31\":1,\"33\":1,\"34\":1,\"37\":1,\"40\":1,\"42\":1,\"47\":1,\"53\":1,\"59\":1,\"65\":2,\"67\":2,\"71\":1,\"80\":2,\"81\":1,\"83\":1,\"84\":2}}],[\"和单线程效率差距越明显\",{\"1\":{\"10\":1}}],[\"声明了一个类型形参包\",{\"1\":{\"83\":1}}],[\"声明\",{\"1\":{\"12\":1}}],[\"且是我们本章重点\",{\"1\":{\"80\":1}}],[\"且任一线程使用\",{\"1\":{\"62\":1}}],[\"且只能减少计数\",{\"1\":{\"60\":1}}],[\"且方便我们获取返回值罢了\",{\"1\":{\"44\":1}}],[\"且运行时很多地方都依赖这个数据结构需要读取\",{\"1\":{\"34\":1}}],[\"且\",{\"1\":{\"31\":1}}],[\"且等待另一个线程的互斥量解锁\",{\"1\":{\"30\":1}}],[\"且写了个函数类型\",{\"1\":{\"12\":1}}],[\"且使用的都是\",{\"1\":{\"12\":1}}],[\"小括号初始化\",{\"1\":{\"12\":1}}],[\"函数来启动一个线程\",{\"1\":{\"80\":1}}],[\"函数很简单\",{\"1\":{\"80\":1}}],[\"函数体中调用了一个函数\",{\"1\":{\"80\":1}}],[\"函数会返回\",{\"1\":{\"66\":1}}],[\"函数会在新线程中执行\",{\"1\":{\"12\":1}}],[\"函数原子地将计数减至\",{\"1\":{\"60\":1}}],[\"函数阻塞子线程\",{\"1\":{\"60\":1}}],[\"函数就是\",{\"1\":{\"58\":1}}],[\"函数就是我们先前说的\",{\"1\":{\"58\":1}}],[\"函数获取这个异常\",{\"1\":{\"45\":1}}],[\"函数外\",{\"1\":{\"45\":1}}],[\"函数设置\",{\"1\":{\"45\":1}}],[\"函数执行后\",{\"1\":{\"40\":1}}],[\"函数中调用\",{\"1\":{\"66\":1}}],[\"函数中的等待结束\",{\"1\":{\"40\":1}}],[\"函数中\",{\"1\":{\"40\":2}}],[\"函数退出也能正常解锁\",{\"1\":{\"30\":1}}],[\"函数的修改操作同一时间只能有一个线程在执行\",{\"1\":{\"27\":1}}],[\"函数却是可以被打断的\",{\"1\":{\"25\":1}}],[\"函数返回\",{\"1\":{\"16\":1,\"50\":1}}],[\"函数模板有两个重载\",{\"1\":{\"43\":1}}],[\"函数模板\",{\"1\":{\"14\":1,\"43\":1}}],[\"函数\",{\"1\":{\"13\":1,\"14\":1,\"21\":2,\"27\":1,\"30\":3,\"33\":1,\"42\":1,\"44\":1,\"47\":1,\"66\":2,\"67\":2,\"80\":1}}],[\"函数继续执行下面别的代码\",{\"1\":{\"12\":1}}],[\"函数结束的时候会解锁互斥量\",{\"1\":{\"31\":1,\"32\":1}}],[\"函数结束\",{\"1\":{\"12\":1}}],[\"函数定义\",{\"1\":{\"12\":1}}],[\"函数名为\",{\"1\":{\"12\":1}}],[\"函数名可以隐式转换到指向它的函数指针\",{\"1\":{\"12\":1}}],[\"函数声明\",{\"1\":{\"12\":2}}],[\"函数可以获得我们当前硬件支持的并发线程数量\",{\"1\":{\"10\":1}}],[\"自动调用析构函数进行销毁操作\",{\"1\":{\"66\":1}}],[\"自旋\",{\"1\":{\"40\":1}}],[\"自然可以传递给\",{\"1\":{\"44\":1}}],[\"自然没有数据竞争\",{\"1\":{\"36\":1}}],[\"自然是一次\",{\"1\":{\"33\":1}}],[\"自然是会保有一个副本\",{\"1\":{\"14\":1}}],[\"自然不会产生死锁\",{\"1\":{\"30\":1}}],[\"自然不存在数据竞争\",{\"1\":{\"27\":1}}],[\"自然不可移动不可复制\",{\"1\":{\"27\":1}}],[\"自然抛出\",{\"1\":{\"12\":1}}],[\"自然就得构造对象了\",{\"1\":{\"12\":1}}],[\"自然也不会启动线程执行任务\",{\"1\":{\"12\":1}}],[\"自己手动实现一些库\",{\"1\":{\"0\":1}}],[\"罢了\",{\"1\":{\"10\":1}}],[\"无符号\",{\"1\":{\"79\":1}}],[\"无锁的原子操作可以显著减少锁的开销和争用\",{\"1\":{\"65\":1}}],[\"无需进行其他\",{\"1\":{\"53\":1}}],[\"无法退出\",{\"1\":{\"66\":1}}],[\"无法增加计数\",{\"1\":{\"60\":1}}],[\"无法点击\",{\"1\":{\"52\":1}}],[\"无法通过编译\",{\"1\":{\"43\":1}}],[\"无法使用\",{\"1\":{\"37\":1}}],[\"无法正确析构\",{\"1\":{\"9\":1}}],[\"无死锁\",{\"1\":{\"30\":1}}],[\"无序且操作可能被打断\",{\"1\":{\"18\":1}}],[\"无非是用容器存储线程对象管理\",{\"1\":{\"10\":1}}],[\"最简单的方式就是先看它的数据成员有什么\",{\"1\":{\"79\":1}}],[\"最简单的作用是\",{\"1\":{\"42\":1}}],[\"最新的\",{\"1\":{\"72\":1}}],[\"最基本的预处理器判断\",{\"1\":{\"65\":1}}],[\"最基础的概念就是如此\",{\"1\":{\"63\":1}}],[\"最大并发数为\",{\"1\":{\"58\":1}}],[\"最终输出的是以毫秒作为单位\",{\"1\":{\"50\":1}}],[\"最终的值是\",{\"1\":{\"49\":1}}],[\"最后汇总的时候写一个循环\",{\"1\":{\"44\":1}}],[\"最后聊了一下\",{\"1\":{\"38\":1}}],[\"最后打印了\",{\"1\":{\"25\":1}}],[\"最后一行调用\",{\"1\":{\"12\":1}}],[\"最后一行是\",{\"1\":{\"10\":1}}],[\"最后进行\",{\"1\":{\"10\":1}}],[\"最多可并行执行\",{\"1\":{\"10\":1}}],[\"时转换为秒时没问题的\",{\"1\":{\"49\":1}}],[\"时钟节拍被指定为\",{\"1\":{\"48\":1}}],[\"时钟节拍\",{\"1\":{\"48\":1}}],[\"时钟被视为时间信息的来源\",{\"1\":{\"48\":1}}],[\"时钟\",{\"0\":{\"48\":1},\"1\":{\"47\":1}}],[\"时间库的知识\",{\"1\":{\"62\":1}}],[\"时间库支持四则运算\",{\"1\":{\"49\":1}}],[\"时间部分最简单的就是时间段\",{\"1\":{\"49\":1}}],[\"时间类型\",{\"1\":{\"48\":1}}],[\"时间点的知识也就足够了\",{\"1\":{\"50\":1}}],[\"时间点也支持加减以及比较操作\",{\"1\":{\"50\":1}}],[\"时间点顾名思义就是时间中的一个点\",{\"1\":{\"50\":1}}],[\"时间点可用\",{\"1\":{\"50\":1}}],[\"时间点\",{\"0\":{\"50\":1},\"1\":{\"47\":2}}],[\"时间段对象可以通过\",{\"1\":{\"49\":1}}],[\"时间段有隐式转换\",{\"1\":{\"49\":1}}],[\"时间段\",{\"0\":{\"49\":1},\"1\":{\"47\":2}}],[\"时间片持续运行\",{\"1\":{\"41\":1}}],[\"时间片让其他线程执行\",{\"1\":{\"15\":1}}],[\"时间会大大减少\",{\"1\":{\"15\":1}}],[\"时间\",{\"1\":{\"15\":1,\"47\":1}}],[\"时\",{\"1\":{\"10\":3,\"25\":1,\"66\":1}}],[\"2px\",{\"1\":{\"54\":1}}],[\"2>\",{\"1\":{\"48\":1}}],[\"25>\",{\"1\":{\"48\":1}}],[\"25\",{\"1\":{\"48\":1}}],[\"29\",{\"1\":{\"21\":1}}],[\"24\",{\"1\":{\"20\":1}}],[\"2我们写出了函数形参名称\",{\"1\":{\"12\":1}}],[\"2\",{\"1\":{\"10\":7,\"12\":5,\"21\":1,\"28\":2,\"30\":3,\"33\":1,\"35\":1,\"40\":3,\"41\":7,\"44\":3,\"48\":1,\"58\":1,\"60\":2,\"65\":2,\"67\":1,\"71\":1}}],[\"200ms\",{\"1\":{\"21\":1}}],[\"20\",{\"1\":{\"10\":2,\"65\":1}}],[\"2024\",{\"1\":{\"10\":1,\"21\":1,\"47\":1}}],[\"30\",{\"1\":{\"65\":1}}],[\"35ms\",{\"1\":{\"49\":2}}],[\"35\",{\"1\":{\"49\":1}}],[\"3999\",{\"1\":{\"49\":1}}],[\"3s\",{\"1\":{\"15\":1,\"21\":1,\"58\":2,\"60\":1}}],[\"3\",{\"1\":{\"10\":1,\"14\":3,\"15\":2,\"21\":2,\"33\":1,\"35\":1,\"40\":1,\"41\":7,\"49\":1,\"58\":5,\"60\":2}}],[\"假设略微了解操作系统基本知识\",{\"1\":{\"73\":1}}],[\"假设返回\",{\"1\":{\"67\":1}}],[\"假设我们有一个\",{\"1\":{\"58\":1}}],[\"假设一个时钟一秒有\",{\"1\":{\"48\":1}}],[\"假设需要执行一个耗时任务并获取其返回值\",{\"1\":{\"43\":1}}],[\"假设5秒后到达目的地\",{\"1\":{\"40\":1}}],[\"假设你正在一辆夜间运行的地铁上\",{\"1\":{\"40\":1}}],[\"假设线程\",{\"1\":{\"27\":1}}],[\"假设有两个线程运行\",{\"1\":{\"67\":1}}],[\"假设有线程\",{\"1\":{\"27\":1}}],[\"假设有\",{\"1\":{\"10\":1}}],[\"假设开发者对操作系统等知识有基本了解\",{\"1\":{\"7\":1}}],[\"求和即可\",{\"1\":{\"10\":1}}],[\"到此\",{\"1\":{\"41\":1,\"44\":1,\"50\":1,\"71\":1}}],[\"到底读取到多少不确定\",{\"1\":{\"64\":1}}],[\"到底哪个线程会抢到\",{\"1\":{\"41\":1}}],[\"到底是如何做到的\",{\"1\":{\"17\":1}}],[\"到达目的地\",{\"1\":{\"40\":1}}],[\"到达设置的位置就提醒\",{\"1\":{\"40\":1}}],[\"到站的时候有人或者其它东西能将你叫醒\",{\"1\":{\"40\":1}}],[\"到\",{\"1\":{\"10\":1}}],[\"是不是很熟悉\",{\"1\":{\"83\":1}}],[\"是无稽之谈\",{\"1\":{\"81\":1,\"82\":1,\"85\":1}}],[\"是无锁类型\",{\"1\":{\"65\":1}}],[\"是重中之重\",{\"1\":{\"80\":1}}],[\"是如何创建线程传递参数的\",{\"1\":{\"78\":1}}],[\"是如何构造的\",{\"1\":{\"78\":1}}],[\"是如何做到的呢\",{\"1\":{\"27\":1}}],[\"是比较严格的内存模型\",{\"1\":{\"71\":1}}],[\"是最基本的整数原子类型\",{\"1\":{\"67\":1}}],[\"是最简单的原子类型\",{\"1\":{\"66\":1}}],[\"是编译期常量\",{\"1\":{\"65\":1}}],[\"是非原子操作\",{\"1\":{\"64\":1}}],[\"是我们设置的非类型模板参数\",{\"1\":{\"58\":1}}],[\"是我们学习\",{\"1\":{\"23\":1}}],[\"是在主线程运行的\",{\"1\":{\"55\":1}}],[\"是指们背后用来关门的棍子\",{\"1\":{\"60\":1}}],[\"是指提供稳定\",{\"1\":{\"48\":1}}],[\"是指在计算机科学和信息技术中的一种操作方式\",{\"1\":{\"39\":1}}],[\"是分钟类型\",{\"1\":{\"48\":1}}],[\"是按引用传递\",{\"1\":{\"46\":1}}],[\"是可复制的\",{\"1\":{\"46\":1}}],[\"是可调用对象\",{\"1\":{\"44\":1}}],[\"是只能移动的\",{\"1\":{\"46\":1}}],[\"是只能移动不可复制的类\",{\"1\":{\"32\":1}}],[\"是因为\",{\"1\":{\"43\":1}}],[\"是系统调度决定的\",{\"1\":{\"41\":1}}],[\"是局部对象\",{\"1\":{\"36\":1}}],[\"是全局对象\",{\"1\":{\"36\":1}}],[\"是安全的\",{\"1\":{\"34\":1}}],[\"是没有数据竞争的\",{\"1\":{\"34\":1}}],[\"是简单合理的做法\",{\"1\":{\"33\":1}}],[\"是查看指针是否为空\",{\"1\":{\"33\":1}}],[\"是线程协调机制\",{\"1\":{\"59\":1}}],[\"是线程安全的\",{\"1\":{\"36\":1}}],[\"是线程安全的吗\",{\"0\":{\"36\":1}}],[\"是线程安全\",{\"1\":{\"33\":2}}],[\"是线程分离\",{\"1\":{\"12\":1}}],[\"是灵活的\",{\"1\":{\"32\":1}}],[\"是自动发生的\",{\"1\":{\"32\":1}}],[\"是有\",{\"1\":{\"31\":1}}],[\"是互斥量中的一种尝试上锁的方式\",{\"1\":{\"28\":1}}],[\"是否总是无锁\",{\"1\":{\"65\":1}}],[\"是否收到了停止请求\",{\"1\":{\"21\":1}}],[\"是否对未捕获的异常进行任何栈回溯由实现定义\",{\"1\":{\"13\":1}}],[\"是一种非常古老的机制\",{\"1\":{\"37\":1}}],[\"是一种用来保护临界区\",{\"1\":{\"26\":1}}],[\"是一种发送取消请求的函数\",{\"1\":{\"21\":1}}],[\"是一个可变参数类模板\",{\"1\":{\"83\":1}}],[\"是一个类模板\",{\"1\":{\"83\":1}}],[\"是一个宏\",{\"1\":{\"80\":1}}],[\"是一个结构体\",{\"1\":{\"79\":1}}],[\"是一个加载操作\",{\"1\":{\"67\":1}}],[\"是一个存储操作\",{\"1\":{\"67\":1}}],[\"是一个\",{\"1\":{\"66\":1,\"67\":1}}],[\"是一个轻量同步原语\",{\"1\":{\"58\":1}}],[\"是一个古老而广泛应用的同步设施\",{\"1\":{\"58\":1}}],[\"是一个分数类模板\",{\"1\":{\"48\":1}}],[\"是一个数组对象\",{\"1\":{\"14\":1}}],[\"是一个整体\",{\"1\":{\"14\":1}}],[\"是一个函数类型\",{\"1\":{\"12\":1}}],[\"是一个返回类型为\",{\"1\":{\"12\":1}}],[\"是打印时间格式\",{\"1\":{\"15\":1}}],[\"是第一个被销毁的\",{\"1\":{\"13\":1}}],[\"是每个线程分配的任务\",{\"1\":{\"10\":1}}],[\"是当前硬件支持的并发线程的值\",{\"1\":{\"10\":1}}],[\"是\",{\"1\":{\"10\":1,\"12\":2,\"15\":1,\"31\":2,\"35\":1,\"49\":1,\"58\":1}}],[\"是很快的\",{\"1\":{\"5\":1}}],[\"定义一个信号量\",{\"1\":{\"58\":1}}],[\"定义一个函数用作打印任务\",{\"1\":{\"9\":1}}],[\"定义在\",{\"1\":{\"58\":1}}],[\"定义的\",{\"1\":{\"49\":1}}],[\"定义的别名\",{\"1\":{\"49\":1}}],[\"定义了一个元组类型\",{\"1\":{\"80\":1}}],[\"定义了一个别名\",{\"1\":{\"10\":1}}],[\"定义了很多种时间类型\",{\"1\":{\"48\":1}}],[\"定义\",{\"1\":{\"12\":1}}],[\"汇总线程的计算结果\",{\"1\":{\"10\":1,\"44\":1}}],[\"elif\",{\"1\":{\"65\":1}}],[\"else\",{\"1\":{\"21\":1,\"28\":2,\"65\":2,\"67\":2,\"80\":2,\"81\":1}}],[\"e\",{\"1\":{\"45\":4}}],[\"empty\",{\"1\":{\"41\":4}}],[\"emplace\",{\"1\":{\"10\":1,\"18\":2,\"25\":3,\"26\":2,\"44\":2,\"58\":1}}],[\"exit\",{\"1\":{\"80\":1}}],[\"exchang\",{\"1\":{\"67\":1}}],[\"exchanged\",{\"1\":{\"65\":3}}],[\"exchange\",{\"1\":{\"65\":8,\"67\":16,\"80\":2}}],[\"exception\",{\"1\":{\"33\":2,\"45\":15}}],[\"extensions\",{\"1\":{\"37\":1}}],[\"extern\",{\"1\":{\"32\":5}}],[\"explorer\",{\"1\":{\"74\":1}}],[\"explicit\",{\"1\":{\"13\":1,\"18\":2,\"21\":1,\"27\":1,\"80\":1,\"83\":6,\"84\":2}}],[\"expected↩︎\",{\"1\":{\"71\":1}}],[\"expected\",{\"1\":{\"67\":11,\"71\":1}}],[\"export\",{\"1\":{\"27\":1,\"83\":1}}],[\"errc\",{\"1\":{\"31\":2}}],[\"error\",{\"1\":{\"16\":1,\"31\":2,\"33\":1,\"43\":2,\"45\":3,\"80\":2}}],[\"erase\",{\"1\":{\"25\":1}}],[\"enable\",{\"1\":{\"21\":1,\"80\":1}}],[\"endif\",{\"1\":{\"65\":1,\"81\":1}}],[\"end\",{\"1\":{\"10\":7,\"27\":2,\"34\":1,\"44\":4,\"50\":2,\"71\":4}}],[\"endl\",{\"1\":{\"9\":2,\"15\":3,\"21\":1,\"28\":3,\"35\":2,\"40\":1,\"41\":2,\"45\":1,\"46\":8,\"58\":1,\"65\":8}}],[\"创建的索引形参包\",{\"1\":{\"80\":1}}],[\"创建控件\",{\"1\":{\"54\":1}}],[\"创建一个\",{\"1\":{\"45\":1,\"65\":1}}],[\"创建一个线程来执行异步任务\",{\"1\":{\"44\":1}}],[\"创建线程执行异步任务\",{\"1\":{\"43\":1}}],[\"创建线程对象\",{\"1\":{\"12\":1}}],[\"创建异步任务获取返回值\",{\"0\":{\"43\":1}}],[\"创建了一个独占指针\",{\"1\":{\"80\":1}}],[\"创建了一个条件变量\",{\"1\":{\"40\":1}}],[\"创建了一个互斥量\",{\"1\":{\"40\":1}}],[\"创建了一个块作用域\",{\"1\":{\"27\":1}}],[\"创建了一个线程对象\",{\"1\":{\"9\":1}}],[\"创建局部对象\",{\"1\":{\"12\":1}}],[\"创建并启动线程\",{\"1\":{\"10\":1}}],[\">addwidget\",{\"1\":{\"54\":3}}],[\">setlayout\",{\"1\":{\"54\":1}}],[\">setsizepolicy\",{\"1\":{\"54\":2}}],[\">setstylesheet\",{\"1\":{\"54\":3}}],[\">setmaximumwidth\",{\"1\":{\"54\":2}}],[\">setminimumsize\",{\"1\":{\"54\":2}}],[\">setvalue\",{\"1\":{\"52\":1,\"54\":1}}],[\">settext\",{\"1\":{\"52\":2,\"54\":2}}],[\">setrange\",{\"1\":{\"52\":1,\"54\":2}}],[\">setenabled\",{\"1\":{\"52\":2,\"54\":2}}],[\">second\",{\"1\":{\"34\":1}}],[\">>\",{\"1\":{\"44\":1}}],[\">>tasks\",{\"1\":{\"44\":1}}],[\">unlock\",{\"1\":{\"31\":1}}],[\">lock\",{\"1\":{\"31\":2}}],[\">do\",{\"1\":{\"29\":1,\"33\":3}}],[\">=\",{\"1\":{\"10\":1}}],[\">\",{\"1\":{\"10\":1,\"21\":1,\"35\":2,\"44\":9,\"50\":1,\"67\":1,\"80\":9,\"83\":2,\"84\":2}}],[\"parent\",{\"1\":{\"54\":3}}],[\"package\",{\"1\":{\"44\":1,\"62\":1}}],[\"packaged\",{\"1\":{\"44\":14}}],[\"period>>\",{\"1\":{\"49\":3}}],[\"period\",{\"1\":{\"48\":2,\"49\":1}}],[\"permitted\",{\"1\":{\"31\":1}}],[\"pointer\",{\"1\":{\"65\":1}}],[\"point<std\",{\"1\":{\"50\":2}}],[\"point<>\",{\"1\":{\"50\":1}}],[\"point\",{\"1\":{\"47\":1,\"48\":2,\"50\":2}}],[\"pow\",{\"1\":{\"44\":3}}],[\"pop\",{\"1\":{\"41\":20}}],[\"posix\",{\"1\":{\"21\":1,\"37\":3,\"56\":1,\"59\":1,\"74\":1,\"81\":1}}],[\"pmtx\",{\"1\":{\"31\":5,\"32\":3}}],[\"ptr>\",{\"1\":{\"62\":1}}],[\"ptr<\",{\"1\":{\"80\":1}}],[\"ptr<t>res\",{\"1\":{\"41\":1}}],[\"ptr<t>\",{\"1\":{\"41\":1}}],[\"ptr<some>ptr\",{\"1\":{\"33\":1}}],[\"ptr\",{\"1\":{\"33\":8,\"41\":1,\"42\":2,\"45\":1,\"46\":3,\"62\":3}}],[\"ptrdiff\",{\"1\":{\"10\":1,\"44\":1,\"60\":1,\"62\":1}}],[\"pthreads\",{\"1\":{\"37\":1}}],[\"pthread\",{\"1\":{\"21\":2,\"37\":4,\"56\":1,\"66\":1}}],[\"push\",{\"1\":{\"27\":2,\"41\":15}}],[\"put\",{\"1\":{\"15\":3,\"48\":2}}],[\"puts\",{\"1\":{\"13\":1,\"14\":2,\"43\":2,\"75\":2}}],[\"public\",{\"1\":{\"12\":1,\"13\":1,\"18\":1,\"27\":1,\"29\":2,\"34\":1,\"41\":1,\"54\":2,\"66\":1,\"81\":1,\"83\":3}}],[\"p\",{\"1\":{\"12\":3,\"14\":4,\"29\":3,\"36\":11,\"43\":4,\"46\":1}}],[\"pred\",{\"1\":{\"40\":2}}],[\"predicate\",{\"1\":{\"40\":1}}],[\"predicate>\",{\"1\":{\"40\":1}}],[\"procedure\",{\"1\":{\"80\":1}}],[\"processing\",{\"1\":{\"58\":2}}],[\"process\",{\"1\":{\"29\":4,\"32\":3}}],[\"proc\",{\"1\":{\"58\":2,\"80\":5}}],[\"progress\",{\"1\":{\"53\":2,\"54\":16}}],[\"progressbar\",{\"1\":{\"52\":2}}],[\"prom\",{\"1\":{\"45\":12}}],[\"promise<std\",{\"1\":{\"46\":1}}],[\"promise<int>\",{\"1\":{\"45\":6}}],[\"promised<int>\",{\"1\":{\"45\":1}}],[\"promise只能移动\",{\"1\":{\"45\":1}}],[\"promiseobj\",{\"1\":{\"45\":2}}],[\"promise\",{\"1\":{\"45\":16,\"46\":1,\"62\":1}}],[\"producer\",{\"1\":{\"41\":7}}],[\"protected\",{\"1\":{\"29\":2}}],[\"print\",{\"1\":{\"27\":8,\"37\":3,\"71\":2}}],[\"private\",{\"1\":{\"27\":1,\"30\":1,\"31\":1,\"34\":1,\"54\":1,\"79\":1,\"83\":2}}],[\"pr\",{\"1\":{\"0\":1,\"76\":1}}],[\"visual\",{\"1\":{\"53\":1}}],[\"variable>\",{\"1\":{\"40\":1}}],[\"variable\",{\"1\":{\"40\":11,\"41\":1,\"47\":1,\"50\":1}}],[\"valid\",{\"1\":{\"43\":3,\"46\":1}}],[\"validate\",{\"1\":{\"31\":3}}],[\"value++\",{\"1\":{\"21\":1}}],[\"value\",{\"1\":{\"10\":10,\"21\":1,\"34\":2,\"41\":8,\"44\":9,\"45\":9,\"65\":10,\"67\":2}}],[\"v\",{\"1\":{\"25\":6,\"36\":2,\"78\":1}}],[\"v<std\",{\"1\":{\"84\":1}}],[\"v<\",{\"1\":{\"80\":1}}],[\"v<decay\",{\"1\":{\"21\":1}}],[\"v<remove\",{\"1\":{\"21\":1}}],[\"vector\",{\"1\":{\"18\":1,\"25\":3}}],[\"vector<int>\",{\"1\":{\"27\":1}}],[\"vector<int>v\",{\"1\":{\"25\":1}}],[\"vector<joining\",{\"1\":{\"18\":1}}],[\"vector<std\",{\"1\":{\"10\":1,\"18\":1,\"26\":2,\"44\":5,\"58\":1}}],[\"vector<value\",{\"1\":{\"10\":1}}],[\"void没办法获取返回值\",{\"1\":{\"44\":1}}],[\"void\",{\"1\":{\"9\":1,\"12\":6,\"13\":1,\"14\":14,\"16\":1,\"18\":4,\"21\":2,\"25\":4,\"26\":2,\"27\":4,\"28\":1,\"29\":4,\"30\":6,\"31\":4,\"32\":1,\"33\":4,\"34\":1,\"35\":2,\"36\":4,\"37\":1,\"40\":6,\"41\":4,\"43\":7,\"44\":1,\"45\":3,\"52\":1,\"54\":1,\"58\":2,\"60\":1,\"64\":2,\"66\":3,\"67\":1,\"79\":1,\"80\":6,\"81\":1,\"83\":1,\"84\":6}}],[\"ullong\",{\"1\":{\"65\":1}}],[\"ulong\",{\"1\":{\"65\":1}}],[\"user\",{\"1\":{\"66\":1,\"80\":1}}],[\"use\",{\"1\":{\"66\":1}}],[\"ushort\",{\"1\":{\"65\":1}}],[\"using\",{\"1\":{\"10\":1,\"15\":1,\"21\":1,\"27\":1,\"44\":1,\"49\":12,\"50\":1,\"58\":1,\"65\":11,\"79\":1,\"80\":2,\"81\":2,\"83\":1}}],[\"uchar\",{\"1\":{\"65\":1}}],[\"u\",{\"1\":{\"65\":1}}],[\"uint\",{\"1\":{\"65\":1}}],[\"ui\",{\"1\":{\"51\":3,\"52\":4,\"53\":1,\"54\":4,\"57\":2,\"62\":1,\"74\":1}}],[\"unavailable\",{\"1\":{\"80\":2}}],[\"unless\",{\"1\":{\"66\":1}}],[\"unlocks\",{\"1\":{\"27\":1,\"83\":1}}],[\"unlock\",{\"1\":{\"26\":3,\"27\":4,\"28\":1,\"30\":1,\"31\":5,\"32\":1,\"35\":6,\"40\":3,\"66\":2,\"83\":2,\"84\":4}}],[\"unlocked\",{\"1\":{\"26\":1}}],[\"uniform\",{\"1\":{\"58\":1}}],[\"unique<\",{\"1\":{\"80\":2}}],[\"unique\",{\"1\":{\"31\":13,\"32\":12,\"34\":1,\"35\":1,\"40\":7,\"41\":2,\"42\":1,\"46\":1,\"50\":1,\"80\":2}}],[\"until\",{\"1\":{\"15\":6,\"47\":3,\"50\":2}}],[\"unsigned\",{\"1\":{\"10\":1,\"56\":1,\"65\":1,\"79\":1,\"80\":1}}],[\"llong\",{\"1\":{\"65\":3}}],[\"leastmaxvalue\",{\"1\":{\"58\":3}}],[\"loadedvalue\",{\"1\":{\"65\":3}}],[\"load\",{\"1\":{\"65\":7,\"67\":7}}],[\"loop\",{\"1\":{\"50\":1}}],[\"long>\",{\"1\":{\"49\":1,\"65\":3}}],[\"long\",{\"1\":{\"49\":3,\"50\":1,\"65\":5}}],[\"local\",{\"1\":{\"37\":13}}],[\"local关键字\",{\"1\":{\"37\":1}}],[\"localtime\",{\"1\":{\"15\":3,\"48\":2}}],[\"lock<>\",{\"1\":{\"83\":2}}],[\"lock<\",{\"1\":{\"83\":1}}],[\"lock<std\",{\"1\":{\"27\":1,\"31\":5,\"32\":3,\"34\":2,\"40\":7,\"41\":2,\"50\":1,\"83\":2,\"84\":1}}],[\"lock2\",{\"1\":{\"30\":2,\"31\":2}}],[\"lock1\",{\"1\":{\"30\":2,\"31\":2}}],[\"locked\",{\"1\":{\"26\":1,\"31\":1,\"35\":2}}],[\"lock\",{\"0\":{\"82\":1},\"1\":{\"1\":1,\"26\":6,\"27\":35,\"28\":4,\"29\":3,\"30\":24,\"31\":41,\"32\":12,\"33\":1,\"34\":5,\"35\":9,\"38\":1,\"40\":7,\"41\":2,\"64\":1,\"65\":22,\"66\":3,\"82\":2,\"83\":36,\"84\":17,\"85\":1}}],[\"lk\",{\"1\":{\"32\":5,\"33\":1,\"40\":4,\"41\":2,\"50\":2}}],[\"lhs\",{\"1\":{\"30\":15,\"31\":4}}],[\"lc3\",{\"1\":{\"83\":1}}],[\"lck\",{\"1\":{\"40\":5}}],[\"lc2\",{\"1\":{\"30\":2}}],[\"lc1\",{\"1\":{\"30\":2}}],[\"lc\",{\"1\":{\"27\":6,\"29\":1,\"35\":1,\"64\":1,\"66\":1,\"84\":1}}],[\"likelihood\",{\"1\":{\"66\":1}}],[\"linus\",{\"1\":{\"66\":1}}],[\"linux\",{\"1\":{\"56\":1}}],[\"lightgrey\",{\"1\":{\"54\":1}}],[\"list<int>\",{\"1\":{\"27\":3}}],[\"list\",{\"1\":{\"27\":28}}],[\"library\",{\"1\":{\"21\":1}}],[\"libc++的实现\",{\"1\":{\"82\":1}}],[\"libc++\",{\"1\":{\"20\":1,\"21\":2,\"66\":1,\"74\":1,\"81\":1,\"84\":1}}],[\"libstdc++\",{\"1\":{\"20\":1,\"21\":1,\"66\":1,\"74\":1,\"81\":2,\"82\":1,\"84\":1}}],[\"literals\",{\"1\":{\"15\":2,\"21\":2,\"49\":2,\"50\":1}}],[\"latch\",{\"1\":{\"59\":2,\"60\":5}}],[\"layout\",{\"1\":{\"54\":5}}],[\"launch\",{\"1\":{\"43\":10,\"46\":2,\"49\":1,\"52\":1,\"54\":1,\"55\":1}}],[\"lambda\",{\"1\":{\"12\":2,\"44\":3,\"46\":2,\"55\":1}}],[\"last\",{\"1\":{\"10\":5,\"44\":3}}],[\"物理核心这个通常不看重\",{\"1\":{\"10\":1}}],[\"66\",{\"1\":{\"84\":1}}],[\"60\",{\"1\":{\"48\":1,\"65\":1}}],[\"64\",{\"1\":{\"20\":1,\"81\":1}}],[\"6\",{\"1\":{\"10\":2,\"49\":1}}],[\"有四个构造函数\",{\"1\":{\"80\":1}}],[\"有限的特性使得\",{\"1\":{\"66\":1}}],[\"有可能不会是\",{\"1\":{\"50\":1}}],[\"有可能函数\",{\"1\":{\"30\":1}}],[\"有一个\",{\"1\":{\"46\":1}}],[\"有一个玩具\",{\"1\":{\"30\":1}}],[\"有时可以通过改变数据结构来避免对原子操作的依赖\",{\"1\":{\"65\":1}}],[\"有时候线程可能会在没有收到通知的情况下被唤醒\",{\"1\":{\"40\":1}}],[\"有时这是无法避免的\",{\"1\":{\"30\":1}}],[\"有特殊需求\",{\"1\":{\"40\":1}}],[\"有兴趣参见我们的链接即可\",{\"1\":{\"37\":1}}],[\"有它的定义\",{\"1\":{\"32\":1}}],[\"有疑问\",{\"1\":{\"32\":1}}],[\"有些人可能喜欢称作\",{\"1\":{\"38\":1}}],[\"有些人认为二者大多数时候是相同的\",{\"1\":{\"6\":1}}],[\"有些人认为二者毫无关系\",{\"1\":{\"6\":1}}],[\"有些时候\",{\"1\":{\"32\":1}}],[\"有两个小孩\",{\"1\":{\"30\":1}}],[\"有的时候只需要一个指针或者引用\",{\"1\":{\"29\":1}}],[\"有数据竞争\",{\"1\":{\"25\":1}}],[\"有点像外部给线程传递信号一样\",{\"1\":{\"21\":1}}],[\"有\",{\"1\":{\"10\":1}}],[\"17\",{\"1\":{\"78\":1}}],[\"1h\",{\"1\":{\"49\":1}}],[\"1min\",{\"1\":{\"49\":1}}],[\"1ms\",{\"1\":{\"49\":1}}],[\"1s\",{\"1\":{\"49\":1}}],[\"1us\",{\"1\":{\"49\":1}}],[\"1ns\",{\"1\":{\"49\":1}}],[\"1>\",{\"1\":{\"48\":1}}],[\"15\",{\"1\":{\"21\":1}}],[\"16\",{\"1\":{\"20\":2,\"31\":1,\"79\":2}}],[\"10px\",{\"1\":{\"54\":1}}],[\"10ms\",{\"1\":{\"52\":1,\"54\":1}}],[\"1024\",{\"1\":{\"14\":3,\"75\":1}}],[\"1024000\",{\"1\":{\"10\":2,\"44\":1}}],[\"1000\",{\"1\":{\"50\":1,\"52\":2,\"54\":3}}],[\"10000000>>\",{\"1\":{\"50\":1}}],[\"1000>\",{\"1\":{\"49\":1}}],[\"100\",{\"1\":{\"12\":2,\"28\":1,\"40\":1,\"45\":3,\"50\":1,\"54\":4}}],[\"10\",{\"1\":{\"10\":1,\"12\":3,\"13\":1,\"18\":3,\"26\":2,\"43\":3,\"44\":3,\"47\":2,\"58\":2,\"65\":1}}],[\"1\",{\"1\":{\"10\":5,\"12\":5,\"14\":3,\"16\":3,\"21\":3,\"25\":1,\"26\":1,\"27\":1,\"28\":3,\"30\":3,\"33\":1,\"35\":4,\"36\":2,\"37\":1,\"40\":3,\"41\":5,\"43\":1,\"44\":1,\"45\":1,\"46\":3,\"48\":3,\"50\":1,\"58\":2,\"60\":1,\"62\":1,\"65\":2,\"67\":1,\"71\":1,\"81\":1}}],[\"14px\",{\"1\":{\"54\":1}}],[\"14\",{\"1\":{\"10\":1}}],[\"13700h\",{\"1\":{\"10\":1}}],[\"123\",{\"1\":{\"47\":1,\"49\":2}}],[\"12\",{\"1\":{\"10\":1}}],[\"混合设计架构\",{\"1\":{\"10\":1}}],[\"大约\",{\"1\":{\"21\":1}}],[\"大小为\",{\"1\":{\"20\":1}}],[\"大小核\",{\"1\":{\"10\":1}}],[\"大多数时候它是合适的\",{\"1\":{\"12\":1}}],[\"大家可以打开自己电脑的任务管理器看一眼\",{\"1\":{\"5\":1}}],[\"代表这些任务就是在主线程\",{\"1\":{\"54\":1}}],[\"代酷睿开始\",{\"1\":{\"10\":1}}],[\"代码进行讲解\",{\"1\":{\"78\":1,\"82\":1}}],[\"代码风格\",{\"0\":{\"75\":1}}],[\"代码后如下\",{\"1\":{\"30\":1}}],[\"代码创建了一个调用\",{\"1\":{\"14\":1}}],[\"代码\",{\"1\":{\"0\":1}}],[\"英特尔从\",{\"1\":{\"10\":1}}],[\"英特尔®\",{\"1\":{\"10\":1}}],[\"年了\",{\"1\":{\"10\":1}}],[\"都没这样做\",{\"1\":{\"84\":1}}],[\"都进行零初始化\",{\"1\":{\"80\":1}}],[\"都有一个内存序参数\",{\"1\":{\"65\":1}}],[\"都提供了函数\",{\"1\":{\"48\":1}}],[\"都会返回\",{\"1\":{\"43\":1}}],[\"都声明在\",{\"1\":{\"42\":1}}],[\"都只能单独执行\",{\"1\":{\"41\":1}}],[\"都要进行读取\",{\"1\":{\"34\":1}}],[\"都以\",{\"1\":{\"31\":1}}],[\"都与线程对象关联\",{\"1\":{\"22\":1}}],[\"都能正常析构\",{\"1\":{\"16\":1}}],[\"都基于这个类\",{\"1\":{\"15\":1}}],[\"都被销毁了\",{\"1\":{\"12\":1}}],[\"都\",{\"1\":{\"10\":1}}],[\"都并行\",{\"1\":{\"5\":1}}],[\"个字节\",{\"1\":{\"79\":1}}],[\"个同时访问者\",{\"1\":{\"58\":1}}],[\"个同时的访问者\",{\"1\":{\"58\":1}}],[\"个并发请求\",{\"1\":{\"58\":1}}],[\"个并发线程\",{\"1\":{\"10\":1}}],[\"个\",{\"1\":{\"58\":1}}],[\"个节拍\",{\"1\":{\"48\":1}}],[\"个线程\",{\"1\":{\"18\":1}}],[\"个线程执行\",{\"1\":{\"10\":1}}],[\"个元素被分配给了前两个线程\",{\"1\":{\"10\":1}}],[\"个性能核\",{\"1\":{\"10\":1}}],[\"个能效核\",{\"1\":{\"10\":1}}],[\"个任务分配三个线程\",{\"1\":{\"10\":1}}],[\"个任务\",{\"1\":{\"10\":1}}],[\"8\",{\"1\":{\"10\":4,\"20\":3,\"79\":1,\"81\":2}}],[\"核心\",{\"1\":{\"10\":2}}],[\"一定要会使用\",{\"1\":{\"84\":1}}],[\"一定时间内没有连接到服务器就不会继续阻塞了\",{\"1\":{\"47\":1}}],[\"一般初始化时使用\",{\"1\":{\"75\":1}}],[\"一般最好使用\",{\"1\":{\"66\":1}}],[\"一般不建议指出\",{\"1\":{\"33\":1}}],[\"一种是\",{\"1\":{\"47\":1}}],[\"一种可能的使用是允许函数去锁住一个互斥量\",{\"1\":{\"32\":1}}],[\"一起使用\",{\"1\":{\"44\":1}}],[\"一起出现\",{\"1\":{\"34\":1}}],[\"一旦条件满足\",{\"1\":{\"40\":1}}],[\"一直不休息\",{\"1\":{\"40\":1}}],[\"一样错误\",{\"1\":{\"43\":1}}],[\"一样\",{\"1\":{\"43\":2,\"46\":1}}],[\"一样使用\",{\"1\":{\"31\":1}}],[\"一样只是多了复制\",{\"1\":{\"14\":1}}],[\"一切最终都是依靠开发者使用与管理\",{\"1\":{\"30\":1}}],[\"一个可调用\",{\"1\":{\"84\":1}}],[\"一个静态函数指针\",{\"1\":{\"80\":1}}],[\"一个常见的例子是在很多网络库中的\",{\"1\":{\"47\":1}}],[\"一个异常\",{\"1\":{\"45\":3}}],[\"一个操作完成后才能开始下一个操作\",{\"1\":{\"39\":1}}],[\"一个直观的展示是\",{\"1\":{\"36\":1}}],[\"一个线程\",{\"1\":{\"41\":1}}],[\"一个线程会尝试在释放一个互斥量前多次获取\",{\"1\":{\"35\":1}}],[\"一个线程知道另一个线程已经在执行③\",{\"1\":{\"33\":1}}],[\"一个互斥量的指针\",{\"1\":{\"31\":1}}],[\"一个引用\",{\"1\":{\"27\":1}}],[\"一个冲突的求值发生早于\",{\"1\":{\"25\":1}}],[\"一个删除元素\",{\"1\":{\"25\":1}}],[\"一次是调用函数\",{\"1\":{\"14\":1}}],[\"一次是被\",{\"1\":{\"14\":1}}],[\"一款\",{\"1\":{\"10\":1}}],[\"一些当前线程可能抛出异常的代码\",{\"1\":{\"12\":3}}],[\"一些老式特殊情况不聊\",{\"1\":{\"12\":1}}],[\"一些古老的书籍比如\",{\"1\":{\"10\":1}}],[\"一些单核机器\",{\"1\":{\"5\":1}}],[\"apply\",{\"1\":{\"83\":1,\"84\":8}}],[\"api\",{\"1\":{\"37\":1,\"56\":1,\"59\":1,\"74\":1}}],[\"abi\",{\"1\":{\"80\":1}}],[\"at\",{\"1\":{\"80\":1}}],[\"atomic类型\",{\"1\":{\"67\":1}}],[\"atomic<t\",{\"1\":{\"67\":1}}],[\"atomic<trivial\",{\"1\":{\"65\":2}}],[\"atomic<bool>b\",{\"1\":{\"67\":1}}],[\"atomic<bool>\",{\"1\":{\"65\":1,\"66\":1,\"67\":11}}],[\"atomic<long\",{\"1\":{\"65\":1}}],[\"atomic<long>\",{\"1\":{\"65\":1}}],[\"atomic<unsigned\",{\"1\":{\"65\":5}}],[\"atomic<char>\",{\"1\":{\"65\":1}}],[\"atomic<int>\",{\"1\":{\"65\":6}}],[\"atomic<short>\",{\"1\":{\"65\":1}}],[\"atomic<shared\",{\"1\":{\"62\":1}}],[\"atomic<signed\",{\"1\":{\"65\":1}}],[\"atomic<std\",{\"1\":{\"62\":1}}],[\"atomic\",{\"1\":{\"25\":1,\"64\":1,\"65\":45,\"66\":20,\"67\":3}}],[\"avoid\",{\"1\":{\"80\":1}}],[\"again\",{\"1\":{\"80\":2}}],[\"await\",{\"1\":{\"72\":1}}],[\"aware\",{\"1\":{\"66\":1}}],[\"as\",{\"1\":{\"71\":1}}],[\"assignable<trivial\",{\"1\":{\"65\":2}}],[\"assert\",{\"1\":{\"65\":5}}],[\"async\",{\"0\":{\"86\":1},\"1\":{\"1\":1,\"43\":27,\"44\":2,\"46\":4,\"49\":2,\"52\":2,\"53\":2,\"54\":8,\"55\":2}}],[\"are\",{\"1\":{\"66\":1}}],[\"arrival\",{\"1\":{\"40\":6}}],[\"arrived\",{\"1\":{\"40\":9}}],[\"args\",{\"1\":{\"18\":3,\"21\":2,\"44\":4,\"80\":6}}],[\"args>\",{\"1\":{\"18\":1,\"21\":3,\"44\":1,\"80\":6}}],[\"any\",{\"1\":{\"40\":7}}],[\"and\",{\"1\":{\"21\":2,\"27\":1,\"66\":7,\"67\":1,\"83\":2,\"84\":1}}],[\"always\",{\"1\":{\"65\":6}}],[\"alignhcenter\",{\"1\":{\"54\":2}}],[\"align\",{\"1\":{\"54\":2}}],[\"aligned\",{\"1\":{\"36\":1}}],[\"already\",{\"1\":{\"45\":2}}],[\"alloc\",{\"1\":{\"36\":1}}],[\"adl\",{\"1\":{\"80\":1}}],[\"adapt\",{\"1\":{\"80\":1}}],[\"addressof\",{\"1\":{\"31\":1}}],[\"add\",{\"1\":{\"27\":6,\"65\":1}}],[\"adopt\",{\"1\":{\"27\":2,\"30\":3,\"31\":5,\"83\":3,\"84\":3}}],[\"ax\",{\"1\":{\"21\":3,\"80\":5}}],[\"after\",{\"1\":{\"15\":1}}],[\"a的引用只能引用a\",{\"1\":{\"14\":1}}],[\"a\",{\"1\":{\"14\":8,\"27\":6,\"29\":1,\"30\":10,\"44\":8,\"64\":8,\"65\":2}}],[\"actually\",{\"1\":{\"66\":1}}],[\"acq\",{\"1\":{\"65\":1,\"67\":1}}],[\"acquire\",{\"1\":{\"58\":7,\"65\":2,\"66\":1,\"67\":3}}],[\"acquisition\",{\"1\":{\"13\":1}}],[\"accumulate\",{\"1\":{\"10\":4,\"27\":1,\"44\":2}}],[\"auto\",{\"1\":{\"10\":6,\"15\":4,\"18\":1,\"25\":1,\"26\":2,\"27\":1,\"34\":1,\"43\":8,\"44\":4,\"48\":2,\"49\":7,\"50\":4,\"54\":1,\"67\":1,\"80\":5,\"84\":4}}],[\"amd\",{\"1\":{\"10\":1}}],[\"更新和用户交互\",{\"1\":{\"51\":1}}],[\"更多的是一些风格上的\",{\"1\":{\"82\":1}}],[\"更多的问题参见源码都很直观\",{\"1\":{\"50\":1}}],[\"更多的线程意味着可以并行完成更多的工作\",{\"1\":{\"10\":1}}],[\"更换为\",{\"1\":{\"40\":1}}],[\"更加灵活\",{\"1\":{\"31\":1}}],[\"更加的灵活\",{\"1\":{\"31\":1}}],[\"更加注重性能\",{\"1\":{\"6\":1}}],[\"更好\",{\"1\":{\"30\":1}}],[\"支持任意可调用\",{\"1\":{\"43\":1}}],[\"支持的形式还有很多\",{\"1\":{\"12\":1}}],[\"支持\",{\"1\":{\"10\":1}}],[\"==\",{\"1\":{\"30\":3,\"31\":1,\"46\":1,\"49\":2,\"50\":1,\"65\":2}}],[\"=delete\",{\"1\":{\"13\":1}}],[\"=\",{\"1\":{\"10\":19,\"12\":4,\"13\":3,\"14\":12,\"15\":6,\"16\":4,\"18\":4,\"21\":1,\"25\":2,\"26\":2,\"27\":4,\"29\":2,\"31\":3,\"32\":2,\"33\":1,\"34\":3,\"36\":5,\"37\":4,\"40\":4,\"41\":3,\"43\":13,\"44\":16,\"45\":5,\"46\":4,\"48\":5,\"49\":20,\"50\":5,\"52\":3,\"54\":9,\"58\":3,\"64\":1,\"65\":20,\"66\":4,\"67\":12,\"71\":1,\"75\":3,\"79\":1,\"80\":13,\"81\":2,\"83\":8}}],[\"hnd\",{\"1\":{\"79\":2,\"80\":7}}],[\"has\",{\"1\":{\"81\":2}}],[\"handle\",{\"1\":{\"58\":3,\"79\":1,\"80\":1,\"81\":2}}],[\"hardware\",{\"1\":{\"10\":5,\"44\":1}}],[\"hour\",{\"1\":{\"49\":1}}],[\"hours\",{\"1\":{\"49\":2}}],[\"h\",{\"1\":{\"12\":2,\"15\":3,\"48\":2,\"53\":1}}],[\"hello\",{\"0\":{\"9\":1},\"1\":{\"9\":8,\"10\":1,\"12\":1,\"14\":2}}],[\"当标志对象已初始化\",{\"1\":{\"66\":1}}],[\"当不要求截断值的情况下\",{\"1\":{\"49\":1}}],[\"当一个时钟的时钟节拍每\",{\"1\":{\"48\":1}}],[\"当我们想要获取任务的返回值的时候\",{\"1\":{\"44\":1}}],[\"当我们使用函数对象用于构造\",{\"1\":{\"12\":1}}],[\"当需要任务执行完的结果的时候\",{\"1\":{\"43\":1}}],[\"当多个线程等待相同事件的结果时\",{\"1\":{\"46\":1}}],[\"当多个线程需要访问一个独立\",{\"1\":{\"42\":1}}],[\"当多个线程执行函数\",{\"1\":{\"26\":1}}],[\"当队列为空时\",{\"1\":{\"41\":2}}],[\"当执行\",{\"1\":{\"41\":1}}],[\"当条件不满足时\",{\"1\":{\"40\":1}}],[\"当同一线程多次对同一个\",{\"1\":{\"35\":1}}],[\"当获取锁后会再检查一次指针②\",{\"1\":{\"33\":1}}],[\"当它无法满足你的需求或者显得代码非常繁琐\",{\"1\":{\"31\":1}}],[\"当运行\",{\"1\":{\"31\":1}}],[\"当然\",{\"1\":{\"31\":1,\"32\":1}}],[\"当然了\",{\"1\":{\"10\":1,\"12\":1,\"14\":1,\"25\":1}}],[\"当写通用代码时\",{\"1\":{\"30\":1}}],[\"当有多个互斥量保护同一个类的对象时\",{\"1\":{\"30\":1}}],[\"当另一个小孩也想玩\",{\"1\":{\"30\":1}}],[\"当其中一个小孩拿到了遥控器和玩具车时\",{\"1\":{\"30\":1}}],[\"当某个表达式的求值写入某个内存位置\",{\"1\":{\"25\":1}}],[\"当两个线程同时尝试向\",{\"1\":{\"25\":1}}],[\"当你调用\",{\"1\":{\"21\":1}}],[\"当你看完\",{\"1\":{\"17\":1}}],[\"当取消被执行时\",{\"1\":{\"21\":1}}],[\"当前原子对象的值为\",{\"1\":{\"67\":1}}],[\"当前值与预期一致时\",{\"1\":{\"67\":1}}],[\"当前时间可以通过静态成员函数\",{\"1\":{\"48\":1}}],[\"当前时间\",{\"1\":{\"48\":1}}],[\"当前是否关联共享状态\",{\"1\":{\"43\":1}}],[\"当前持有线程资源\",{\"1\":{\"16\":1}}],[\"当前没有关联活跃线程\",{\"1\":{\"16\":1}}],[\"当前关联了活跃线程\",{\"1\":{\"16\":1}}],[\"当前环境\",{\"1\":{\"65\":2}}],[\"当前环境核心越多数据越多\",{\"1\":{\"10\":1}}],[\"当前环境支持并发线程数\",{\"0\":{\"10\":1}}],[\"当异常抛出时\",{\"1\":{\"13\":1}}],[\"当\",{\"1\":{\"10\":3,\"12\":1,\"15\":1,\"40\":1,\"66\":1}}],[\"当关注重点在于任务分离或任务响应时\",{\"1\":{\"6\":1}}],[\"其线程调用\",{\"1\":{\"66\":1}}],[\"其它同步机制\",{\"1\":{\"65\":1}}],[\"其它方面就得自己保证了\",{\"1\":{\"36\":1}}],[\"其\",{\"1\":{\"58\":1}}],[\"其所有权可以在不同的对象中互相传递\",{\"1\":{\"46\":1}}],[\"其返回值或所抛异常被存储于能通过\",{\"1\":{\"44\":1}}],[\"其中的数据成员也是不同的\",{\"1\":{\"83\":1}}],[\"其中的重中之重就是它的构造\",{\"1\":{\"17\":1}}],[\"其中有一段话说得很直接\",{\"1\":{\"66\":1}}],[\"其中不同的任务或操作按顺序执行\",{\"1\":{\"39\":1}}],[\"其中每个线程都有一个互斥量\",{\"1\":{\"30\":1}}],[\"其他所有的线程\",{\"1\":{\"26\":1}}],[\"其相当于实现了一个公共的\",{\"1\":{\"26\":1}}],[\"其主要在于\",{\"1\":{\"22\":1}}],[\"其次是\",{\"1\":{\"15\":1}}],[\"其局部对象正常析构释放\",{\"1\":{\"12\":1}}],[\"其实这很简单\",{\"1\":{\"85\":1}}],[\"其实并不是什么复杂的东西\",{\"1\":{\"66\":1}}],[\"其实不算难\",{\"1\":{\"84\":1}}],[\"其实不同无非是定义了\",{\"1\":{\"44\":1}}],[\"其实不用感到奇怪\",{\"1\":{\"32\":1}}],[\"其实\",{\"1\":{\"44\":1}}],[\"其实到此基本就差不多了\",{\"1\":{\"43\":1}}],[\"其实第一种方法就是在说\",{\"1\":{\"40\":1}}],[\"其实也还是别名罢了\",{\"1\":{\"49\":1}}],[\"其实也很简单\",{\"1\":{\"35\":1}}],[\"其实也就是回到了第一个示例的问题\",{\"1\":{\"30\":1}}],[\"其实也就是指管理\",{\"1\":{\"11\":1}}],[\"其实也就是要\",{\"1\":{\"10\":1}}],[\"其实还有不少其他的做法或者反例\",{\"1\":{\"33\":1}}],[\"其实理论上你\",{\"1\":{\"32\":1}}],[\"其实只是传递了它们的指针或者引用罢了\",{\"1\":{\"32\":2}}],[\"其实倒也还好\",{\"1\":{\"31\":1}}],[\"其实上面的代码还不够简单直接\",{\"1\":{\"31\":1}}],[\"其实简单来说\",{\"1\":{\"21\":1}}],[\"其实就是把元组给解包了\",{\"1\":{\"84\":1}}],[\"其实就是先前讲的\",{\"1\":{\"47\":1}}],[\"其实就是在传递可调用对象与参数之前传递枚举值罢了\",{\"1\":{\"43\":1}}],[\"其实就是线程对象自己调用\",{\"1\":{\"21\":1}}],[\"其实就是\",{\"1\":{\"14\":1}}],[\"其实可以直接简单理解为\",{\"1\":{\"3\":1}}],[\"其成员函数也很少\",{\"1\":{\"9\":1}}],[\"高度封装\",{\"1\":{\"9\":1}}],[\"如内存访问的优化\",{\"1\":{\"71\":1}}],[\"如读写锁\",{\"1\":{\"65\":1}}],[\"如互斥量\",{\"1\":{\"64\":1}}],[\"如上\",{\"1\":{\"49\":1}}],[\"如同规则\",{\"1\":{\"71\":1}}],[\"如同没有线程资源所有权的\",{\"1\":{\"43\":1}}],[\"如同第一个示例那样\",{\"1\":{\"30\":1}}],[\"如下\",{\"1\":{\"31\":1,\"41\":1,\"80\":1}}],[\"如何创建的线程\",{\"1\":{\"17\":1}}],[\"如何做到接受任意可调用对象\",{\"1\":{\"17\":1}}],[\"如何支持只能移动的对象\",{\"1\":{\"17\":1}}],[\"如\",{\"1\":{\"17\":1,\"50\":1,\"65\":1,\"75\":1,\"78\":1}}],[\"如你所见它的形参类型是\",{\"1\":{\"80\":1}}],[\"如你所见很简单\",{\"1\":{\"31\":1}}],[\"如你所见\",{\"1\":{\"9\":1,\"31\":2,\"43\":3,\"48\":1,\"50\":1,\"65\":1,\"80\":1,\"85\":1}}],[\"如果线程启动失败\",{\"1\":{\"80\":1}}],[\"如果线程句柄\",{\"1\":{\"80\":1}}],[\"如果相等则将其更新为新值并返回\",{\"1\":{\"67\":1}}],[\"如果原子变量的赋值操作返回了一个引用\",{\"1\":{\"67\":1}}],[\"如果发现某些原子类型在目标平台上是有锁的\",{\"1\":{\"65\":1}}],[\"如果一个类型的原子操作总是无锁的\",{\"1\":{\"65\":1}}],[\"如果这些操作在目标平台上是有锁的\",{\"1\":{\"65\":1}}],[\"如果我们知道某些操作在目标平台上是无锁的\",{\"1\":{\"65\":1}}],[\"如果我们的\",{\"1\":{\"14\":1}}],[\"如果信号量只有二进制的\",{\"1\":{\"62\":1}}],[\"如果当前值为\",{\"1\":{\"67\":1}}],[\"如果当前环境上的原子类型\",{\"1\":{\"65\":1}}],[\"如果当前信号量的计数值为\",{\"1\":{\"58\":2}}],[\"如果当前有活跃线程\",{\"1\":{\"18\":1}}],[\"如果在主线程中执行耗时任务会导致界面卡顿\",{\"1\":{\"51\":1}}],[\"如果在指定的超时间隔后仍然无法得到结果\",{\"1\":{\"49\":1}}],[\"如果超过了这个时间还没有被唤醒\",{\"1\":{\"50\":1}}],[\"如果先前调用了\",{\"1\":{\"45\":1}}],[\"如果promise的值还没有被设置\",{\"1\":{\"45\":1}}],[\"如果想要异步的获取返回值\",{\"1\":{\"44\":1}}],[\"如果从\",{\"1\":{\"43\":1}}],[\"如果系统资源有限\",{\"1\":{\"43\":1}}],[\"如果系统资源充足\",{\"1\":{\"43\":1}}],[\"如果要支持\",{\"1\":{\"37\":1}}],[\"如果构造函数\",{\"1\":{\"36\":1}}],[\"如果\",{\"1\":{\"36\":1,\"45\":1}}],[\"如果用外部代码要获取一个锁\",{\"1\":{\"30\":1}}],[\"如果必须要获取多个锁\",{\"1\":{\"30\":1}}],[\"如果按照前面的的选择一个固定的顺序上锁解锁\",{\"1\":{\"30\":1}}],[\"如果两个线程同时运行\",{\"1\":{\"30\":1}}],[\"如果上锁成功就返回\",{\"1\":{\"28\":1}}],[\"如果使用这个构造函数\",{\"1\":{\"27\":1}}],[\"如果互斥量是锁定的\",{\"1\":{\"26\":1}}],[\"如果出现数据竞争\",{\"1\":{\"25\":1}}],[\"如果是标量类型\",{\"1\":{\"75\":1}}],[\"如果是整数类型的特化\",{\"1\":{\"65\":1}}],[\"如果是\",{\"1\":{\"43\":1}}],[\"如果是自己重载\",{\"1\":{\"36\":1}}],[\"如果是第一次学习本章的内容\",{\"1\":{\"23\":1}}],[\"如果是默认构造之类的\",{\"1\":{\"12\":1}}],[\"如果非要使用\",{\"1\":{\"21\":1}}],[\"如果您对内存次序感兴趣\",{\"1\":{\"71\":1}}],[\"如果您主要关注业务开发\",{\"1\":{\"71\":1}}],[\"如果您是\",{\"1\":{\"56\":1}}],[\"如果您好好的学习了上一节的内容\",{\"1\":{\"18\":1}}],[\"如果您支持\",{\"1\":{\"15\":1}}],[\"如果标准达到\",{\"1\":{\"16\":1}}],[\"如果还没完成就调用\",{\"1\":{\"15\":1}}],[\"如果还有不理解\",{\"1\":{\"14\":1}}],[\"如果不满足要求\",{\"1\":{\"65\":1}}],[\"如果不这样做\",{\"1\":{\"52\":1}}],[\"如果不使用线程\",{\"1\":{\"52\":1}}],[\"如果不使用\",{\"1\":{\"14\":1}}],[\"如果不想等待线程结束可以使用\",{\"1\":{\"13\":1}}],[\"如果对他们的实现感兴趣\",{\"1\":{\"14\":1}}],[\"如果有两个线程运行这段代码\",{\"1\":{\"28\":1}}],[\"如果有\",{\"1\":{\"13\":1}}],[\"如果异常被抛出但未被捕获那么就会调用\",{\"1\":{\"13\":1}}],[\"如果抛出异常\",{\"1\":{\"12\":1}}],[\"如果抛出了异常\",{\"1\":{\"12\":1}}],[\"如果代码里抛出了异常\",{\"1\":{\"12\":1}}],[\"如果你对此网站的使用不熟悉\",{\"1\":{\"74\":1}}],[\"如果你需要更多的操作\",{\"1\":{\"36\":1}}],[\"如果你需要多线程求和\",{\"1\":{\"10\":1}}],[\"如果你的标准达到\",{\"1\":{\"36\":1}}],[\"如果你的同事或上司写出此代码\",{\"1\":{\"33\":1}}],[\"如果你学过其它语言或者操作系统\",{\"1\":{\"34\":1}}],[\"如果你有需要\",{\"1\":{\"33\":1}}],[\"如果你有些地方无法理解\",{\"1\":{\"16\":1}}],[\"如果你觉得难以理解\",{\"1\":{\"33\":1}}],[\"如果你简单写一个\",{\"1\":{\"32\":1}}],[\"如果你自己编译了这些代码\",{\"1\":{\"18\":1}}],[\"如果你直接用一个循环不断判断这个操作是否完成就会使得这个线程占满\",{\"1\":{\"15\":1}}],[\"如果你是第一次见到成员指针\",{\"1\":{\"14\":1}}],[\"如果你传入的是一个临时对象\",{\"1\":{\"12\":1}}],[\"如果希望代码可以在\",{\"1\":{\"10\":1}}],[\"如果为\",{\"1\":{\"9\":1}}],[\"如果没有同步\",{\"1\":{\"62\":1}}],[\"如果没有进行同步保护\",{\"1\":{\"46\":2}}],[\"如果没有找到键返回空字符串\",{\"1\":{\"34\":1}}],[\"如果没有线程持有这个互斥量\",{\"1\":{\"26\":1}}],[\"如果没有\",{\"1\":{\"0\":1}}],[\"会不会指令重排导致先输出\",{\"1\":{\"71\":1}}],[\"会保证外部行为的一致性\",{\"1\":{\"71\":1}}],[\"会看到先输出\",{\"1\":{\"58\":1}}],[\"会返回系统的当前时间\",{\"1\":{\"48\":1}}],[\"会进行其它处理\",{\"1\":{\"47\":1}}],[\"会抛出\",{\"1\":{\"45\":1}}],[\"会堵塞\",{\"1\":{\"43\":1}}],[\"会使用到\",{\"1\":{\"38\":1}}],[\"会按照互斥量的规则进行阻塞\",{\"1\":{\"35\":1}}],[\"会让传入的可调用对象被多次调用\",{\"1\":{\"33\":1}}],[\"会持有一个悬垂指针\",{\"1\":{\"32\":1}}],[\"会尝试上锁\",{\"1\":{\"28\":1}}],[\"会详细了解这个类\",{\"1\":{\"27\":1}}],[\"会打印出了一样的值\",{\"1\":{\"27\":1}}],[\"会多\",{\"1\":{\"20\":1}}],[\"会导致问题\",{\"1\":{\"14\":1}}],[\"会自动调用对象的析构函数\",{\"1\":{\"13\":1}}],[\"会产生未定义行为\",{\"1\":{\"12\":1}}],[\"会调用\",{\"1\":{\"9\":1,\"21\":1}}],[\"会讨论程序的并发性\",{\"1\":{\"6\":1}}],[\"会讨论程序的并行性\",{\"1\":{\"6\":1}}],[\"判断线程对象目前是否有关联活跃线程\",{\"1\":{\"9\":1}}],[\"failed\",{\"1\":{\"80\":2}}],[\"false\",{\"1\":{\"9\":1,\"12\":2,\"28\":1,\"31\":3,\"32\":1,\"40\":3,\"43\":2,\"46\":1,\"50\":2,\"52\":1,\"54\":1,\"65\":3,\"66\":9,\"67\":18}}],[\"f4\",{\"1\":{\"66\":1}}],[\"fetch\",{\"1\":{\"46\":4,\"65\":2}}],[\"fexperimental\",{\"1\":{\"21\":1}}],[\"f3\",{\"1\":{\"43\":1,\"66\":1}}],[\"f1\",{\"1\":{\"43\":2}}],[\"fms\",{\"1\":{\"37\":1}}],[\"front\",{\"1\":{\"41\":2}}],[\"free\",{\"1\":{\"36\":1,\"65\":22}}],[\"friend\",{\"1\":{\"30\":1}}],[\"fixed\",{\"1\":{\"54\":2}}],[\"find\",{\"1\":{\"34\":1}}],[\"first\",{\"1\":{\"10\":7,\"44\":4}}],[\"float\",{\"1\":{\"65\":3}}],[\"flag不可复制不可移动不可赋值\",{\"1\":{\"66\":1}}],[\"flag\",{\"1\":{\"33\":8,\"40\":5,\"66\":26,\"67\":14}}],[\"flush\",{\"1\":{\"21\":1}}],[\"found\",{\"1\":{\"88\":1}}],[\"font\",{\"1\":{\"54\":1}}],[\"foo\",{\"1\":{\"29\":1,\"33\":1}}],[\"format\",{\"1\":{\"58\":1}}],[\"forward<tuple>\",{\"1\":{\"84\":2}}],[\"forward<\",{\"1\":{\"21\":4,\"80\":6}}],[\"forward<args>\",{\"1\":{\"18\":1,\"44\":1}}],[\"forward<callable>\",{\"1\":{\"18\":1,\"84\":2}}],[\"forwardit\",{\"1\":{\"10\":4,\"44\":2}}],[\"forwardit>\",{\"1\":{\"10\":2,\"44\":1}}],[\"for\",{\"1\":{\"10\":2,\"12\":1,\"15\":5,\"18\":3,\"21\":2,\"26\":4,\"27\":1,\"28\":1,\"40\":8,\"41\":2,\"43\":1,\"44\":3,\"45\":1,\"46\":2,\"47\":3,\"49\":3,\"50\":1,\"52\":2,\"54\":2,\"58\":4,\"60\":1,\"79\":1}}],[\"fx\",{\"1\":{\"21\":3,\"80\":5}}],[\"fnvals\",{\"1\":{\"80\":2}}],[\"fn>\",{\"1\":{\"21\":4,\"80\":6}}],[\"fn\",{\"1\":{\"21\":2,\"80\":5}}],[\"f2\",{\"1\":{\"12\":3,\"13\":2,\"25\":7,\"30\":6,\"43\":3,\"66\":1,\"84\":1}}],[\"f\",{\"1\":{\"12\":3,\"13\":2,\"14\":27,\"16\":7,\"21\":4,\"25\":10,\"26\":5,\"27\":2,\"30\":6,\"31\":1,\"33\":4,\"36\":3,\"43\":15,\"64\":2,\"66\":7,\"84\":6}}],[\"fut\",{\"1\":{\"45\":4}}],[\"future<t>\",{\"1\":{\"46\":1}}],[\"future<std\",{\"1\":{\"46\":5}}],[\"future<value\",{\"1\":{\"44\":2}}],[\"future<void>future\",{\"1\":{\"54\":1}}],[\"future<void>\",{\"1\":{\"43\":2}}],[\"future<double>future\",{\"1\":{\"44\":2}}],[\"future<int>\",{\"1\":{\"43\":1,\"44\":1,\"45\":3,\"49\":1}}],[\"futures\",{\"1\":{\"38\":1,\"44\":4}}],[\"future\",{\"0\":{\"86\":1},\"1\":{\"1\":1,\"39\":2,\"42\":9,\"43\":15,\"44\":17,\"45\":11,\"46\":39,\"49\":12,\"52\":1,\"54\":1,\"62\":1}}],[\"func>\",{\"1\":{\"29\":1}}],[\"function\",{\"1\":{\"28\":3,\"29\":3,\"35\":6,\"45\":4}}],[\"func\",{\"1\":{\"12\":9,\"13\":1,\"18\":2,\"29\":3}}],[\"返回类型不为\",{\"1\":{\"84\":1}}],[\"返回类型都是\",{\"1\":{\"84\":1}}],[\"返回类型推导是\",{\"1\":{\"10\":1}}],[\"返回一个普通的\",{\"1\":{\"67\":1}}],[\"返回的内部类型没办法直接转换为\",{\"1\":{\"56\":1}}],[\"返回的临时\",{\"1\":{\"16\":1}}],[\"返回执行结果\",{\"1\":{\"43\":1}}],[\"返回与\",{\"1\":{\"21\":2}}],[\"返回当前线程\",{\"1\":{\"15\":1}}],[\"返回\",{\"1\":{\"9\":1,\"14\":1,\"65\":2,\"66\":1,\"67\":1,\"80\":1}}],[\"让元组保有的互斥量引用都进行解锁\",{\"1\":{\"84\":1}}],[\"让你对它再无疑问\",{\"1\":{\"82\":1}}],[\"让你彻底了解这个类\",{\"1\":{\"78\":1}}],[\"让我们得以简单的使用\",{\"1\":{\"49\":1}}],[\"让它和\",{\"1\":{\"44\":1}}],[\"让另外的线程有机会获取锁并设置标识\",{\"1\":{\"40\":1}}],[\"让其选择到不上锁的构造函数\",{\"1\":{\"30\":1}}],[\"让其关联的线程执行成员函数\",{\"1\":{\"14\":1}}],[\"让持有线程资源的\",{\"1\":{\"16\":1}}],[\"让当前线程延迟到具体的时间\",{\"1\":{\"15\":1}}],[\"让对象的生命周期和资源绑定\",{\"1\":{\"13\":1}}],[\"让\",{\"1\":{\"9\":1}}],[\"然后就用\",{\"1\":{\"84\":1}}],[\"然后就是推荐使用\",{\"1\":{\"66\":1}}],[\"然后调用\",{\"1\":{\"80\":1}}],[\"然后退出循环\",{\"1\":{\"66\":1}}],[\"然后\",{\"1\":{\"45\":1}}],[\"然后在循环中制造任务插入容器\",{\"1\":{\"44\":1}}],[\"然后我们来传递任务进行异步调用等操作\",{\"1\":{\"44\":1}}],[\"然后再写入另一个对象\",{\"1\":{\"66\":1}}],[\"然后再获取返回值\",{\"1\":{\"44\":1}}],[\"然后再尝试锁定\",{\"1\":{\"30\":1}}],[\"然后使用\",{\"1\":{\"44\":1}}],[\"然后逐个执行\",{\"1\":{\"43\":1}}],[\"然后设置一个稍早的闹钟\",{\"1\":{\"40\":1}}],[\"然后讨论了面对不同情况保护共享数据的不同方式\",{\"1\":{\"38\":1}}],[\"然后传递\",{\"1\":{\"31\":1}}],[\"然后作用域结束\",{\"1\":{\"27\":1}}],[\"然后执行\",{\"1\":{\"25\":1}}],[\"然后来管理函数到底如何执行\",{\"1\":{\"22\":1}}],[\"然后这个临时对象再用来初始化\",{\"1\":{\"16\":1}}],[\"然后返回它\",{\"1\":{\"16\":1}}],[\"然后会修改对象的状态\",{\"1\":{\"9\":1}}],[\"然而要想阅读学习源码\",{\"1\":{\"73\":1}}],[\"然而\",{\"1\":{\"43\":1,\"58\":1}}],[\"然而在某些情况下\",{\"1\":{\"35\":1}}],[\"然而使用\",{\"1\":{\"34\":1}}],[\"然而使用互斥量来保护共享数据也并不是在函数中加上一个\",{\"1\":{\"29\":1}}],[\"然而这显然没用\",{\"1\":{\"33\":1}}],[\"然而它们的帮助都是有限的\",{\"1\":{\"30\":1}}],[\"然而函数\",{\"1\":{\"30\":1}}],[\"然而此时我们必须再次\",{\"1\":{\"12\":1}}],[\"然而大多数是粗糙的\",{\"1\":{\"0\":1}}],[\"调用可调用对象即可\",{\"1\":{\"84\":1}}],[\"调用可调用对象的参数\",{\"1\":{\"80\":1}}],[\"调用不会上锁的构造函数的参数顺序不同\",{\"1\":{\"84\":1}}],[\"调用时执行\",{\"1\":{\"43\":1,\"49\":1}}],[\"调用另一个重载版本\",{\"1\":{\"43\":1}}],[\"调用就阻塞了\",{\"1\":{\"27\":1}}],[\"调用了\",{\"1\":{\"25\":1,\"31\":1,\"43\":1}}],[\"调用是线程安全的\",{\"1\":{\"25\":1}}],[\"调用和执行\",{\"1\":{\"14\":1}}],[\"调用成员函数的参数\",{\"1\":{\"14\":1}}],[\"调用析构函数阻塞执行\",{\"1\":{\"43\":1}}],[\"调用析构函数\",{\"1\":{\"13\":1}}],[\"调用之前\",{\"1\":{\"12\":1}}],[\"调用\",{\"1\":{\"9\":1,\"12\":1,\"27\":1,\"32\":1,\"45\":1,\"67\":1,\"80\":2}}],[\"否则将所有权层数减少\",{\"1\":{\"35\":1}}],[\"否则将一直堵塞\",{\"1\":{\"9\":1}}],[\"否则\",{\"1\":{\"9\":1,\"67\":1}}],[\"就如同我们先前聊\",{\"1\":{\"82\":1}}],[\"就如同我们先前所说\",{\"1\":{\"46\":1}}],[\"就比如它们\",{\"1\":{\"81\":1}}],[\"就接受了我们构造\",{\"1\":{\"80\":1}}],[\"就等于\",{\"1\":{\"80\":1}}],[\"就算真的\",{\"1\":{\"71\":1}}],[\"就不再重复\",{\"1\":{\"84\":1}}],[\"就不再需要使用\",{\"1\":{\"66\":1}}],[\"就不需要再强调了\",{\"1\":{\"46\":1}}],[\"就不可再次调用\",{\"1\":{\"45\":1}}],[\"就需要使用\",{\"1\":{\"46\":1}}],[\"就\",{\"1\":{\"44\":1}}],[\"就休息\",{\"1\":{\"40\":1}}],[\"就得使用互斥量之类的方式保护了\",{\"1\":{\"36\":1}}],[\"就可能会导致数据竞争和未定义行为\",{\"1\":{\"36\":1}}],[\"就可以执行了\",{\"1\":{\"80\":1}}],[\"就可以\",{\"1\":{\"33\":1}}],[\"就可以尽情玩耍\",{\"1\":{\"30\":1}}],[\"就可以进去执行了\",{\"1\":{\"27\":1}}],[\"就别再获取第二个锁\",{\"1\":{\"30\":1}}],[\"就有死锁风险\",{\"1\":{\"30\":1}}],[\"就通常不会死锁\",{\"1\":{\"30\":1}}],[\"就应该是单纯的在受互斥量保护的情况下老老实实调用\",{\"1\":{\"29\":1}}],[\"就万事大吉了\",{\"1\":{\"29\":1}}],[\"就更简单了\",{\"1\":{\"27\":1}}],[\"就解锁了互斥量\",{\"1\":{\"26\":1}}],[\"就要避免其它线程修改\",{\"1\":{\"30\":1}}],[\"就要开始聊共享数据的那些事\",{\"1\":{\"24\":1}}],[\"就要特别注意了\",{\"1\":{\"14\":1}}],[\"就好\",{\"1\":{\"21\":1}}],[\"就能让这种保护形同虚设\",{\"1\":{\"29\":1}}],[\"就能成功调用\",{\"1\":{\"14\":1}}],[\"就能正常的调用\",{\"1\":{\"12\":1}}],[\"就在\",{\"1\":{\"12\":1}}],[\"就会导致编译错误\",{\"1\":{\"43\":1}}],[\"就会阻塞直到\",{\"1\":{\"43\":1}}],[\"就会违反第一个指导意见\",{\"1\":{\"30\":1}}],[\"就会产生死锁\",{\"1\":{\"30\":1}}],[\"就会跳转到\",{\"1\":{\"12\":1}}],[\"就会被跳过\",{\"1\":{\"12\":1}}],[\"就手搓了一个\",{\"1\":{\"10\":1}}],[\"就是我们前面讲的\",{\"1\":{\"80\":1}}],[\"就是接受一个元组类型\",{\"1\":{\"80\":1}}],[\"就是占据\",{\"1\":{\"79\":1}}],[\"就是在原子类型的类型名前面加上\",{\"1\":{\"65\":1}}],[\"就是主线程\",{\"1\":{\"54\":1}}],[\"就是一个稳定时钟\",{\"1\":{\"48\":1}}],[\"就是其关联的事件\",{\"1\":{\"42\":1}}],[\"就是调用移动构造\",{\"1\":{\"32\":1}}],[\"就是按引用传递了\",{\"1\":{\"14\":1}}],[\"就是返回了\",{\"1\":{\"14\":1}}],[\"就是\",{\"1\":{\"14\":1,\"48\":1,\"80\":1}}],[\"就是构造\",{\"1\":{\"12\":1}}],[\"就是确保线程对象关联的线程已经执行完毕\",{\"1\":{\"9\":1}}],[\"就是为了区别多线程中不同的关注点\",{\"1\":{\"6\":1}}],[\"就自动在新线程开始执行函数\",{\"1\":{\"9\":1}}],[\"线程模型\",{\"1\":{\"81\":1}}],[\"线程基本上就是独立的\",{\"1\":{\"62\":1}}],[\"线程id\",{\"1\":{\"54\":2}}],[\"线程执行\",{\"1\":{\"54\":1}}],[\"线程2\",{\"1\":{\"46\":4}}],[\"线程1\",{\"1\":{\"46\":4}}],[\"线程知道预期结果\",{\"1\":{\"42\":1}}],[\"线程弹出元素\",{\"1\":{\"41\":5}}],[\"线程插入元素\",{\"1\":{\"41\":5}}],[\"线程局部存储\",{\"1\":{\"37\":1}}],[\"线程存储期的对象在线程开始时分配\",{\"1\":{\"37\":1}}],[\"线程存储期\",{\"0\":{\"37\":1},\"1\":{\"37\":1}}],[\"线程可以阻塞\",{\"1\":{\"60\":1}}],[\"线程可以等待\",{\"1\":{\"40\":1}}],[\"线程可以在递归互斥体上重复调用\",{\"1\":{\"35\":1}}],[\"线程可以检测到停止状态是否已被设置为\",{\"1\":{\"21\":1}}],[\"线程对已经上锁的\",{\"1\":{\"35\":1}}],[\"线程对象的大小都是\",{\"1\":{\"81\":1}}],[\"线程对象代表了线程\",{\"1\":{\"18\":1}}],[\"线程对象\",{\"1\":{\"14\":1,\"16\":2}}],[\"线程对象现在是否有关联的活跃线程\",{\"1\":{\"13\":1}}],[\"线程对象当前关联了活跃线程\",{\"1\":{\"13\":1}}],[\"线程对象正常析构\",{\"1\":{\"13\":1}}],[\"线程对象可以正常析构\",{\"1\":{\"12\":1}}],[\"线程对象放弃了线程资源的所有权\",{\"1\":{\"12\":1}}],[\"线程对象不再持有线程资源\",{\"1\":{\"12\":1}}],[\"线程对象调用了\",{\"1\":{\"12\":1}}],[\"线程对象没有关联线程的\",{\"1\":{\"12\":1}}],[\"线程对象关联了一个线程资源\",{\"1\":{\"9\":1}}],[\"线程安全的队列\",{\"0\":{\"41\":1}}],[\"线程安全的初始化过程\",{\"1\":{\"33\":1}}],[\"线程安全的一次初始化\",{\"1\":{\"33\":1}}],[\"线程不安全\",{\"1\":{\"33\":1}}],[\"线程获取一个锁时\",{\"1\":{\"30\":1}}],[\"线程会在那个调用中结束\",{\"1\":{\"23\":1}}],[\"线程内部可以定期检查\",{\"1\":{\"21\":1}}],[\"线程停止设施你会感觉是一种类似与外部与线程进行某种信号通信的设施\",{\"1\":{\"22\":1}}],[\"线程停止\",{\"0\":{\"21\":1},\"1\":{\"21\":1,\"22\":1}}],[\"线程停止功能\",{\"1\":{\"19\":1}}],[\"线程资源的所有权转移给函数调用\",{\"1\":{\"16\":1}}],[\"线程资源\",{\"1\":{\"16\":1}}],[\"线程是一种系统资源\",{\"1\":{\"16\":1}}],[\"线程需要等待某个操作完成\",{\"1\":{\"15\":1}}],[\"线程开始执行\",{\"1\":{\"12\":1}}],[\"线程独立的运行\",{\"1\":{\"12\":1}}],[\"线程分离\",{\"1\":{\"12\":1}}],[\"线程库启动线程\",{\"1\":{\"12\":1}}],[\"线程管理\",{\"0\":{\"11\":1},\"1\":{\"11\":1}}],[\"线程\",{\"1\":{\"10\":1,\"27\":2,\"28\":6,\"30\":3,\"37\":1,\"52\":1,\"58\":4,\"64\":5}}],[\"线程其实是指所谓的逻辑处理器\",{\"1\":{\"10\":1}}],[\"线程的情况下执行耗时任务\",{\"1\":{\"51\":1}}],[\"线程的接口\",{\"1\":{\"37\":1}}],[\"线程的取消\",{\"1\":{\"19\":1}}],[\"线程的\",{\"1\":{\"10\":1}}],[\"线程更是上千\",{\"1\":{\"5\":1}}],[\"将线程id设置为0\",{\"1\":{\"80\":1}}],[\"将独占指针的所有权转移给线程\",{\"1\":{\"80\":1}}],[\"将我们构造函数的参数全部完美转发\",{\"1\":{\"80\":1}}],[\"将原子对象的值设置给\",{\"1\":{\"67\":1}}],[\"将原子对象的值加载进\",{\"1\":{\"67\":1}}],[\"将原子对象\",{\"1\":{\"67\":1}}],[\"将是\",{\"1\":{\"67\":1}}],[\"将标志对象的状态原子地更改为设置\",{\"1\":{\"66\":1}}],[\"将标志对象的状态原子地更改为清除\",{\"1\":{\"66\":1}}],[\"将返回\",{\"1\":{\"65\":1}}],[\"将错误码设置为\",{\"1\":{\"45\":1}}],[\"将持有最终计算出来的结果\",{\"1\":{\"43\":1}}],[\"将互斥量的所有权转移给调用方\",{\"1\":{\"32\":1}}],[\"将数据成员赋给新对象\",{\"1\":{\"32\":1}}],[\"将临时对象的线程资源所有权移交给\",{\"1\":{\"16\":1}}],[\"将对象包装\",{\"1\":{\"14\":1}}],[\"将\",{\"1\":{\"9\":1,\"12\":1,\"14\":1,\"16\":3,\"66\":3,\"71\":1,\"80\":1}}],[\"<>\",{\"1\":{\"83\":1}}],[\"<atomic>\",{\"1\":{\"65\":1}}],[\"<latch>\",{\"1\":{\"59\":1}}],[\"<semaphore>\",{\"1\":{\"58\":1}}],[\"<future>\",{\"1\":{\"42\":1,\"43\":1}}],[\"<condition\",{\"1\":{\"40\":1}}],[\"<class\",{\"1\":{\"21\":1,\"27\":1,\"80\":4,\"83\":2}}],[\"<mutex>\",{\"1\":{\"26\":1,\"35\":1}}],[\"<=\",{\"1\":{\"12\":1,\"54\":1}}],[\"<\",{\"1\":{\"10\":5,\"18\":2,\"26\":2,\"41\":2,\"44\":3,\"52\":1,\"58\":1}}],[\"<thread>\",{\"1\":{\"9\":1,\"10\":1,\"12\":2,\"35\":1,\"43\":1}}],[\"<<\",{\"1\":{\"9\":4,\"10\":3,\"12\":2,\"14\":12,\"15\":13,\"16\":10,\"18\":6,\"21\":4,\"25\":4,\"26\":4,\"27\":5,\"28\":12,\"33\":3,\"35\":10,\"37\":6,\"40\":2,\"41\":6,\"43\":26,\"44\":6,\"45\":15,\"46\":20,\"48\":4,\"49\":6,\"50\":3,\"58\":8,\"60\":2,\"65\":25,\"66\":2,\"67\":2,\"84\":2}}],[\"<iostream>\",{\"1\":{\"9\":2,\"10\":1,\"12\":2,\"35\":1,\"43\":1,\"75\":1}}],[\"memcpy\",{\"1\":{\"71\":1}}],[\"memcmp\",{\"1\":{\"71\":1}}],[\"memory\",{\"1\":{\"25\":1,\"65\":13,\"66\":6,\"67\":6}}],[\"mt19937\",{\"1\":{\"58\":1}}],[\"mtxes\",{\"1\":{\"83\":7,\"84\":7}}],[\"mtx\",{\"1\":{\"27\":4,\"28\":3,\"31\":2,\"35\":4,\"40\":5,\"83\":4}}],[\"ms\",{\"1\":{\"49\":2}}],[\"msvc\",{\"1\":{\"0\":1,\"20\":1,\"21\":1,\"22\":1,\"27\":1,\"31\":1,\"37\":6,\"49\":1,\"65\":1,\"66\":1,\"72\":1,\"74\":3,\"78\":2,\"80\":1,\"82\":2,\"84\":1}}],[\"modify\",{\"1\":{\"65\":1}}],[\"months\",{\"1\":{\"49\":1}}],[\"move\",{\"1\":{\"14\":9,\"16\":5,\"18\":4,\"32\":1,\"43\":12,\"44\":3,\"45\":4,\"65\":2,\"75\":7,\"80\":2}}],[\"minimum\",{\"1\":{\"54\":2}}],[\"minute\",{\"1\":{\"49\":1}}],[\"minutes\",{\"1\":{\"48\":2,\"49\":1}}],[\"millisecond\",{\"1\":{\"49\":1}}],[\"milliseconds>\",{\"1\":{\"50\":1}}],[\"milliseconds\",{\"1\":{\"28\":1,\"40\":1,\"43\":1,\"49\":3}}],[\"milli\",{\"1\":{\"49\":1}}],[\"milli>\",{\"1\":{\"49\":1}}],[\"microsecond\",{\"1\":{\"49\":1}}],[\"microseconds\",{\"1\":{\"49\":1}}],[\"micro>\",{\"1\":{\"49\":1}}],[\"mq白\",{\"1\":{\"42\":1}}],[\"m2\",{\"1\":{\"30\":8,\"83\":2}}],[\"m1\",{\"1\":{\"30\":7,\"83\":3}}],[\"make\",{\"1\":{\"41\":1,\"80\":6,\"84\":2}}],[\"malloc\",{\"1\":{\"36\":1}}],[\"malicious\",{\"1\":{\"29\":3}}],[\"map<std\",{\"1\":{\"34\":1}}],[\"main\",{\"1\":{\"9\":2,\"10\":1,\"12\":4,\"14\":3,\"15\":4,\"16\":4,\"18\":3,\"21\":1,\"25\":2,\"26\":2,\"31\":2,\"33\":1,\"35\":1,\"37\":1,\"43\":6,\"44\":1,\"45\":2,\"46\":2,\"53\":1,\"58\":8,\"60\":1,\"75\":1}}],[\"mutable\",{\"1\":{\"34\":2,\"41\":1}}],[\"mutexes>\",{\"1\":{\"83\":1}}],[\"mutexes\",{\"1\":{\"83\":6,\"84\":3}}],[\"mutex>sp\",{\"1\":{\"84\":1}}],[\"mutex>get\",{\"1\":{\"32\":1}}],[\"mutex>lk\",{\"1\":{\"40\":2,\"41\":4}}],[\"mutex>lock\",{\"1\":{\"31\":2}}],[\"mutex>lc2\",{\"1\":{\"83\":1}}],[\"mutex>lc\",{\"1\":{\"27\":1,\"83\":1}}],[\"mutex>\",{\"1\":{\"27\":6,\"29\":1,\"30\":8,\"31\":3,\"32\":2,\"33\":1,\"34\":3,\"35\":1,\"40\":6,\"50\":1,\"64\":1,\"66\":1,\"83\":2,\"84\":1}}],[\"mutex\",{\"1\":{\"26\":2,\"27\":9,\"28\":1,\"29\":1,\"30\":2,\"31\":7,\"32\":10,\"33\":1,\"34\":12,\"35\":6,\"38\":4,\"40\":3,\"41\":1,\"50\":1,\"58\":1,\"64\":1,\"66\":6,\"83\":10,\"84\":2}}],[\"multiply<ratio<146097\",{\"1\":{\"49\":1}}],[\"multiply<ratio<7>\",{\"1\":{\"49\":1}}],[\"multiply<ratio<24>\",{\"1\":{\"49\":1}}],[\"multi\",{\"1\":{\"10\":1}}],[\"mymutexes让它保有这些互斥量的引用\",{\"1\":{\"84\":2}}],[\"mymutexes\",{\"1\":{\"83\":4,\"84\":3}}],[\"mymutex\",{\"1\":{\"27\":5,\"83\":5}}],[\"my\",{\"1\":{\"12\":10,\"33\":5,\"65\":6}}],[\"m\",{\"1\":{\"12\":3,\"13\":4,\"15\":3,\"26\":3,\"27\":9,\"29\":2,\"30\":11,\"31\":8,\"33\":2,\"34\":2,\"40\":3,\"41\":5,\"48\":2,\"50\":2,\"64\":2,\"66\":2,\"75\":1,\"84\":5}}],[\"image\",{\"0\":{\"89\":1}}],[\"impl\",{\"1\":{\"20\":1,\"21\":4,\"84\":2}}],[\"it\",{\"1\":{\"34\":3}}],[\"iterator\",{\"1\":{\"10\":1}}],[\"iter\",{\"1\":{\"10\":2,\"44\":1}}],[\"iota\",{\"1\":{\"27\":1}}],[\"identifier\",{\"1\":{\"79\":1}}],[\"id打印主线程和子线程的\",{\"1\":{\"15\":1}}],[\"id\",{\"1\":{\"15\":6,\"16\":1,\"18\":7,\"26\":2,\"27\":1,\"28\":4,\"35\":2,\"43\":7,\"54\":4,\"55\":1,\"56\":2,\"58\":2,\"79\":5,\"80\":5,\"81\":1}}],[\"issue\",{\"1\":{\"76\":1}}],[\"issues\",{\"1\":{\"0\":1}}],[\"isdone\",{\"1\":{\"15\":1}}],[\"is\",{\"1\":{\"13\":1,\"21\":2,\"48\":1,\"65\":12,\"66\":1,\"80\":1}}],[\"i\",{\"1\":{\"10\":9,\"12\":8,\"18\":6,\"26\":4,\"27\":4,\"41\":5,\"44\":11,\"52\":4,\"54\":4,\"58\":3,\"66\":1}}],[\"ifdef\",{\"1\":{\"81\":1}}],[\"if\",{\"1\":{\"10\":1,\"13\":1,\"18\":2,\"21\":3,\"28\":1,\"30\":3,\"31\":6,\"33\":2,\"35\":2,\"44\":1,\"49\":2,\"50\":1,\"65\":3,\"67\":2,\"71\":1,\"80\":3}}],[\"i7\",{\"1\":{\"10\":1}}],[\"incomplete\",{\"1\":{\"80\":1}}],[\"include\",{\"1\":{\"9\":3,\"10\":2,\"12\":4,\"26\":1,\"35\":3,\"43\":3,\"75\":2}}],[\"indices\",{\"1\":{\"80\":3}}],[\"indices>\",{\"1\":{\"80\":4}}],[\"index>\",{\"1\":{\"84\":1}}],[\"index\",{\"1\":{\"80\":5,\"84\":4}}],[\"in\",{\"1\":{\"66\":1}}],[\"information\",{\"1\":{\"54\":3}}],[\"invoke<\",{\"1\":{\"80\":3}}],[\"invoker\",{\"1\":{\"80\":5}}],[\"invoke\",{\"1\":{\"78\":1,\"80\":13,\"84\":2}}],[\"invokemethod\",{\"1\":{\"52\":5,\"54\":5,\"55\":1}}],[\"invocable<std\",{\"1\":{\"44\":1}}],[\"invocable\",{\"1\":{\"21\":1}}],[\"instance\",{\"1\":{\"33\":4}}],[\"init\",{\"1\":{\"33\":2,\"66\":6}}],[\"initialization\",{\"1\":{\"13\":1}}],[\"int29\",{\"1\":{\"48\":1}}],[\"int>\",{\"1\":{\"14\":1,\"21\":1,\"65\":1,\"80\":1}}],[\"int\",{\"1\":{\"9\":2,\"10\":2,\"12\":16,\"13\":1,\"14\":24,\"15\":4,\"16\":4,\"18\":3,\"21\":2,\"25\":3,\"26\":2,\"27\":2,\"28\":1,\"29\":1,\"31\":2,\"33\":2,\"35\":3,\"36\":2,\"37\":5,\"41\":3,\"43\":17,\"44\":18,\"45\":5,\"46\":2,\"52\":1,\"54\":1,\"56\":1,\"58\":6,\"60\":1,\"64\":1,\"65\":11,\"75\":2,\"79\":2,\"80\":1,\"81\":1}}],[\"write\",{\"1\":{\"65\":1}}],[\"wrapper<int>\",{\"1\":{\"14\":1}}],[\"wrapper<const\",{\"1\":{\"14\":2}}],[\"wrapper可以隐式转换为被包装对象的引用即可\",{\"1\":{\"14\":1}}],[\"wrapper\",{\"1\":{\"14\":1,\"29\":2}}],[\"wchar\",{\"1\":{\"65\":1}}],[\"weak\",{\"1\":{\"65\":2,\"67\":6}}],[\"weeks\",{\"1\":{\"49\":1}}],[\"web\",{\"1\":{\"5\":1,\"58\":2}}],[\"what\",{\"1\":{\"45\":2,\"66\":2}}],[\"while\",{\"1\":{\"15\":1,\"21\":1,\"40\":3,\"50\":1,\"66\":1,\"67\":1}}],[\"would\",{\"1\":{\"31\":1}}],[\"worker\",{\"1\":{\"58\":1}}],[\"work\",{\"1\":{\"18\":3,\"60\":6}}],[\"world\",{\"0\":{\"9\":1},\"1\":{\"9\":3,\"10\":1,\"12\":1}}],[\"width\",{\"1\":{\"54\":1}}],[\"win32\",{\"1\":{\"37\":3,\"56\":1,\"59\":1,\"74\":1,\"79\":2,\"81\":1}}],[\"windows\",{\"1\":{\"14\":1}}],[\"with\",{\"1\":{\"27\":1,\"83\":1}}],[\"wait\",{\"1\":{\"40\":11,\"41\":2,\"43\":6,\"46\":4,\"47\":4,\"49\":5,\"50\":2,\"60\":2}}],[\"waiting\",{\"1\":{\"15\":2,\"40\":1}}],[\"wakeup\",{\"1\":{\"15\":5,\"40\":1}}],[\"类维护着一个\",{\"1\":{\"60\":1}}],[\"类而已\",{\"1\":{\"44\":1}}],[\"类模板不仅只能使用标准库为我们定义的特化类型\",{\"1\":{\"65\":1}}],[\"类模板\",{\"1\":{\"44\":1,\"45\":1,\"48\":1}}],[\"类模板实参推导\",{\"1\":{\"27\":1}}],[\"类似于\",{\"1\":{\"67\":1}}],[\"类似\",{\"1\":{\"42\":1,\"46\":1,\"71\":1}}],[\"类似问题应该是看你自己的\",{\"1\":{\"7\":1}}],[\"类是\",{\"1\":{\"40\":1}}],[\"类型和一个参数序列的索引序列\",{\"1\":{\"80\":1}}],[\"类型进行构造\",{\"1\":{\"67\":1}}],[\"类型\",{\"1\":{\"49\":1,\"65\":1,\"80\":1}}],[\"类型的原子操作一定有锁的\",{\"1\":{\"65\":1}}],[\"类型的原子操作一定无锁的\",{\"1\":{\"65\":1}}],[\"类型的原子操作有时是无锁的\",{\"1\":{\"65\":1}}],[\"类型的计数\",{\"1\":{\"60\":1}}],[\"类型的值\",{\"1\":{\"48\":1}}],[\"类型的参数\",{\"1\":{\"45\":1}}],[\"类型的对象需要以\",{\"1\":{\"66\":1}}],[\"类型的对象\",{\"1\":{\"31\":1,\"80\":1}}],[\"类型的对象作为参数\",{\"1\":{\"14\":1}}],[\"类型是\",{\"1\":{\"12\":1}}],[\"类名\",{\"1\":{\"12\":1,\"14\":1}}],[\"类\",{\"1\":{\"8\":1,\"11\":1,\"30\":1}}],[\"中就是先前说的\",{\"1\":{\"60\":1}}],[\"中才得以引入\",{\"1\":{\"58\":1}}],[\"中获取线程\",{\"1\":{\"54\":1}}],[\"中用于表达当前时间\",{\"1\":{\"50\":1}}],[\"中增加打印语句\",{\"1\":{\"41\":1}}],[\"中添加元素时\",{\"1\":{\"25\":1}}],[\"中创建了一个局部的\",{\"1\":{\"16\":1}}],[\"中创建的线程正常执行完成\",{\"1\":{\"12\":1}}],[\"中的高级工具之后\",{\"1\":{\"62\":1}}],[\"中的时间库\",{\"1\":{\"47\":1}}],[\"中的\",{\"1\":{\"12\":1,\"27\":2,\"32\":1}}],[\"中\",{\"1\":{\"8\":1,\"45\":1,\"52\":1,\"58\":1,\"65\":2,\"66\":1,\"80\":1}}],[\"什么时候不该使用多线程\",{\"1\":{\"7\":1}}],[\"什么时候你该使用多线程\",{\"1\":{\"7\":1}}],[\"它包含了可调用对象和参数的类型\",{\"1\":{\"80\":1}}],[\"它保有两个数据成员\",{\"1\":{\"79\":1}}],[\"它还提供了一种存储方式\",{\"1\":{\"67\":1}}],[\"它在不同的标准库实现中只是简单的初始化\",{\"1\":{\"66\":1}}],[\"它很简单\",{\"1\":{\"66\":1}}],[\"它只能做三件事情\",{\"1\":{\"66\":1}}],[\"它只能处理有限数量的并发请求\",{\"1\":{\"58\":1}}],[\"它只是一个可变参数成员函数模板\",{\"1\":{\"80\":1}}],[\"它只是一个\",{\"1\":{\"66\":2}}],[\"它只保有一个私有数据成员\",{\"1\":{\"27\":1}}],[\"它维护一个计数\",{\"1\":{\"58\":1}}],[\"它用于对时间段进行处理\",{\"1\":{\"49\":1}}],[\"它用于处理线程中需要等待某个事件的情况\",{\"1\":{\"42\":1}}],[\"它通常用于测量时间间隔和性能计时等需要高精度和稳定性的场景\",{\"1\":{\"48\":1}}],[\"它通过创建新的类型提供了更多的功能\",{\"1\":{\"20\":1}}],[\"它默认的时钟节拍是\",{\"1\":{\"48\":1}}],[\"它较为麻烦\",{\"1\":{\"47\":1}}],[\"它并没有提供线程安全的方式\",{\"1\":{\"46\":1}}],[\"它并非具体类型\",{\"1\":{\"44\":1}}],[\"它接受一个\",{\"1\":{\"45\":1}}],[\"它本身并没什么特殊的\",{\"1\":{\"44\":1}}],[\"它有两个特化\",{\"1\":{\"83\":1}}],[\"它有两个非类型模板参数\",{\"1\":{\"48\":1}}],[\"它有\",{\"1\":{\"44\":1}}],[\"它支持只移动类型\",{\"1\":{\"43\":1}}],[\"它支持所有可调用\",{\"1\":{\"43\":1}}],[\"它支持\",{\"1\":{\"37\":1}}],[\"它允许同一线程多次锁定同一个互斥量\",{\"1\":{\"35\":1}}],[\"它不管有没有发生数据竞争\",{\"1\":{\"34\":1}}],[\"它也是一个可变参数成员函数模板\",{\"1\":{\"80\":1}}],[\"它也能保持稳定\",{\"1\":{\"48\":1}}],[\"它也可以是类的成员\",{\"1\":{\"33\":1}}],[\"它也更加的复杂\",{\"1\":{\"31\":1}}],[\"它指定外部链接\",{\"1\":{\"32\":1}}],[\"它移动即标志其管理的互斥量的所有权转移了\",{\"1\":{\"32\":1}}],[\"它拥有\",{\"1\":{\"31\":1}}],[\"它相比于\",{\"1\":{\"31\":1}}],[\"它相较于\",{\"1\":{\"27\":1,\"67\":1}}],[\"它能一次性锁住多个互斥量\",{\"1\":{\"30\":1}}],[\"它才能往下执行\",{\"1\":{\"30\":1}}],[\"它和\",{\"1\":{\"27\":1}}],[\"它可以原子的使用新的值替换已经存储的值\",{\"1\":{\"67\":1}}],[\"它可以在编译阶段进行决策\",{\"1\":{\"65\":1}}],[\"它可以提供相对于起始时间的稳定的递增时间\",{\"1\":{\"48\":1}}],[\"它可以管理多个互斥量\",{\"1\":{\"27\":1}}],[\"它可以处于锁定\",{\"1\":{\"26\":1}}],[\"它会执行我们传递的可调用\",{\"1\":{\"44\":1}}],[\"它会返回一个\",{\"1\":{\"43\":1}}],[\"它会设置内部的停止状态为\",{\"1\":{\"21\":1}}],[\"它会退化成指向它的const\",{\"1\":{\"14\":1}}],[\"它将我们传入的参数\",{\"1\":{\"14\":1}}],[\"它们几乎都有一个\",{\"1\":{\"65\":1}}],[\"它们定义在标头\",{\"1\":{\"59\":1}}],[\"它们位于仓库的\",{\"1\":{\"53\":1}}],[\"它们都是通过\",{\"1\":{\"49\":1}}],[\"它们都是模板\",{\"1\":{\"42\":1}}],[\"它们相比于\",{\"1\":{\"47\":1}}],[\"它们和我们先前讲的\",{\"1\":{\"47\":1}}],[\"它们的返回类型都是\",{\"1\":{\"50\":1}}],[\"它们的模板类型参数\",{\"1\":{\"42\":1}}],[\"它们的区别与\",{\"1\":{\"42\":1}}],[\"它们的区别简单来说\",{\"1\":{\"34\":1}}],[\"它们的跨平台性和可移植性较差\",{\"1\":{\"37\":1}}],[\"它们不是同一个\",{\"1\":{\"37\":1}}],[\"它们就可能会彼此等待对方释放其所需的锁\",{\"1\":{\"30\":1}}],[\"它们之中最常用的是\",{\"1\":{\"15\":1}}],[\"它们构成了成员指针\",{\"1\":{\"14\":1}}],[\"它们返回一个包装类\",{\"1\":{\"14\":1}}],[\"它们没有什么区别\",{\"1\":{\"6\":1}}],[\"它就应该只是单纯的管理线程对象仅此而已\",{\"1\":{\"13\":1}}],[\"它现在根本没有关联任何线程\",{\"1\":{\"12\":1}}],[\"它自身就是类类型\",{\"1\":{\"12\":1}}],[\"它被调整为了一个指向这个函数类型的指针类型\",{\"1\":{\"12\":1}}],[\"它的形参类型我们不再过多介绍\",{\"1\":{\"80\":1}}],[\"它的形式表现为\",{\"1\":{\"67\":1}}],[\"它的实现完全基于\",{\"1\":{\"78\":1}}],[\"它的所有操作都直接是原子的\",{\"1\":{\"64\":1}}],[\"它的逻辑比信号量还要简单\",{\"1\":{\"60\":1}}],[\"它的第二个模板参数的时间单位\",{\"1\":{\"50\":1}}],[\"它的第一个参数是类型表示\",{\"1\":{\"49\":1}}],[\"它的特点是不受系统时间调整或变化的影响\",{\"1\":{\"48\":1}}],[\"它的\",{\"1\":{\"46\":1}}],[\"它的返回类型是一个枚举类\",{\"1\":{\"49\":1}}],[\"它的返回类型是\",{\"1\":{\"28\":1}}],[\"它的效率接近我们实现的\",{\"1\":{\"10\":1}}],[\"它的用法也还远不止如此\",{\"1\":{\"9\":1}}],[\"它存储的就是余数\",{\"1\":{\"10\":1}}],[\"它与英特尔的技术实现有所不同\",{\"1\":{\"10\":1}}],[\"它是线程实际执行的函数\",{\"1\":{\"80\":1}}],[\"它是原子的\",{\"1\":{\"66\":1}}],[\"它是有效的\",{\"1\":{\"66\":1}}],[\"它是怎么实现的呢\",{\"1\":{\"27\":1}}],[\"它是模板\",{\"1\":{\"15\":1}}],[\"它是\",{\"1\":{\"10\":2}}],[\"它要想并发\",{\"1\":{\"5\":1}}],[\"对类型形参包为空的情况的全特化\",{\"1\":{\"83\":1}}],[\"对模板类型形参包只有一个类型情况的偏特化\",{\"1\":{\"83\":1}}],[\"对它们的兼容\",{\"1\":{\"74\":1}}],[\"对标准库的实现\",{\"1\":{\"74\":1}}],[\"对此类有兴趣或任何疑问\",{\"1\":{\"30\":1}}],[\"对数据做了保护\",{\"1\":{\"29\":1}}],[\"对每个线程对象调用\",{\"1\":{\"18\":1}}],[\"对移动语义不了解\",{\"1\":{\"16\":1}}],[\"对线程资源是独占所有权\",{\"1\":{\"16\":1,\"80\":1}}],[\"对\",{\"1\":{\"13\":1,\"64\":1}}],[\"对象并将它与执行线程关联\",{\"1\":{\"80\":1}}],[\"对象赋值给\",{\"1\":{\"67\":1}}],[\"对象不可进行复制\",{\"1\":{\"65\":1}}],[\"对象不可表示一个线程\",{\"1\":{\"16\":1}}],[\"对象而不同步\",{\"1\":{\"62\":1}}],[\"对象上调用所有成员函数\",{\"1\":{\"62\":1}}],[\"对象在默认构造时是清除\",{\"1\":{\"66\":1}}],[\"对象在\",{\"1\":{\"49\":1}}],[\"对象只能是存储值或者异常其中一种\",{\"1\":{\"45\":1}}],[\"对象会重新抛出这个异常\",{\"1\":{\"45\":1}}],[\"对象通过\",{\"1\":{\"45\":1}}],[\"对象进行操作时\",{\"1\":{\"46\":2}}],[\"对象进行关联\",{\"1\":{\"45\":1}}],[\"对象进行复制或赋值等操作会引发一个编译错误\",{\"1\":{\"13\":1}}],[\"对象异步获得\",{\"1\":{\"45\":1}}],[\"对象所创建的\",{\"1\":{\"45\":1}}],[\"对象所持有的线程资源转移给\",{\"1\":{\"16\":1}}],[\"对象访问的共享状态中\",{\"1\":{\"44\":1}}],[\"对象调用\",{\"1\":{\"43\":2}}],[\"对象副本进行访问\",{\"1\":{\"42\":1,\"46\":1}}],[\"对象时\",{\"1\":{\"42\":1}}],[\"对象实例\",{\"1\":{\"36\":1}}],[\"对象是全局命名空间作用域声明\",{\"1\":{\"33\":1}}],[\"对象都具有静态或线程存储期\",{\"1\":{\"32\":1}}],[\"对象都能检查到这个停止请求\",{\"1\":{\"21\":1}}],[\"对象表示拥有互斥量的所有权\",{\"1\":{\"31\":1}}],[\"对象停止状态\",{\"1\":{\"21\":1}}],[\"对象关联的\",{\"1\":{\"21\":1}}],[\"对象管理\",{\"1\":{\"18\":1}}],[\"对象中存储的\",{\"1\":{\"66\":1}}],[\"对象中\",{\"1\":{\"16\":1}}],[\"对象最后调用\",{\"1\":{\"16\":1}}],[\"对象的状态原子地更改为清除\",{\"1\":{\"66\":1}}],[\"对象的状态为设置\",{\"1\":{\"66\":1}}],[\"对象的生命周期结束时\",{\"1\":{\"66\":1}}],[\"对象的计数减少到零\",{\"1\":{\"60\":1}}],[\"对象的\",{\"1\":{\"45\":1}}],[\"对象的线程资源所有权转移给另一个\",{\"1\":{\"16\":1}}],[\"对象的指针\",{\"1\":{\"14\":1}}],[\"对象失去了线程资源的所有权\",{\"1\":{\"13\":1}}],[\"对象销毁之后再去访问\",{\"1\":{\"12\":1}}],[\"对象即可\",{\"1\":{\"12\":1,\"33\":1}}],[\"对象\",{\"1\":{\"9\":1,\"11\":1,\"12\":5,\"13\":1,\"14\":1,\"16\":5,\"32\":2,\"33\":1,\"37\":1,\"43\":3,\"44\":1,\"45\":1,\"46\":1,\"65\":1,\"80\":2,\"84\":1}}],[\"对于多线程程序\",{\"1\":{\"71\":1}}],[\"对于单线程程序\",{\"1\":{\"71\":1}}],[\"对于普通开发者来说\",{\"1\":{\"71\":1}}],[\"对于两个独立的对象\",{\"1\":{\"66\":1}}],[\"对于标准内建类型的别名\",{\"1\":{\"65\":1}}],[\"对于有时无锁的内建原子类型是\",{\"1\":{\"65\":1}}],[\"对于一定无锁的内建原子类型是\",{\"1\":{\"65\":1}}],[\"对于一定有锁的内建原子类型是\",{\"1\":{\"65\":1}}],[\"对于一些特殊的场景\",{\"1\":{\"33\":1}}],[\"对于那些熟悉操作系统或其它并发支持库的开发者来说\",{\"1\":{\"58\":1}}],[\"对于每个线程来说是独立的\",{\"1\":{\"36\":1}}],[\"对于相同类型的两个不同对象进行数据的交换操作\",{\"1\":{\"30\":1}}],[\"对于很多人来说\",{\"1\":{\"6\":1}}],[\"对于这两个术语\",{\"1\":{\"6\":1}}],[\"对多线程来说\",{\"1\":{\"6\":1}}],[\"只管理一个互斥量的\",{\"1\":{\"84\":1}}],[\"只不过一直没详细展开讲解\",{\"1\":{\"71\":1}}],[\"只需关注\",{\"1\":{\"53\":1}}],[\"只需要调用\",{\"1\":{\"43\":1}}],[\"只需要接受可调用\",{\"1\":{\"33\":1}}],[\"只需要将这些参数作为\",{\"1\":{\"14\":1}}],[\"只保有一个私有数据成员\",{\"1\":{\"79\":1}}],[\"只保有一个引用\",{\"1\":{\"13\":1}}],[\"只保证了\",{\"1\":{\"36\":1}}],[\"只要可被多个线程读写\",{\"1\":{\"36\":1}}],[\"只要不影响自己即可\",{\"1\":{\"33\":1}}],[\"只要是可调用\",{\"1\":{\"12\":1}}],[\"只能包一层了\",{\"1\":{\"44\":1}}],[\"只能移动\",{\"1\":{\"44\":1}}],[\"只能与单个指定事件关联\",{\"1\":{\"42\":1}}],[\"只能寄希望于调用方传递的代码是能正常执行的\",{\"1\":{\"30\":1}}],[\"只能通过对象关联线程后\",{\"1\":{\"11\":1}}],[\"只用来确保必须的共享资源的线程安全\",{\"1\":{\"27\":1}}],[\"只有两个版本需要介绍\",{\"1\":{\"84\":1}}],[\"只有第四个构造函数较为复杂\",{\"1\":{\"80\":1}}],[\"只有在解锁与锁定次数相匹配时\",{\"1\":{\"35\":1}}],[\"只有在涉及多线程读写相同共享数据的时候\",{\"1\":{\"25\":1}}],[\"只有一个线程可以运行\",{\"1\":{\"34\":1}}],[\"只有一个线程能获取结果\",{\"1\":{\"46\":1}}],[\"只有一个线程能在\",{\"1\":{\"27\":1}}],[\"只有一个线程能成功调用并将\",{\"1\":{\"66\":1}}],[\"只有一个线程能成功调用\",{\"1\":{\"26\":1}}],[\"只有\",{\"1\":{\"27\":1}}],[\"只有硬件上是多核的\",{\"1\":{\"5\":1}}],[\"只是初始化数据成员\",{\"1\":{\"84\":1}}],[\"只是初始化了数据成员而已\",{\"1\":{\"31\":1}}],[\"只是其中之一\",{\"1\":{\"67\":1}}],[\"只是\",{\"1\":{\"58\":1}}],[\"只是不上锁\",{\"1\":{\"31\":1}}],[\"只是多了两个功能\",{\"1\":{\"19\":1}}],[\"只是保有了线程对象的引用\",{\"1\":{\"13\":1}}],[\"只是为了让线程对象关联的线程得以正确执行完毕\",{\"1\":{\"12\":1}}],[\"只是用于描述一些东西的时候关注点不同\",{\"1\":{\"6\":1}}],[\"指令重排了\",{\"1\":{\"71\":1}}],[\"指明\",{\"1\":{\"66\":1}}],[\"指定时间的方式\",{\"1\":{\"47\":1}}],[\"指的是一个访问共享资源的程序片段\",{\"1\":{\"38\":1}}],[\"指的是由\",{\"1\":{\"23\":1}}],[\"指针为空\",{\"1\":{\"33\":1}}],[\"指针就悬空了\",{\"1\":{\"14\":1}}],[\"指针\",{\"1\":{\"14\":1,\"79\":1}}],[\"指向了一个静态成员函数\",{\"1\":{\"80\":1}}],[\"指向的是\",{\"1\":{\"80\":1}}],[\"指向它的指针这当然没问题了\",{\"1\":{\"14\":1}}],[\"指向\",{\"1\":{\"12\":1}}],[\"指代的东西完全不同\",{\"1\":{\"6\":1}}],[\"指两个或两个以上的独立活动同时发生\",{\"1\":{\"4\":1}}],[\"并将线程句柄存储到\",{\"1\":{\"80\":1}}],[\"并将互斥量的所有权转移到调用者上\",{\"1\":{\"32\":1}}],[\"并返回\",{\"1\":{\"67\":1}}],[\"并返回旧值\",{\"1\":{\"67\":1}}],[\"并返回它先前的值\",{\"1\":{\"66\":1}}],[\"并返回它先前保有的值给\",{\"1\":{\"66\":1}}],[\"并返回它先前保有的值\",{\"1\":{\"66\":1}}],[\"并返回一个指向弹出元素的\",{\"1\":{\"41\":1}}],[\"并介绍其成员函数和使用方法\",{\"1\":{\"65\":1}}],[\"并指明了执行策略\",{\"1\":{\"52\":1}}],[\"并指明执行策略\",{\"1\":{\"10\":1}}],[\"并更新进度条\",{\"1\":{\"51\":1}}],[\"并退出循环\",{\"1\":{\"50\":1}}],[\"并执行后续的操作\",{\"1\":{\"40\":1}}],[\"并说明了可以使用互斥量\",{\"1\":{\"38\":1}}],[\"并在主线程中通过与其关联的\",{\"1\":{\"45\":1}}],[\"并在线程结束时释放\",{\"1\":{\"37\":1}}],[\"并在以后反复查看和实践\",{\"1\":{\"23\":1}}],[\"并非是不可打断不可交换的固定指令\",{\"1\":{\"33\":1}}],[\"并非引用了局部对象\",{\"1\":{\"14\":1}}],[\"并造成死锁\",{\"1\":{\"30\":1}}],[\"并且能从非原子的\",{\"1\":{\"67\":1}}],[\"并且为了方便使用\",{\"1\":{\"49\":1}}],[\"并且异步任务的执行不会导致性能问题\",{\"1\":{\"43\":1}}],[\"并且它们都不可移动不可复制\",{\"1\":{\"83\":1}}],[\"并且它和\",{\"1\":{\"43\":1}}],[\"并且它有自己的问题\",{\"1\":{\"38\":1}}],[\"并且也是默认按值复制\",{\"1\":{\"43\":1}}],[\"并且通过\",{\"1\":{\"40\":1}}],[\"并且条件变量\",{\"1\":{\"40\":1}}],[\"并且要注意互斥量上锁的\",{\"1\":{\"38\":1}}],[\"并且额外支持超时功能\",{\"1\":{\"34\":1}}],[\"并且让当前线程获取锁\",{\"1\":{\"33\":1}}],[\"并且把\",{\"1\":{\"31\":1}}],[\"并且死锁经常是不可预见\",{\"1\":{\"30\":1}}],[\"并且没有死锁风险\",{\"1\":{\"30\":1}}],[\"并且一个拿到了遥控器\",{\"1\":{\"30\":1}}],[\"并且两个小孩都想要玩\",{\"1\":{\"30\":1}}],[\"并且\",{\"1\":{\"27\":1,\"31\":1}}],[\"并且余数是\",{\"1\":{\"10\":1}}],[\"并对它进行修改\",{\"1\":{\"25\":1}}],[\"并不总是无锁\",{\"1\":{\"65\":1}}],[\"并不堵塞\",{\"1\":{\"44\":1}}],[\"并不是说要在\",{\"1\":{\"14\":1}}],[\"并不会和前面\",{\"1\":{\"14\":1}}],[\"并没有太多区别\",{\"1\":{\"82\":1}}],[\"并没有处理什么其他的东西\",{\"1\":{\"12\":1}}],[\"并没有非常公认的说法\",{\"1\":{\"6\":1}}],[\"并行求和\",{\"1\":{\"10\":1}}],[\"并行\",{\"1\":{\"6\":1}}],[\"并发支持库进行多线程编程\",{\"1\":{\"73\":1}}],[\"并发支持库的重中之重\",{\"1\":{\"23\":1}}],[\"并发支持库也不涉及多进程\",{\"1\":{\"3\":1}}],[\"并发库的历史发展\",{\"1\":{\"7\":1}}],[\"并发与并行\",{\"0\":{\"6\":1}}],[\"并发在生活中随处可见\",{\"1\":{\"4\":1}}],[\"并发\",{\"0\":{\"4\":1},\"1\":{\"4\":1}}],[\"并发编程\",{\"1\":{\"3\":1}}],[\"并发编程的教程并不稀少\",{\"1\":{\"0\":1}}],[\"并发编程教程\",{\"1\":{\"0\":1,\"72\":1,\"74\":1}}],[\"事实上只需要一句话就可以表达了\",{\"1\":{\"73\":1}}],[\"事实上我们在前面就用到了不少的内存次序\",{\"1\":{\"71\":1}}],[\"事实上我们的代码就是这样做的\",{\"1\":{\"58\":1}}],[\"事实上最简单的方式是\",{\"1\":{\"40\":1}}],[\"事实上完全等价\",{\"1\":{\"12\":1}}],[\"事实上\",{\"1\":{\"6\":1}}],[\"浏览器\",{\"1\":{\"5\":1}}],[\"编译选项\",{\"1\":{\"21\":1,\"37\":1}}],[\"编译器优化需要遵守一个\",{\"1\":{\"71\":1}}],[\"编译器在编译代码时\",{\"1\":{\"71\":1}}],[\"编译器重排\",{\"1\":{\"71\":1}}],[\"编译器可以\",{\"1\":{\"37\":1}}],[\"编译器\",{\"1\":{\"5\":1}}],[\"编辑器和\",{\"1\":{\"5\":1}}],[\"这很明显\",{\"1\":{\"84\":1}}],[\"这很正常\",{\"1\":{\"41\":1}}],[\"这三个版本中\",{\"1\":{\"84\":1}}],[\"这三个文件\",{\"1\":{\"53\":1}}],[\"这没办法\",{\"1\":{\"82\":1}}],[\"这并非当前描述不足或者不够严谨\",{\"1\":{\"74\":1}}],[\"这并不能创建异步任务\",{\"1\":{\"43\":1}}],[\"这显然不现实\",{\"1\":{\"71\":1}}],[\"这也就是前面说的\",{\"1\":{\"71\":1}}],[\"这也就是下一章节的内容了\",{\"1\":{\"18\":1}}],[\"这将使学习过程具有一定挑战性\",{\"1\":{\"71\":1}}],[\"这意味着你可以根据成功或失败的情况\",{\"1\":{\"67\":1}}],[\"这意味着通过调用\",{\"1\":{\"12\":1}}],[\"这不是\",{\"1\":{\"66\":1}}],[\"这不是接口设计者可以处理的\",{\"1\":{\"30\":1}}],[\"这构成了数据竞争\",{\"1\":{\"64\":1}}],[\"这使得\",{\"1\":{\"60\":1}}],[\"这对于代码块的计时是很有用的\",{\"1\":{\"50\":1}}],[\"这只是一个简单的示例\",{\"1\":{\"44\":1}}],[\"这一点和\",{\"1\":{\"46\":1}}],[\"这一点中在源码中很明显\",{\"1\":{\"43\":1}}],[\"这一切的问题都会在后面的\",{\"1\":{\"14\":1}}],[\"这可以避免\",{\"1\":{\"40\":1}}],[\"这会涉及不少模板技术\",{\"1\":{\"85\":1}}],[\"这会涉及到不少的模板技术\",{\"1\":{\"82\":1}}],[\"这会影响到程序的行为\",{\"1\":{\"40\":1}}],[\"这会造成很多的额外开销\",{\"1\":{\"33\":1}}],[\"这会造成资源浪费\",{\"1\":{\"15\":1}}],[\"这和线程有什么关系呢\",{\"1\":{\"40\":1}}],[\"这都不是最重要的\",{\"1\":{\"31\":1}}],[\"这都很正常\",{\"1\":{\"27\":1}}],[\"这种遍历元组的方式在之前讲\",{\"1\":{\"84\":1}}],[\"这种重排通常遵循一些硬件层面的优化规则\",{\"1\":{\"71\":1}}],[\"这种操作叫做\",{\"1\":{\"67\":1}}],[\"这种区分必然是\",{\"1\":{\"40\":1}}],[\"这种机制就称为\",{\"1\":{\"40\":1}}],[\"这种机制不是强制性的终止线程\",{\"1\":{\"23\":1}}],[\"这种实现进步了很多\",{\"1\":{\"40\":1}}],[\"这种错误写法在一些单例中也非常的常见\",{\"1\":{\"33\":1}}],[\"这种转移\",{\"1\":{\"32\":1}}],[\"这种情况就是死锁\",{\"1\":{\"30\":1}}],[\"这种方法在多线程编程中很有用\",{\"1\":{\"28\":1}}],[\"这些还是简单直接且符合直觉的\",{\"1\":{\"71\":1}}],[\"这些东西用来创建一个线程\",{\"1\":{\"80\":1}}],[\"这些东西\",{\"1\":{\"71\":1}}],[\"这些操作是不被允许的\",{\"1\":{\"66\":1}}],[\"这些操作对应的函数分别是\",{\"1\":{\"66\":1}}],[\"这些类型的操作都是原子的\",{\"1\":{\"65\":1}}],[\"这些扩展并不是标准的\",{\"1\":{\"37\":1}}],[\"这些都由操作系统调度决定\",{\"1\":{\"27\":1}}],[\"这些参数会复制到新线程的内存空间中\",{\"1\":{\"14\":1}}],[\"这所谓的线程停止\",{\"1\":{\"21\":1}}],[\"这就是这个类型名字的由来\",{\"1\":{\"62\":1}}],[\"这就是双重检查\",{\"1\":{\"33\":1}}],[\"这就是所谓的\",{\"1\":{\"32\":1}}],[\"这就是\",{\"1\":{\"20\":1}}],[\"这段代码为你展示了\",{\"1\":{\"84\":1}}],[\"这段代码很简单\",{\"1\":{\"58\":1}}],[\"这段代码很好的展示了\",{\"1\":{\"37\":1}}],[\"这段代码存在数据竞争\",{\"1\":{\"46\":1}}],[\"这段代码运行会抛出异常\",{\"1\":{\"31\":1}}],[\"这段代码极其简单\",{\"1\":{\"27\":1}}],[\"这段代码你多次运行它会得到毫无规律和格式的结果\",{\"1\":{\"26\":1}}],[\"这段代码可以通过编译\",{\"1\":{\"16\":1}}],[\"这段代码通过移动构造转移了线程对象\",{\"1\":{\"16\":1}}],[\"这段代码将\",{\"1\":{\"9\":1}}],[\"这确保了线程对象\",{\"1\":{\"13\":1}}],[\"这确保了剩余的\",{\"1\":{\"10\":1}}],[\"这个非常重要\",{\"1\":{\"84\":1}}],[\"这个东西可以用来接收一个由\",{\"1\":{\"80\":1}}],[\"这个构造函数不上锁\",{\"1\":{\"84\":1}}],[\"这个构造函数做了两件事情\",{\"1\":{\"84\":1}}],[\"这个构造函数本身并没有做什么\",{\"1\":{\"80\":1}}],[\"这个构造函数没有给互斥量上锁\",{\"1\":{\"31\":1}}],[\"这个结构体\",{\"1\":{\"79\":1}}],[\"这个结构体的\",{\"1\":{\"79\":1}}],[\"这个行为不仅仅适用于std\",{\"1\":{\"67\":1}}],[\"这个参数可以用来指定执行顺序\",{\"1\":{\"65\":1}}],[\"这个参数通常通过\",{\"1\":{\"45\":1}}],[\"这个数量非常之多\",{\"1\":{\"65\":1}}],[\"这个数据结构很少进行改变\",{\"1\":{\"34\":1}}],[\"这个函数模板接受两个参数\",{\"1\":{\"84\":1}}],[\"这个函数用于获取一个函数指针\",{\"1\":{\"80\":1}}],[\"这个函数才是我们的重点\",{\"1\":{\"80\":1}}],[\"这个函数可以让用户查询某原子类型的操作是直接用的原子指令\",{\"1\":{\"65\":1}}],[\"这个函数调用是阻塞的\",{\"1\":{\"47\":1}}],[\"这个字其实个人觉得是不常见\",{\"1\":{\"60\":1}}],[\"这个计数不能小于\",{\"1\":{\"58\":1}}],[\"这个同步设施的概念应该不会感到陌生\",{\"1\":{\"58\":1}}],[\"这个例子其实很好的展示了多线程异步的作用\",{\"1\":{\"57\":1}}],[\"这个对象和任务关联\",{\"1\":{\"43\":1}}],[\"这个问题就能使用\",{\"1\":{\"42\":1}}],[\"这个方法听起来还行\",{\"1\":{\"40\":1}}],[\"这个所有权语义\",{\"1\":{\"31\":1}}],[\"这个建议是很简单的\",{\"1\":{\"30\":1}}],[\"这个玩具有两个部分\",{\"1\":{\"30\":1}}],[\"这个是由操作系统调度决定的\",{\"1\":{\"26\":1}}],[\"这个类型的对象可以在两个状态间切换\",{\"1\":{\"66\":1}}],[\"这个类和\",{\"1\":{\"18\":1}}],[\"这个类就是包装引用对象类模板\",{\"1\":{\"14\":1}}],[\"这个传入了一个临时对象\",{\"1\":{\"15\":1}}],[\"这个命名空间包含了管理当前线程的函数\",{\"1\":{\"15\":1}}],[\"这个指针可以通过\",{\"1\":{\"14\":1}}],[\"这个\",{\"1\":{\"14\":1,\"18\":1}}],[\"这个销毁依然会发生\",{\"1\":{\"13\":1}}],[\"这个线程也会多分配一个元素\",{\"1\":{\"10\":1}}],[\"这被编译器解析为函数声明\",{\"1\":{\"12\":1}}],[\"这样简单直观\",{\"1\":{\"75\":1}}],[\"这样的系统时钟可能会受到系统时间调整或变化的影响\",{\"1\":{\"48\":1}}],[\"这样的方式很好\",{\"1\":{\"47\":1}}],[\"这样的话\",{\"1\":{\"13\":1}}],[\"这样不会有任何问题\",{\"1\":{\"46\":1}}],[\"这样访问的就都是\",{\"1\":{\"46\":1}}],[\"这样就不会错过你要下车的站点\",{\"1\":{\"40\":1}}],[\"这样就确保了所有的元素都被正确地分配给了各个线程进行处理\",{\"1\":{\"10\":1}}],[\"这样一个恶意的函数\",{\"1\":{\"29\":1}}],[\"这样确保了当执行函数\",{\"1\":{\"27\":1}}],[\"这样这个线程占用\",{\"1\":{\"15\":1}}],[\"这样如果前面的代码没有抛出异常\",{\"1\":{\"12\":1}}],[\"这样\",{\"1\":{\"12\":1,\"21\":1,\"40\":1}}],[\"这样系统使用者就可以同时运行文字处理器\",{\"1\":{\"5\":1}}],[\"这里就用到了\",{\"1\":{\"80\":1}}],[\"这里有一个形参包展开\",{\"1\":{\"80\":1}}],[\"这里使用了\",{\"1\":{\"80\":1}}],[\"这里推荐一下\",{\"1\":{\"73\":1,\"81\":1}}],[\"这里实际上有两个独立的操作\",{\"1\":{\"66\":1}}],[\"这里还不是详细展开聊内存序的时候\",{\"1\":{\"66\":1}}],[\"这里还需要提一下\",{\"1\":{\"31\":1}}],[\"这里不再过多赘述\",{\"1\":{\"63\":1}}],[\"这里显示的是子线程的id\",{\"1\":{\"54\":1}}],[\"这里显示的线程\",{\"1\":{\"54\":1}}],[\"这里\",{\"1\":{\"43\":1}}],[\"这里会调用移动构造\",{\"1\":{\"32\":1}}],[\"这里一样选择到移动构造\",{\"1\":{\"16\":1}}],[\"这里相当于是将临时的\",{\"1\":{\"16\":1}}],[\"这里虽然有两个\",{\"1\":{\"16\":1}}],[\"这里调用\",{\"1\":{\"12\":1}}],[\"这里反而是最简单的\",{\"1\":{\"10\":1}}],[\"这里写了一个三目运算符是为了进行分配任务\",{\"1\":{\"10\":1}}],[\"这里的效果相当于给其成员\",{\"1\":{\"80\":1}}],[\"这里的结果是截断的\",{\"1\":{\"49\":1}}],[\"这里的\",{\"1\":{\"10\":1,\"16\":1}}],[\"这里的调用是必须的\",{\"1\":{\"9\":1}}],[\"这行代码是获取当前线程的执行范围\",{\"1\":{\"10\":1}}],[\"这是个好问题\",{\"1\":{\"84\":1}}],[\"这是个管理类\",{\"1\":{\"13\":1}}],[\"这是由时间周期所决定\",{\"1\":{\"48\":1}}],[\"这是移动语义的基本语义逻辑\",{\"1\":{\"43\":1}}],[\"这是未定义行为\",{\"1\":{\"35\":1}}],[\"这是一个很重要的类\",{\"1\":{\"48\":1}}],[\"这是一个互斥量的声明\",{\"1\":{\"32\":1}}],[\"这是一个非常典型的\",{\"1\":{\"27\":1}}],[\"这是一个\",{\"1\":{\"27\":1}}],[\"这是一个可以检查停止请求的类型\",{\"1\":{\"21\":1}}],[\"这是一个可以发出停止请求的类型\",{\"1\":{\"21\":1}}],[\"这是无所谓的\",{\"1\":{\"25\":1}}],[\"这是正常现象\",{\"1\":{\"18\":1}}],[\"这是唯一标准用法\",{\"1\":{\"14\":1}}],[\"这是为了那些只支持移动的类型\",{\"1\":{\"14\":1,\"43\":1}}],[\"这是为了让迭代器一直向前\",{\"1\":{\"10\":1}}],[\"这是因为许多内存次序问题是由于极端的\",{\"1\":{\"71\":1}}],[\"这是因为函数模板不是函数\",{\"1\":{\"44\":1}}],[\"这是因为\",{\"1\":{\"14\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"这是因为我们创建线程对象\",{\"1\":{\"9\":1}}],[\"这是好习惯\",{\"1\":{\"12\":1}}],[\"这是必须的\",{\"1\":{\"0\":1,\"80\":1}}],[\"这两个函数都非常的简单\",{\"1\":{\"80\":1}}],[\"这两个实现都包含在\",{\"1\":{\"40\":1}}],[\"这两个方面的线程安全\",{\"1\":{\"36\":1}}],[\"这两个数据成员\",{\"1\":{\"20\":1}}],[\"这两个问题其实也算一个问题\",{\"1\":{\"12\":1}}],[\"这两个术语存在的目的\",{\"1\":{\"6\":1}}],[\"这两个词是用来描述硬件同时执行多个任务的方式\",{\"1\":{\"6\":1}}],[\"这两个概念大部分是重叠的\",{\"1\":{\"6\":1}}],[\"这基本不可能每一个任务分配一个核心\",{\"1\":{\"5\":1}}],[\"进入\",{\"1\":{\"58\":1}}],[\"进入作用域构造\",{\"1\":{\"27\":1}}],[\"进程至少上百个\",{\"1\":{\"5\":1}}],[\"进行约束我们传入的可调用对象的类型不能是\",{\"1\":{\"80\":1}}],[\"进行加载操作\",{\"1\":{\"67\":1}}],[\"进行操作\",{\"1\":{\"65\":1}}],[\"进行操作了\",{\"1\":{\"46\":1}}],[\"进行传递\",{\"1\":{\"45\":1}}],[\"进行锁定时\",{\"1\":{\"35\":1}}],[\"进行检测\",{\"1\":{\"31\":1}}],[\"进行调用\",{\"1\":{\"31\":1}}],[\"进行编译\",{\"1\":{\"21\":1}}],[\"进行清理和终止线程\",{\"1\":{\"21\":1}}],[\"进行初始化\",{\"1\":{\"12\":1}}],[\"进行教学\",{\"1\":{\"3\":1}}],[\"进行多线程编程\",{\"1\":{\"0\":1}}],[\"但我们也扩展涉及了许多其他知识\",{\"1\":{\"74\":1}}],[\"但并未给出标准协程库\",{\"1\":{\"72\":1}}],[\"但并不是强制性的线程终止方式\",{\"1\":{\"21\":1}}],[\"但可以使用非原子的\",{\"1\":{\"67\":1}}],[\"但还未完成\",{\"1\":{\"64\":1}}],[\"但反过来不行\",{\"1\":{\"49\":1}}],[\"但只有一个对象可以获得特定的同步结果\",{\"1\":{\"46\":1}}],[\"但无法获取返回值\",{\"1\":{\"44\":1}}],[\"但无数据竞争\",{\"1\":{\"25\":1,\"34\":1}}],[\"但很难确定正确的休眠时间\",{\"1\":{\"40\":1}}],[\"但它并不影响不同线程对同一个互斥量进行锁定的情况\",{\"1\":{\"35\":1}}],[\"但它不能用来定义自动存储期的对象\",{\"1\":{\"32\":1}}],[\"但不会出现假失败\",{\"1\":{\"67\":1}}],[\"但不止如此\",{\"1\":{\"31\":1}}],[\"但不用担心\",{\"1\":{\"0\":1}}],[\"但如果他们都不愿意\",{\"1\":{\"30\":1}}],[\"但如果锁已经被其他线程占用\",{\"1\":{\"28\":1}}],[\"但实际上停止的决定和实现都由用户代码来完成\",{\"1\":{\"21\":1}}],[\"但这里使用的是字符串字面量\",{\"1\":{\"14\":1}}],[\"但通常这不符合我们的需求\",{\"1\":{\"14\":1}}],[\"但是我可以将它转换为\",{\"1\":{\"80\":1}}],[\"但是我们无需在乎\",{\"1\":{\"71\":1}}],[\"但是我们显然不能寄希望于这种操作系统的调度\",{\"1\":{\"25\":1}}],[\"但是我们也需要执行这个任务\",{\"1\":{\"10\":1}}],[\"但是基本的需求得能做到\",{\"1\":{\"73\":1,\"81\":1}}],[\"但是也是限时的\",{\"1\":{\"47\":1}}],[\"但是在一些情况下\",{\"1\":{\"47\":1}}],[\"但是却没有使用\",{\"1\":{\"45\":1}}],[\"但是却是少有的准确与完善\",{\"1\":{\"23\":1}}],[\"但是并不急切的需要它\",{\"1\":{\"43\":1}}],[\"但是你可能被过早的叫醒\",{\"1\":{\"40\":1}}],[\"但是互斥量只能解决它能解决的问题\",{\"1\":{\"38\":1}}],[\"但是觉得没必要再聊了\",{\"1\":{\"33\":1}}],[\"但是此时还没有创建\",{\"1\":{\"33\":1}}],[\"但是有些时候又不可避免的有修改和读取都要工作的时候\",{\"1\":{\"34\":1}}],[\"但是有所有权\",{\"1\":{\"31\":1}}],[\"但是有的时候即使固定锁顺序\",{\"1\":{\"30\":1}}],[\"但是调用方传递了\",{\"1\":{\"29\":1}}],[\"但是\",{\"1\":{\"25\":1,\"33\":1,\"43\":1}}],[\"但是实际什么都调用了\",{\"1\":{\"21\":1}}],[\"但是从始至终只有一个线程资源\",{\"1\":{\"16\":1}}],[\"但是它需要接受的参数不同\",{\"1\":{\"15\":1}}],[\"但是如果它的内部使用互斥量实现\",{\"1\":{\"65\":1}}],[\"但是如果是指向\",{\"1\":{\"14\":1}}],[\"但是如果抛出了异常呢\",{\"1\":{\"12\":1}}],[\"但是这会很疲惫\",{\"1\":{\"40\":1}}],[\"但是这个\",{\"1\":{\"14\":1}}],[\"但是这让\",{\"1\":{\"13\":1}}],[\"但是这是不对的\",{\"1\":{\"12\":1}}],[\"但是这是可能有余数的\",{\"1\":{\"10\":1}}],[\"但是主线程\",{\"1\":{\"12\":1}}],[\"但是核心却没有那么多\",{\"1\":{\"5\":1}}],[\"而标准库中提供的原子对象的原子操作\",{\"1\":{\"71\":1}}],[\"而这些情况很难被重现\",{\"1\":{\"71\":1}}],[\"而这些共享资源又无法同时被多个线程访问的特性\",{\"1\":{\"38\":1}}],[\"而赋值和复制涉及两个对象\",{\"1\":{\"66\":1}}],[\"而未展开具体使用\",{\"1\":{\"65\":1}}],[\"而屏障则可以\",{\"1\":{\"59\":1}}],[\"而后者是指定等待到一个具体的时间点\",{\"1\":{\"47\":1}}],[\"而从多个线程访问同一共享状态\",{\"1\":{\"46\":1}}],[\"而无法共存\",{\"1\":{\"45\":1}}],[\"而多个线程访问同一共享状态\",{\"1\":{\"42\":1}}],[\"而\",{\"1\":{\"42\":1,\"46\":1,\"67\":1}}],[\"而局部对象\",{\"1\":{\"36\":1}}],[\"而非\",{\"1\":{\"75\":2}}],[\"而非像上面那样将它自己作为可调用对象\",{\"1\":{\"44\":1}}],[\"而非显式调用\",{\"1\":{\"35\":1}}],[\"而非对线程类\",{\"1\":{\"10\":1}}],[\"而那些无需修改数据结构的读线程\",{\"1\":{\"34\":1}}],[\"而只是分配内存对指针写入\",{\"1\":{\"33\":1}}],[\"而互斥量的所有权可以通过移动操作转移给其他的\",{\"1\":{\"32\":1}}],[\"而函数\",{\"1\":{\"30\":1}}],[\"而不附加同步\",{\"1\":{\"62\":1}}],[\"而不会进行所谓的四舍五入\",{\"1\":{\"49\":1}}],[\"而不会造成死锁\",{\"1\":{\"35\":1}}],[\"而不需要写明模板类型参数\",{\"1\":{\"27\":1}}],[\"而不是驼峰命名法\",{\"1\":{\"75\":1}}],[\"而不是像之前\",{\"1\":{\"31\":1}}],[\"而不是一种与操作系统系统有关系的线程终止\",{\"1\":{\"21\":1}}],[\"而不是调用我们传递的可调用对象\",{\"1\":{\"14\":1}}],[\"而不是复制\",{\"1\":{\"14\":1}}],[\"而不是\",{\"1\":{\"12\":1}}],[\"而另一求值读或修改同一内存位置时\",{\"1\":{\"25\":1}}],[\"而没有影响到原来\",{\"1\":{\"20\":1}}],[\"而移动操作可以将一个\",{\"1\":{\"16\":1}}],[\"而线程对象拥有了线程的所有权\",{\"1\":{\"16\":1}}],[\"而新线程此时还没有进行\",{\"1\":{\"14\":1}}],[\"而是为了考虑读者的水平和可能的扩展学习需求\",{\"1\":{\"74\":1}}],[\"而是适用于所有std\",{\"1\":{\"67\":1}}],[\"而是所有原子类型共有的属性\",{\"1\":{\"66\":1}}],[\"而是\",{\"1\":{\"33\":1}}],[\"而是立即返回\",{\"1\":{\"28\":1}}],[\"而是提供一种线程内外都能检查和响应的信号\",{\"1\":{\"23\":1}}],[\"而是创造一个新的线程类型呢\",{\"1\":{\"20\":1}}],[\"而是在创建的新线程中\",{\"1\":{\"14\":1}}],[\"而是会产生编译错误\",{\"1\":{\"14\":1}}],[\"而按值复制的\",{\"1\":{\"14\":1}}],[\"而此时子线程还持有它的引用\",{\"1\":{\"12\":1}}],[\"而类名可不会直接变成对象\",{\"1\":{\"12\":1}}],[\"而且个人觉得\",{\"1\":{\"82\":1}}],[\"而且也不是重点\",{\"1\":{\"81\":1}}],[\"而且也没必要\",{\"1\":{\"5\":1}}],[\"而且技术上不影响存储期\",{\"1\":{\"32\":1}}],[\"而且即使不是一个添加元素\",{\"1\":{\"25\":1}}],[\"而且重复运行的结果还不一样\",{\"1\":{\"18\":1}}],[\"而且顾名思义\",{\"1\":{\"13\":1}}],[\"而且只是百万数据通常没必要多线程\",{\"1\":{\"10\":1}}],[\"而第三个线程只处理了平均数量的元素\",{\"1\":{\"10\":1}}],[\"而小于这个值的则直接使用标准库函数\",{\"1\":{\"10\":1}}],[\"而我们的\",{\"1\":{\"46\":1}}],[\"而我们先前一直没有写明这个参数\",{\"1\":{\"43\":1}}],[\"而我们知道\",{\"1\":{\"34\":1}}],[\"而我们本节说的\",{\"1\":{\"11\":1}}],[\"而我们回到代码上即可\",{\"1\":{\"7\":1}}],[\"而我们想以更加现代\",{\"1\":{\"0\":1}}],[\"而操作系统调度基本也一样有任务切换\",{\"1\":{\"5\":1}}],[\"同一个\",{\"1\":{\"46\":1}}],[\"同一时刻只能有一个线程执行\",{\"1\":{\"27\":1}}],[\"同一时间只有一个线程执行\",{\"1\":{\"26\":1}}],[\"同步的\",{\"1\":{\"25\":1}}],[\"同步操作对于并发编程至关重要\",{\"1\":{\"62\":1}}],[\"同步操作\",{\"0\":{\"39\":1},\"1\":{\"1\":1,\"39\":1}}],[\"同时开始修改变量\",{\"1\":{\"64\":1}}],[\"同时\",{\"1\":{\"57\":1,\"62\":1,\"74\":1}}],[\"同时我们讲述了一些避免死锁的方法和技术\",{\"1\":{\"38\":1}}],[\"同时扩展知识面\",{\"1\":{\"37\":1}}],[\"同时它还提供一个有额外std\",{\"1\":{\"27\":1}}],[\"同时上锁\",{\"1\":{\"27\":1}}],[\"同时阻止了移动等函数的隐式定义\",{\"1\":{\"27\":1}}],[\"同时也能解释其使用与学习中的各种问题\",{\"1\":{\"17\":1}}],[\"同时会阻止移动构造函数和移动赋值运算符的隐式定义\",{\"1\":{\"13\":1}}],[\"同时执行任务\",{\"1\":{\"5\":1}}],[\"同样\",{\"1\":{\"41\":1}}],[\"同样的\",{\"1\":{\"35\":1,\"45\":1,\"50\":1}}],[\"同样支持\",{\"1\":{\"34\":1}}],[\"同样允许在对象销毁之前就解锁互斥量\",{\"1\":{\"32\":1}}],[\"同样可以作为构造\",{\"1\":{\"12\":1}}],[\"同样因为\",{\"1\":{\"10\":1}}],[\"任务开始执行\",{\"1\":{\"60\":1}}],[\"任务与\",{\"1\":{\"44\":1}}],[\"任务在线程中执行\",{\"1\":{\"44\":1,\"52\":1}}],[\"任务并不会在线程中执行\",{\"1\":{\"44\":1}}],[\"任务切换会给你一种\",{\"1\":{\"5\":1}}],[\"任何持有与这个\",{\"1\":{\"21\":1}}],[\"任何组织和个人遵守\",{\"1\":{\"0\":1}}],[\"那这两个的共同点是什么呢\",{\"1\":{\"84\":1}}],[\"那是不现实的\",{\"1\":{\"81\":1}}],[\"那会显得文章很冗长\",{\"1\":{\"81\":1}}],[\"那自然是全方面的\",{\"1\":{\"74\":1}}],[\"那有没有可能\",{\"1\":{\"71\":1}}],[\"那它等价于\",{\"1\":{\"50\":1}}],[\"那我们就提一下\",{\"1\":{\"49\":1}}],[\"那我们就讲第二种\",{\"1\":{\"6\":1}}],[\"那时开发者通常使用\",{\"1\":{\"37\":1}}],[\"那只有一种可能\",{\"1\":{\"16\":1}}],[\"那里的\",{\"1\":{\"12\":1}}],[\"那就打印超时\",{\"1\":{\"50\":1}}],[\"那就记住\",{\"1\":{\"33\":1}}],[\"那就先执行完\",{\"1\":{\"18\":1}}],[\"那就调用\",{\"1\":{\"12\":1}}],[\"那就只能是任务切换\",{\"1\":{\"5\":1}}],[\"那么到此也就够了\",{\"1\":{\"84\":1}}],[\"那么第一个线程调用\",{\"1\":{\"67\":1}}],[\"那么依赖这个结果的代码需要显式地进行加载\",{\"1\":{\"67\":1}}],[\"那么我们可以利用这一点进行性能优化\",{\"1\":{\"65\":1}}],[\"那么我们稍微聊一下\",{\"1\":{\"14\":1}}],[\"那么不可能有性能的提升\",{\"1\":{\"65\":1}}],[\"那么不就卡界面了\",{\"1\":{\"57\":1}}],[\"那么执行\",{\"1\":{\"58\":2}}],[\"那么它的\",{\"1\":{\"48\":1}}],[\"那么它的线程安全就要我们来保证\",{\"1\":{\"36\":1}}],[\"那么将阻塞当前线程\",{\"1\":{\"45\":1}}],[\"那么一切都不成问题\",{\"1\":{\"44\":1}}],[\"那么一样存在数据竞争\",{\"1\":{\"36\":1}}],[\"那么在完整表达式结尾\",{\"1\":{\"43\":1}}],[\"那么系统可能会选择延迟执行\",{\"1\":{\"43\":1}}],[\"那么系统可能会选择在新线程中执行任务\",{\"1\":{\"43\":1}}],[\"那么当前线程会重新获取锁\",{\"1\":{\"40\":1}}],[\"那么你要如何在正确的站点下车呢\",{\"1\":{\"40\":1}}],[\"那么你不是还得执行一个\",{\"1\":{\"12\":1}}],[\"那么函数\",{\"1\":{\"32\":1}}],[\"那么函数局部对象的生存期都已经结束了\",{\"1\":{\"12\":1}}],[\"那么可以考虑使用\",{\"1\":{\"31\":1}}],[\"那么灵活在哪\",{\"1\":{\"31\":1}}],[\"那么接下来看析构函数\",{\"1\":{\"31\":1}}],[\"那么这个线程在①的时候就不会进入\",{\"1\":{\"33\":1}}],[\"那么这个遥控汽车就谁都没有办法玩\",{\"1\":{\"30\":1}}],[\"那么这个互斥量就处于解锁状态\",{\"1\":{\"26\":1}}],[\"那么线程\",{\"1\":{\"27\":1}}],[\"那么问题来了\",{\"1\":{\"27\":1}}],[\"那么其他线程此时也就能再有一个成功调用\",{\"1\":{\"26\":1}}],[\"那么程序的行为未定义\",{\"1\":{\"25\":1}}],[\"那么就都不存在问题\",{\"1\":{\"58\":1}}],[\"那么就可以启动新线程计算\",{\"1\":{\"43\":1}}],[\"那么就是线程对象放弃了对线程资源的所有权\",{\"1\":{\"12\":1}}],[\"那么就当做有关联活跃线程\",{\"1\":{\"9\":1}}],[\"那么回到我们最初的\",{\"1\":{\"12\":1}}],[\"那么编译器会将此语法解析为函数声明\",{\"1\":{\"12\":1}}],[\"那么\",{\"1\":{\"10\":1,\"12\":1,\"14\":1,\"37\":1,\"65\":1}}],[\"那多进程呢\",{\"1\":{\"3\":1}}],[\"多数函数都对两种超时方式进行处理\",{\"1\":{\"47\":1}}],[\"多一次\",{\"1\":{\"35\":1}}],[\"多个对象可以指代同一个共享状态\",{\"1\":{\"46\":1}}],[\"多个线程能在不同的\",{\"1\":{\"62\":1}}],[\"多个线程的等待\",{\"0\":{\"46\":1}}],[\"多个线程同时对其进行访问和修改时\",{\"1\":{\"36\":1}}],[\"多个线程可以一起读取\",{\"1\":{\"34\":1}}],[\"多个互斥量才可能遇到死锁问题\",{\"1\":{\"30\":1}}],[\"多次\",{\"1\":{\"33\":1}}],[\"多了一个解除阻塞的可能\",{\"1\":{\"47\":1}}],[\"多了一个\",{\"1\":{\"31\":1}}],[\"多记忆\",{\"1\":{\"23\":1}}],[\"多线程读取\",{\"1\":{\"34\":1}}],[\"多线程可以安全的调用\",{\"1\":{\"33\":1}}],[\"多线程共享数据的问题\",{\"1\":{\"24\":1}}],[\"多线程执行就是如此\",{\"1\":{\"18\":1}}],[\"多线程增加了这个问题发生的几率\",{\"1\":{\"12\":1}}],[\"多线程求和只需要介绍三个地方\",{\"1\":{\"10\":1}}],[\"多线程编程\",{\"1\":{\"3\":1}}],[\"多核机器的真正并行\",{\"1\":{\"5\":1}}],[\"在上一节讲\",{\"1\":{\"84\":1}}],[\"在上一章内容\",{\"1\":{\"24\":1}}],[\"在64\",{\"1\":{\"79\":1}}],[\"在运行程序时\",{\"1\":{\"71\":1}}],[\"在开始学习之前\",{\"1\":{\"71\":1}}],[\"在开发带有\",{\"1\":{\"51\":1}}],[\"在后续章节中\",{\"1\":{\"65\":1}}],[\"在后续我们详细介绍\",{\"1\":{\"16\":1}}],[\"在后面的内容会详细讲述\",{\"1\":{\"65\":1}}],[\"在后面详细的展开使用\",{\"1\":{\"65\":1}}],[\"在一些情况下\",{\"1\":{\"65\":1}}],[\"在高频交易系统\",{\"1\":{\"65\":1}}],[\"在实际应用中\",{\"1\":{\"65\":1}}],[\"在预处理阶段就选择执行合适的代码\",{\"1\":{\"65\":1}}],[\"在编译时对各种整数原子类型是否无锁进行判断\",{\"1\":{\"65\":1}}],[\"在下节我们会详细讲解\",{\"1\":{\"64\":1}}],[\"在之前的内容中\",{\"1\":{\"64\":1}}],[\"在讨论了\",{\"1\":{\"62\":1}}],[\"在并发编程中\",{\"1\":{\"62\":1}}],[\"在创建对象的时候初始化计数器的值\",{\"1\":{\"60\":1}}],[\"在创建线程执行之前先定义了一个开始迭代器\",{\"1\":{\"10\":1}}],[\"在此方面可把信号量当作条件变量的替代品\",{\"1\":{\"58\":1}}],[\"在各种编程语言中都有自己的抽象实现\",{\"1\":{\"58\":1}}],[\"在启动进度条后\",{\"1\":{\"52\":1}}],[\"在讲述它的使用细节之前\",{\"1\":{\"47\":1}}],[\"在多个线程中对同一个\",{\"1\":{\"46\":2}}],[\"在多线程编程中\",{\"1\":{\"39\":1}}],[\"在多线程的情况下\",{\"1\":{\"25\":1}}],[\"在需要的时候获取返回值\",{\"1\":{\"44\":1}}],[\"在需要快速响应的程序中就意味着丢帧或错过了一个时间片\",{\"1\":{\"40\":1}}],[\"在不同硬件上有不同的值\",{\"1\":{\"48\":1}}],[\"在不同线程上执行异步任务\",{\"1\":{\"43\":1}}],[\"在不同作用域传递互斥量\",{\"0\":{\"32\":1}}],[\"在执行\",{\"1\":{\"41\":1}}],[\"在本节中\",{\"1\":{\"41\":1}}],[\"在循环中等待并判断条件可一并解决\",{\"1\":{\"40\":1}}],[\"在规定时间内等待\",{\"1\":{\"39\":1}}],[\"在临界区中\",{\"1\":{\"38\":1}}],[\"在持有锁的情况下\",{\"1\":{\"30\":1}}],[\"在无保护的情况下访问保护数据\",{\"1\":{\"29\":1}}],[\"在大多数情况下\",{\"1\":{\"25\":1}}],[\"在函数中调用\",{\"1\":{\"16\":1}}],[\"在调用\",{\"1\":{\"14\":1}}],[\"在析构时自动调用\",{\"1\":{\"19\":1}}],[\"在析构的时候进行了\",{\"1\":{\"13\":1}}],[\"在析构函数中使用\",{\"1\":{\"13\":1}}],[\"在异常处理过程中调用\",{\"1\":{\"12\":1}}],[\"在单线程的代码中\",{\"1\":{\"12\":1}}],[\"在线程\",{\"1\":{\"64\":1}}],[\"在线程调用\",{\"1\":{\"35\":1}}],[\"在线程退出时释放所有分配的资源\",{\"1\":{\"12\":1}}],[\"在线程对象构造成功\",{\"1\":{\"9\":1}}],[\"在确定每个形参的类型后\",{\"1\":{\"12\":1}}],[\"在\",{\"1\":{\"11\":1,\"13\":1,\"15\":1,\"37\":1,\"40\":2,\"43\":1,\"48\":2,\"49\":2,\"50\":1,\"52\":1,\"58\":1,\"60\":1,\"65\":1,\"66\":5}}],[\"在传递给线程执行的lambda表达式中\",{\"1\":{\"10\":1}}],[\"在进行多线程编程时\",{\"1\":{\"10\":1}}],[\"在新线程中执行函数\",{\"1\":{\"14\":1}}],[\"在新线程中执行\",{\"1\":{\"9\":1}}],[\"在我们之前讲的\",{\"1\":{\"84\":1}}],[\"在我们初学\",{\"1\":{\"9\":1}}],[\"在我们谈起\",{\"1\":{\"3\":1}}],[\"在标准\",{\"1\":{\"8\":1}}],[\"在现在\",{\"1\":{\"5\":1}}],[\"在早期\",{\"1\":{\"5\":1}}],[\"在计算机中的并发\",{\"0\":{\"5\":1}}],[\"也希望者能让读者避免获取二手知识与理解\",{\"1\":{\"74\":1}}],[\"也得在可观测行为发生前回溯了\",{\"1\":{\"71\":1}}],[\"也会对指令进行重排\",{\"1\":{\"71\":1}}],[\"也会稍微涉及一些其它库\",{\"1\":{\"3\":1}}],[\"也能带来更高的性能\",{\"1\":{\"65\":1}}],[\"也执行了递增操作\",{\"1\":{\"64\":1}}],[\"也提供了屏障机制来支持多线程编程\",{\"1\":{\"59\":1}}],[\"也很好理解\",{\"1\":{\"49\":1}}],[\"也同\",{\"1\":{\"46\":1}}],[\"也需要确保没有其他线程正在执行\",{\"1\":{\"41\":1}}],[\"也称\",{\"1\":{\"40\":1}}],[\"也肯定无法使用\",{\"1\":{\"37\":1}}],[\"也必须是老老实实上锁解锁\",{\"1\":{\"34\":1}}],[\"也有两个超时的版本\",{\"1\":{\"47\":1}}],[\"也有局限性\",{\"1\":{\"46\":1}}],[\"也有人喜欢称作\",{\"1\":{\"37\":1}}],[\"也有一些例外情况\",{\"1\":{\"33\":1}}],[\"也有专门的保护方式\",{\"1\":{\"33\":1}}],[\"也有可能先执行\",{\"1\":{\"25\":1}}],[\"也在等待函数\",{\"1\":{\"30\":1}}],[\"也完全有可能连续\",{\"1\":{\"27\":1}}],[\"也一样会有问题\",{\"1\":{\"25\":1}}],[\"也是完全可以的\",{\"1\":{\"65\":1}}],[\"也是完全可行\",{\"1\":{\"32\":1}}],[\"也是最好的\",{\"1\":{\"40\":1}}],[\"也是良性竞争\",{\"1\":{\"25\":1}}],[\"也是默认按值复制的\",{\"1\":{\"14\":1}}],[\"也没问题\",{\"1\":{\"12\":1}}],[\"也不能保证它在其他平台上也能表现良好\",{\"1\":{\"71\":1}}],[\"也不要求一定是函数\",{\"1\":{\"33\":1}}],[\"也不要想着\",{\"1\":{\"12\":1}}],[\"也不需要会什么元编程\",{\"1\":{\"73\":1,\"81\":1}}],[\"也不需要上锁\",{\"1\":{\"27\":1}}],[\"也不需要再次\",{\"1\":{\"12\":1}}],[\"也不成问题\",{\"1\":{\"0\":1}}],[\"也就移动传递参数\",{\"1\":{\"43\":1}}],[\"也就可以了\",{\"1\":{\"41\":1,\"44\":1}}],[\"也就足够了\",{\"1\":{\"12\":1}}],[\"也就是弃值表达式\",{\"1\":{\"84\":1}}],[\"也就是有三个版本\",{\"1\":{\"83\":1}}],[\"也就是置空\",{\"1\":{\"80\":1}}],[\"也就是允许\",{\"1\":{\"58\":1}}],[\"也就是其它线程执行了\",{\"1\":{\"58\":1}}],[\"也就是等待到一个时间点\",{\"1\":{\"50\":1}}],[\"也就是分子与分母\",{\"1\":{\"48\":1}}],[\"也就是一个时钟所用的秒数\",{\"1\":{\"49\":1}}],[\"也就是一个\",{\"1\":{\"44\":1}}],[\"也就是一个线程\",{\"1\":{\"41\":1}}],[\"也就是就算全是读的情况\",{\"1\":{\"34\":1}}],[\"也就是说我们可以这样初始化\",{\"1\":{\"66\":1}}],[\"也就是说在多线程中可能会被另一个线程观察到只完成一半\",{\"1\":{\"64\":1}}],[\"也就是说第二个参数的实际类型是\",{\"1\":{\"50\":1}}],[\"也就是说虽然最初的那段代码看似什么都没调用\",{\"1\":{\"21\":1}}],[\"也就是说\",{\"1\":{\"14\":1,\"31\":1,\"79\":1}}],[\"也就是线程对象没有关联活跃线程了\",{\"1\":{\"12\":1}}],[\"也就是构造\",{\"1\":{\"12\":1}}],[\"也就是\",{\"1\":{\"12\":1,\"17\":1,\"20\":1,\"23\":1,\"30\":1,\"31\":1,\"44\":1,\"46\":1,\"80\":1,\"84\":1}}],[\"也就是我们要进行求和的元素个数了\",{\"1\":{\"10\":1}}],[\"也就是真正的\",{\"1\":{\"5\":1}}],[\"也可以换为更加通用常见的\",{\"1\":{\"67\":1}}],[\"也可以使用原子类型的别名\",{\"1\":{\"65\":1}}],[\"也可以在线程中传递\",{\"1\":{\"44\":1}}],[\"也可以处于解锁\",{\"1\":{\"26\":1}}],[\"也可以直接叫函数对象\",{\"1\":{\"12\":1}}],[\"也可以两只手同时做不同的动作\",{\"1\":{\"4\":1}}],[\"也意味着这颗\",{\"1\":{\"10\":1}}],[\"我再说一遍\",{\"1\":{\"66\":1}}],[\"我尽量以简单通俗的方式进行讲解\",{\"1\":{\"23\":1}}],[\"我在\",{\"1\":{\"12\":1}}],[\"我知道你会有问题\",{\"1\":{\"37\":1}}],[\"我知道你肯定有疑问\",{\"1\":{\"20\":1}}],[\"我知道你可能会想到\",{\"1\":{\"12\":1}}],[\"我知道你可能有很多疑问\",{\"1\":{\"12\":1}}],[\"我知道你或许有疑问\",{\"1\":{\"3\":1}}],[\"我相信你可能对\",{\"1\":{\"32\":1}}],[\"我相信你也发现了\",{\"1\":{\"12\":1}}],[\"我相信本章也一定可以让你收获良多\",{\"1\":{\"23\":1}}],[\"我相信\",{\"1\":{\"12\":1}}],[\"我喜欢第二种\",{\"1\":{\"6\":1}}],[\"我们使用\",{\"1\":{\"80\":1}}],[\"我们使用了多线程读写\",{\"1\":{\"34\":1}}],[\"我们以\",{\"1\":{\"78\":1}}],[\"我们会收集捐赠者进行感谢\",{\"1\":{\"77\":1}}],[\"我们提供的链接基本都是较为专业的文档或官方网站\",{\"1\":{\"74\":1}}],[\"我们强调了模板\",{\"1\":{\"73\":1}}],[\"我们假设读者最低水平为\",{\"1\":{\"73\":1}}],[\"我们无需在意\",{\"1\":{\"71\":1}}],[\"我们无需手动控制\",{\"1\":{\"9\":1}}],[\"我们知道即可\",{\"1\":{\"66\":1}}],[\"我们可能会选择其它同步机制\",{\"1\":{\"65\":1}}],[\"我们可以自己简单实现一下它\",{\"1\":{\"84\":1}}],[\"我们可以开始进入正式的学习内容了\",{\"1\":{\"76\":1}}],[\"我们可以简单的使用测试一下\",{\"1\":{\"66\":1}}],[\"我们可以尝试使用一下它\",{\"1\":{\"65\":1}}],[\"我们可以考虑以下优化策略\",{\"1\":{\"65\":1}}],[\"我们可以更放心地在性能关键的代码路径中使用它\",{\"1\":{\"65\":1}}],[\"我们可以这么做\",{\"1\":{\"44\":1}}],[\"我们可以给一个简单的示意图帮助你理解这段运行结果\",{\"1\":{\"41\":1}}],[\"我们可以写一个经典的\",{\"1\":{\"41\":1}}],[\"我们可以在构造函数中使用\",{\"1\":{\"36\":1}}],[\"我们可以通过一些简单的规则\",{\"1\":{\"30\":1}}],[\"我们可以使用静态断言\",{\"1\":{\"65\":1}}],[\"我们可以使用这些宏来对代码进行编译时的优化和检查\",{\"1\":{\"65\":1}}],[\"我们可以使用信号量来限制并发请求的数量\",{\"1\":{\"58\":1}}],[\"我们可以使用\",{\"1\":{\"27\":1,\"52\":1}}],[\"我们可以使用互斥量解决这个问题\",{\"1\":{\"26\":1}}],[\"我们可以使用标准库的设施\",{\"1\":{\"14\":1}}],[\"我们可以改成下面这样\",{\"1\":{\"15\":1}}],[\"我们可以打印地址来验证我们的猜想\",{\"1\":{\"14\":1}}],[\"我们可以提供一个类\",{\"1\":{\"13\":1}}],[\"我们可以举个简单的例子运用这个值\",{\"1\":{\"10\":1}}],[\"我们可以参考此值来确定创建的线程数量\",{\"1\":{\"10\":1}}],[\"我们可以轻易的创建线程执行任务\",{\"1\":{\"9\":1}}],[\"我们可以启动一个线程来做这件事情\",{\"1\":{\"9\":1}}],[\"我们可以一边走路一边说话\",{\"1\":{\"4\":1}}],[\"我们想要的是一种原子类型\",{\"1\":{\"64\":1}}],[\"我们想使用\",{\"1\":{\"12\":1}}],[\"我们讲述了使用很多同步设施\",{\"1\":{\"64\":1}}],[\"我们这单章是为了专门解释一下\",{\"1\":{\"78\":1}}],[\"我们这段代码设置的是\",{\"1\":{\"58\":1}}],[\"我们这里的源码解析涉及到的\",{\"1\":{\"81\":1}}],[\"我们这里的设计比较简单\",{\"1\":{\"10\":1}}],[\"我们这里使用到的\",{\"1\":{\"10\":1}}],[\"我们举一个简单的例子来使用一下\",{\"1\":{\"58\":1}}],[\"我们举一个例子\",{\"1\":{\"27\":1}}],[\"我们就能利用折叠表达式展开形参包并对其调用\",{\"1\":{\"84\":1}}],[\"我们就可以进行调用了\",{\"1\":{\"80\":1}}],[\"我们就直接使用了\",{\"1\":{\"56\":1}}],[\"我们就拿先前的代码改成使用\",{\"1\":{\"37\":1}}],[\"我们设置的是等待到当前时间往后\",{\"1\":{\"50\":1}}],[\"我们设计了一个名为\",{\"1\":{\"41\":1}}],[\"我们进行了一个显式的转换\",{\"1\":{\"50\":1}}],[\"我们分\",{\"1\":{\"47\":1}}],[\"我们写了一个简单的示例\",{\"1\":{\"65\":1}}],[\"我们写了这样一个求和函数\",{\"1\":{\"10\":1}}],[\"我们写的是\",{\"1\":{\"45\":1}}],[\"我们套了一个\",{\"1\":{\"44\":1}}],[\"我们一步一步来\",{\"1\":{\"44\":1}}],[\"我们再将第二章实现的并行\",{\"1\":{\"44\":1}}],[\"我们再介绍两个常见问题即可\",{\"1\":{\"43\":1}}],[\"我们再举个例子\",{\"1\":{\"31\":1}}],[\"我们将更详细地讨论一些版本\",{\"1\":{\"65\":1}}],[\"我们将参数使用\",{\"1\":{\"43\":1}}],[\"我们将开始讲述同步操作\",{\"1\":{\"38\":1}}],[\"我们下面详细聊一下\",{\"1\":{\"43\":1}}],[\"我们需要强调一些基本的认识\",{\"1\":{\"71\":1}}],[\"我们需要在调用\",{\"1\":{\"44\":1}}],[\"我们需要使用条件变量来传递一个谓词\",{\"1\":{\"41\":1}}],[\"我们需要考虑以下两个关键点\",{\"1\":{\"41\":1}}],[\"我们介绍了一个更为复杂的示例\",{\"1\":{\"41\":1}}],[\"我们应当使用\",{\"1\":{\"37\":1}}],[\"我们直接调用它自然不成问题\",{\"1\":{\"36\":1}}],[\"我们直接聊这个所谓的\",{\"1\":{\"21\":1}}],[\"我们也查看了\",{\"1\":{\"82\":1}}],[\"我们也没办法每一个都单独讲\",{\"1\":{\"81\":1}}],[\"我们也完全可以自定义类型创建对应的原子对象\",{\"1\":{\"65\":1}}],[\"我们也可以使用\",{\"1\":{\"35\":1}}],[\"我们也不打算特别介绍什么\",{\"1\":{\"7\":1}}],[\"我们重点的强调了一下这两个成员函数的这个概念\",{\"1\":{\"35\":1}}],[\"我们不想为各位介绍其它乱七八糟的各种保护初始化的方式\",{\"1\":{\"33\":1}}],[\"我们不详细介绍他们的实现\",{\"1\":{\"14\":1}}],[\"我们通常就不会用互斥量\",{\"1\":{\"33\":1}}],[\"我们说的无非是调用\",{\"1\":{\"32\":1}}],[\"我们当然不在乎小孩抢玩具\",{\"1\":{\"30\":1}}],[\"我们传递的函数就不该是涉及外部副作用的\",{\"1\":{\"29\":1}}],[\"我们定义复制构造与复制赋值为弃置函数\",{\"1\":{\"27\":1}}],[\"我们来看看\",{\"1\":{\"80\":1}}],[\"我们来看它在\",{\"1\":{\"27\":1}}],[\"我们来使用它\",{\"1\":{\"66\":1}}],[\"我们来展示一下\",{\"1\":{\"43\":1}}],[\"我们来展示使用\",{\"1\":{\"43\":1}}],[\"我们来解释一下\",{\"1\":{\"14\":1}}],[\"我们本章\",{\"1\":{\"24\":1}}],[\"我们本节的难点只在于使用到了一些\",{\"1\":{\"22\":1}}],[\"我们对于线程的基本使用和管理\",{\"1\":{\"24\":1}}],[\"我们觉得这一个小例子所牵扯到的内容也就足够了\",{\"1\":{\"22\":1}}],[\"我们并没有举很多的例子\",{\"1\":{\"22\":1}}],[\"我们存储一个\",{\"1\":{\"18\":1}}],[\"我们用\",{\"1\":{\"27\":1}}],[\"我们用源码实现为各位从头讲解\",{\"1\":{\"17\":1}}],[\"我们用一个简单的示例为你展示\",{\"1\":{\"12\":1}}],[\"我们上一个大节讲解了线程管理\",{\"1\":{\"17\":1}}],[\"我们上一节的示例是传递了一个函数给\",{\"1\":{\"12\":1}}],[\"我们在新线程中通过调用\",{\"1\":{\"45\":1}}],[\"我们在车站等车\",{\"1\":{\"42\":1}}],[\"我们在后续管理多个互斥量\",{\"1\":{\"27\":1}}],[\"我们在函数\",{\"1\":{\"16\":1}}],[\"我们在教学中可能常常为您展示部分标准库源码\",{\"1\":{\"0\":1}}],[\"我们只需要保证一开始提到的两点就行了\",{\"1\":{\"41\":1}}],[\"我们只需要介绍\",{\"1\":{\"16\":1}}],[\"我们只介绍三种\",{\"1\":{\"33\":1}}],[\"我们只是稍微的讲一下使用\",{\"1\":{\"66\":1}}],[\"我们只是告诉各位可能的情况\",{\"1\":{\"29\":1}}],[\"我们只是确保函数\",{\"1\":{\"12\":1}}],[\"我们后续会经常看到这些函数的使用\",{\"1\":{\"15\":1}}],[\"我们延时\",{\"1\":{\"15\":1}}],[\"我们要了解\",{\"1\":{\"31\":1}}],[\"我们要聊的是线程对锁的竞争\",{\"1\":{\"30\":1}}],[\"我们要尽可能的让互斥量上锁的粒度小\",{\"1\":{\"27\":1}}],[\"我们要特别强调\",{\"1\":{\"14\":1}}],[\"我们要明白\",{\"1\":{\"14\":1}}],[\"我们要判断\",{\"1\":{\"13\":1}}],[\"我们还是一样的\",{\"1\":{\"82\":1}}],[\"我们还是要来先聊一下\",{\"1\":{\"47\":1}}],[\"我们还要先知道\",{\"1\":{\"31\":1}}],[\"我们还可以使用移动赋值来转移线程资源的所有权\",{\"1\":{\"16\":1}}],[\"我们还可以使用模板函数\",{\"1\":{\"14\":1}}],[\"我们还得测试运行\",{\"1\":{\"41\":1}}],[\"我们还得处理线程运行后的异常问题\",{\"1\":{\"12\":1}}],[\"我们还得考虑一个问题\",{\"1\":{\"10\":1}}],[\"我们自然希望能引用调用方传递的参数\",{\"1\":{\"14\":1}}],[\"我们前面一直没有使用\",{\"1\":{\"43\":1}}],[\"我们前面也说了\",{\"1\":{\"32\":1}}],[\"我们前面也都写了\",{\"1\":{\"14\":1}}],[\"我们前面提到了\",{\"1\":{\"31\":1}}],[\"我们前面代码会调用构造函数\",{\"1\":{\"31\":1}}],[\"我们前面聊的很清楚了\",{\"1\":{\"12\":1}}],[\"我们才会执行\",{\"1\":{\"13\":1}}],[\"我们理所应当再次抛出\",{\"1\":{\"12\":1}}],[\"我们既然\",{\"1\":{\"12\":1}}],[\"我们聊一下\",{\"1\":{\"12\":1}}],[\"我们先前讲的\",{\"1\":{\"42\":1}}],[\"我们先前使用的就是\",{\"1\":{\"12\":1}}],[\"我们先获取了迭代器所指向的值的类型\",{\"1\":{\"10\":1}}],[\"我们必须在线程对象的生存期结束之前\",{\"1\":{\"12\":1}}],[\"我们显然没办法直接像函数使用函数名一样\",{\"1\":{\"12\":1}}],[\"我们的标准库的那些互斥量unlock\",{\"1\":{\"84\":1}}],[\"我们的教程中常常会提供\",{\"1\":{\"74\":1}}],[\"我们的教程中常包含许多外部链接\",{\"1\":{\"74\":1}}],[\"我们的代码风格较为简洁明了\",{\"1\":{\"75\":1}}],[\"我们的代码因为调用了\",{\"1\":{\"31\":1}}],[\"我们的代码均会测试三大编译器\",{\"1\":{\"0\":1}}],[\"我们的使用代码是多个线程执行这两个函数\",{\"1\":{\"27\":1}}],[\"我们的这段代码就可以通过编译\",{\"1\":{\"21\":1}}],[\"我们的测试代码是捕获了异常的\",{\"1\":{\"13\":1}}],[\"我们的线程对象都没有线程\",{\"1\":{\"12\":1}}],[\"我们的\",{\"1\":{\"10\":1,\"12\":1,\"46\":1,\"66\":1}}],[\"我们慢慢介绍\",{\"1\":{\"9\":1}}],[\"我们现在的\",{\"1\":{\"5\":1}}],[\"我们日常使用的机器\",{\"1\":{\"5\":1}}],[\"我们主要使用标准\",{\"1\":{\"3\":1}}],[\"我们希望您的编译器版本和标准尽可能的高\",{\"1\":{\"0\":1}}],[\"我们几乎是从头教学\",{\"1\":{\"0\":1}}],[\"与原子对象的值相等\",{\"1\":{\"71\":1}}],[\"与编译器当神经病\",{\"1\":{\"71\":1}}],[\"与编译器不是神经病\",{\"1\":{\"71\":1}}],[\"与信号量类似\",{\"1\":{\"59\":1}}],[\"与屏障\",{\"1\":{\"59\":1}}],[\"与常规的\",{\"1\":{\"28\":1}}],[\"与线程\",{\"1\":{\"27\":1}}],[\"与其配合使用的对象\",{\"1\":{\"14\":1}}],[\"与\",{\"0\":{\"44\":1,\"86\":1},\"1\":{\"1\":1,\"16\":1,\"27\":1,\"30\":1,\"34\":1,\"35\":1,\"37\":3,\"41\":3,\"43\":1,\"44\":2,\"45\":1,\"46\":1,\"47\":1,\"58\":1,\"66\":1,\"67\":2,\"74\":1,\"76\":1}}],[\"的确\",{\"1\":{\"84\":1}}],[\"的确算是没问题\",{\"1\":{\"29\":1}}],[\"的旧值用以初始化当前对象的数据成员\",{\"1\":{\"80\":1}}],[\"的结果就可能是\",{\"1\":{\"81\":1}}],[\"的结果就是\",{\"1\":{\"49\":1}}],[\"的结果应该为\",{\"1\":{\"79\":1}}],[\"的东西\",{\"1\":{\"78\":1}}],[\"的一些库\",{\"1\":{\"78\":1}}],[\"的一个特化别名\",{\"1\":{\"58\":1}}],[\"的运行测试链接以确保正确性\",{\"1\":{\"74\":1}}],[\"的程序\",{\"1\":{\"74\":1}}],[\"的程序时\",{\"1\":{\"51\":1}}],[\"的指令重排必须遵循一定的规则\",{\"1\":{\"71\":1}}],[\"的指针\",{\"1\":{\"12\":1}}],[\"的另一个不同是\",{\"1\":{\"67\":1}}],[\"的操作\",{\"1\":{\"67\":1}}],[\"的局限性太强\",{\"1\":{\"66\":1}}],[\"的文章\",{\"1\":{\"66\":1}}],[\"的状态原子地更改为设置\",{\"1\":{\"66\":2}}],[\"的状态原子地更改为清除\",{\"1\":{\"66\":1}}],[\"的状态是确定的\",{\"1\":{\"27\":1}}],[\"的默认构造函数保证对象为\",{\"1\":{\"66\":1}}],[\"的可平凡复制\",{\"1\":{\"65\":1}}],[\"的前缀\",{\"1\":{\"65\":1}}],[\"的静态数据成员\",{\"1\":{\"65\":1}}],[\"的静态成员函数\",{\"1\":{\"10\":1}}],[\"的数据成员的时候已经把这个模板类的全部源码\",{\"1\":{\"84\":1}}],[\"的数据成员\",{\"0\":{\"79\":1,\"83\":1},\"1\":{\"65\":1}}],[\"的数组\",{\"1\":{\"12\":1}}],[\"的非\",{\"1\":{\"62\":1}}],[\"的特化的别名\",{\"1\":{\"58\":1}}],[\"的特殊对象\",{\"1\":{\"26\":1}}],[\"的接收者\",{\"1\":{\"58\":1}}],[\"的响应情况\",{\"1\":{\"57\":1}}],[\"的时间库极其繁杂\",{\"1\":{\"48\":1}}],[\"的时候上锁了\",{\"1\":{\"30\":1}}],[\"的时候上锁\",{\"1\":{\"27\":1}}],[\"的时候\",{\"1\":{\"12\":1,\"14\":1,\"26\":1}}],[\"的时候就关联了一个活跃的线程\",{\"1\":{\"9\":1}}],[\"的时候应该都写过这样一段代码\",{\"1\":{\"9\":1}}],[\"的等待函数\",{\"1\":{\"47\":1}}],[\"的所有权\",{\"1\":{\"46\":1}}],[\"的所有功能\",{\"1\":{\"34\":1}}],[\"的副本\",{\"1\":{\"46\":1}}],[\"的副本了\",{\"1\":{\"46\":1}}],[\"的异常\",{\"1\":{\"45\":2}}],[\"的值都为\",{\"1\":{\"81\":1}}],[\"的值有两种方式\",{\"1\":{\"67\":1}}],[\"的值是多少也不确定\",{\"1\":{\"64\":1}}],[\"的值\",{\"1\":{\"45\":1,\"64\":2}}],[\"的值相比\",{\"1\":{\"20\":1}}],[\"的平方是\",{\"1\":{\"45\":1}}],[\"的形式\",{\"1\":{\"44\":1}}],[\"的形参是谁传递的\",{\"1\":{\"21\":1}}],[\"的形参类型不是\",{\"1\":{\"14\":1}}],[\"的形参会调整为具有类型\",{\"1\":{\"12\":1}}],[\"的重载\",{\"1\":{\"44\":1}}],[\"的执行策略\",{\"1\":{\"43\":1}}],[\"的返回类型就是\",{\"1\":{\"48\":1}}],[\"的返回类型\",{\"1\":{\"42\":1,\"84\":1}}],[\"的视频教程\",{\"1\":{\"42\":1}}],[\"的模板类\",{\"1\":{\"41\":1}}],[\"的泛化\",{\"1\":{\"40\":1}}],[\"的扩展\",{\"1\":{\"37\":1}}],[\"的编译器扩展\",{\"1\":{\"37\":2,\"74\":1}}],[\"的编译器扩展即可\",{\"1\":{\"37\":1}}],[\"的概念源自操作系统\",{\"1\":{\"37\":1}}],[\"的开销是过大的\",{\"1\":{\"34\":1}}],[\"的开发者链接\",{\"1\":{\"21\":1}}],[\"的完整运行示例\",{\"1\":{\"32\":1}}],[\"的移动构造罢了\",{\"1\":{\"32\":1}}],[\"的要求\",{\"1\":{\"32\":1}}],[\"的代码\",{\"1\":{\"30\":1}}],[\"的代码中\",{\"1\":{\"12\":1}}],[\"的互斥量执行完毕才能解锁\",{\"1\":{\"30\":1}}],[\"的互斥量\",{\"1\":{\"30\":7}}],[\"的分支\",{\"1\":{\"28\":1}}],[\"的计算\",{\"1\":{\"27\":1}}],[\"的生存期\",{\"1\":{\"27\":1}}],[\"的实现是最简单直观的\",{\"1\":{\"82\":1}}],[\"的实现只保有一个\",{\"1\":{\"81\":1}}],[\"的实现\",{\"1\":{\"27\":1,\"82\":1}}],[\"的性能和内存占用\",{\"1\":{\"20\":1}}],[\"的通常实现就是单纯的保有\",{\"1\":{\"20\":1}}],[\"的设计哲学\",{\"1\":{\"20\":1}}],[\"的源码解析\",{\"1\":{\"85\":1}}],[\"的源码的时候也提到过\",{\"1\":{\"84\":1}}],[\"的源码实现来配合理解\",{\"1\":{\"22\":1}}],[\"的源码实现与解析\",{\"0\":{\"82\":1},\"1\":{\"1\":1,\"30\":1}}],[\"的源码\",{\"1\":{\"18\":1}}],[\"的区别\",{\"1\":{\"47\":1}}],[\"的区别就如同\",{\"1\":{\"46\":1}}],[\"的区别就是析构函数会自动\",{\"1\":{\"18\":1}}],[\"的区别无非是\",{\"1\":{\"12\":1}}],[\"的使用\",{\"1\":{\"17\":1,\"60\":1}}],[\"的使用了\",{\"1\":{\"10\":1}}],[\"的这次\",{\"1\":{\"16\":1}}],[\"的占用\",{\"1\":{\"15\":1}}],[\"的别名\",{\"1\":{\"15\":1}}],[\"的调用次数一样\",{\"1\":{\"35\":1}}],[\"的调用恰好比\",{\"1\":{\"35\":1}}],[\"的调用将阻塞执行\",{\"1\":{\"26\":1}}],[\"的调用\",{\"1\":{\"14\":1}}],[\"的转换构造函数\",{\"1\":{\"14\":1}}],[\"的线程成功调用\",{\"1\":{\"27\":1}}],[\"的线程得以继续往下执行\",{\"1\":{\"26\":1}}],[\"的线程资源所有权到\",{\"1\":{\"16\":1}}],[\"的线程资源的所有权移交给\",{\"1\":{\"16\":1}}],[\"的线程\",{\"1\":{\"14\":1}}],[\"的缩写\",{\"1\":{\"14\":1}}],[\"的引用\",{\"1\":{\"14\":3,\"80\":1}}],[\"的引用被子线程持有\",{\"1\":{\"12\":1}}],[\"的事情就行\",{\"1\":{\"13\":1}}],[\"的\",{\"1\":{\"12\":2,\"14\":2,\"21\":3,\"25\":1,\"27\":1,\"31\":1,\"44\":1,\"55\":2,\"56\":2,\"67\":1}}],[\"的参数\",{\"1\":{\"12\":1}}],[\"的空参的函数指针类型\",{\"1\":{\"12\":1}}],[\"的类对象\",{\"1\":{\"12\":1}}],[\"的对象就是指代线程的对象\",{\"1\":{\"11\":1}}],[\"的两倍\",{\"1\":{\"10\":1}}],[\"的熟悉程度\",{\"1\":{\"10\":1}}],[\"的简单的模板函数\",{\"1\":{\"10\":1}}],[\"的进行多线程求和\",{\"1\":{\"10\":1}}],[\"的距离\",{\"1\":{\"10\":1}}],[\"的环境运行也可以自行修改为\",{\"1\":{\"10\":1}}],[\"的析构函数将阻塞到异步计算完成\",{\"1\":{\"43\":1}}],[\"的析构函数将调用\",{\"1\":{\"9\":1}}],[\"的析构函数调用\",{\"1\":{\"21\":1}}],[\"的析构函数中\",{\"1\":{\"13\":1,\"21\":1}}],[\"的析构函数\",{\"1\":{\"9\":1,\"27\":1}}],[\"的假象\",{\"1\":{\"5\":1}}],[\"的构造与析构\",{\"0\":{\"84\":1}}],[\"的构造与源码分析最后说的\",{\"1\":{\"82\":1}}],[\"的构造函数\",{\"0\":{\"80\":1}}],[\"的构造函数中成功调用\",{\"1\":{\"27\":1}}],[\"的构造函数中\",{\"1\":{\"14\":1}}],[\"的构造函数中调用了创建线程的函数\",{\"1\":{\"14\":1}}],[\"的构造函数其实并没有申请资源\",{\"1\":{\"13\":1}}],[\"的构造没有问题\",{\"1\":{\"14\":1}}],[\"的构造参数即可\",{\"1\":{\"14\":1}}],[\"的构造\",{\"0\":{\"78\":1},\"1\":{\"1\":1,\"14\":1,\"17\":1}}],[\"的教案\",{\"1\":{\"0\":1}}],[\"tup\",{\"1\":{\"80\":5}}],[\"tuple<int\",{\"1\":{\"84\":1}}],[\"tuple<std\",{\"1\":{\"83\":1}}],[\"tuple<\",{\"1\":{\"83\":1}}],[\"tuple<decay\",{\"1\":{\"80\":2}}],[\"tuple>\",{\"1\":{\"80\":5,\"84\":1}}],[\"tuple\",{\"1\":{\"44\":1,\"80\":12,\"83\":1,\"84\":13}}],[\"tso\",{\"1\":{\"71\":1,\"74\":1}}],[\"ts\",{\"1\":{\"44\":3}}],[\"tlsfree\",{\"1\":{\"37\":1}}],[\"tlsgetvalue\",{\"1\":{\"37\":1}}],[\"tlssetvalue\",{\"1\":{\"37\":1}}],[\"tlsalloc\",{\"1\":{\"37\":1}}],[\"tls\",{\"1\":{\"37\":1}}],[\"t4\",{\"1\":{\"27\":2,\"43\":1}}],[\"t参数的构造函数\",{\"1\":{\"27\":1}}],[\"t3\",{\"1\":{\"25\":1,\"27\":2,\"43\":1}}],[\"t1\",{\"1\":{\"25\":1,\"27\":2,\"28\":2,\"35\":2,\"43\":1}}],[\"t<tuple>>>\",{\"1\":{\"84\":1}}],[\"t<\",{\"1\":{\"21\":4,\"80\":6}}],[\"t<forwardit>\",{\"1\":{\"10\":1,\"44\":1}}],[\"t重载决议\",{\"1\":{\"16\":1}}],[\"t2\",{\"1\":{\"16\":14,\"25\":5,\"27\":2,\"28\":2,\"30\":1,\"35\":2,\"43\":1}}],[\"timeout\",{\"1\":{\"49\":2,\"50\":3}}],[\"timed\",{\"1\":{\"34\":2}}],[\"time\",{\"1\":{\"15\":19,\"47\":1,\"48\":14,\"50\":5,\"58\":2}}],[\"t>\",{\"1\":{\"14\":1,\"41\":1,\"62\":1}}],[\"the\",{\"1\":{\"31\":2,\"66\":1,\"80\":1}}],[\"that\",{\"1\":{\"27\":1,\"66\":2,\"83\":1}}],[\"thr\",{\"1\":{\"58\":1,\"79\":2,\"80\":17}}],[\"thrd\",{\"1\":{\"54\":2,\"56\":1,\"79\":6}}],[\"throw\",{\"1\":{\"12\":4,\"31\":2,\"33\":1,\"45\":6,\"80\":2}}],[\"thread1\",{\"1\":{\"46\":4}}],[\"thread2\",{\"1\":{\"18\":1,\"46\":4}}],[\"thread>threads\",{\"1\":{\"18\":2,\"26\":1}}],[\"thread>\",{\"1\":{\"10\":1,\"26\":1,\"44\":1,\"80\":1}}],[\"threadsafe\",{\"1\":{\"41\":5}}],[\"threads\",{\"1\":{\"10\":9,\"18\":3,\"26\":5,\"44\":9,\"58\":2}}],[\"threading\",{\"1\":{\"10\":1}}],[\"thread\",{\"0\":{\"78\":1},\"1\":{\"1\":1,\"8\":2,\"9\":6,\"10\":6,\"11\":2,\"12\":35,\"13\":16,\"14\":21,\"15\":8,\"16\":26,\"17\":3,\"18\":27,\"19\":1,\"20\":6,\"21\":4,\"23\":2,\"24\":1,\"25\":5,\"26\":6,\"27\":5,\"28\":6,\"30\":2,\"35\":6,\"37\":23,\"40\":3,\"42\":1,\"43\":10,\"44\":6,\"45\":4,\"46\":6,\"47\":2,\"50\":1,\"52\":1,\"54\":1,\"56\":1,\"58\":11,\"60\":2,\"78\":2,\"79\":3,\"80\":21,\"81\":3,\"82\":1,\"84\":2,\"85\":1}}],[\"this\",{\"1\":{\"12\":1,\"15\":7,\"16\":1,\"18\":3,\"21\":2,\"26\":2,\"27\":1,\"28\":1,\"35\":2,\"40\":3,\"41\":2,\"43\":6,\"45\":1,\"46\":2,\"47\":2,\"50\":1,\"52\":7,\"54\":13,\"56\":1,\"58\":3,\"60\":1,\"71\":1}}],[\"torvalds\",{\"1\":{\"66\":1}}],[\"token\",{\"1\":{\"21\":14,\"22\":1,\"23\":1}}],[\"to\",{\"1\":{\"15\":3,\"27\":7,\"48\":2,\"54\":2,\"58\":6,\"80\":4}}],[\"todo\",{\"1\":{\"12\":4,\"14\":3,\"44\":2}}],[\"total\",{\"1\":{\"10\":4,\"44\":5,\"71\":1,\"74\":1}}],[\"tasks\",{\"1\":{\"44\":4}}],[\"task<value\",{\"1\":{\"44\":3}}],[\"task<int\",{\"1\":{\"44\":1}}],[\"task<r\",{\"1\":{\"44\":2}}],[\"task<double\",{\"1\":{\"44\":3}}],[\"task\",{\"1\":{\"12\":8,\"14\":7,\"43\":4,\"44\":22,\"52\":1,\"54\":2,\"62\":1}}],[\"transition\",{\"1\":{\"80\":1}}],[\"transferred\",{\"1\":{\"80\":1}}],[\"traits<forwardit>\",{\"1\":{\"10\":1}}],[\"trivially\",{\"1\":{\"65\":1}}],[\"triviallycopyable\",{\"1\":{\"65\":1}}],[\"trivial\",{\"1\":{\"65\":14}}],[\"try块中的代码抛出了异常\",{\"1\":{\"12\":1}}],[\"trycatch\",{\"1\":{\"12\":1}}],[\"try\",{\"1\":{\"12\":4,\"21\":2,\"28\":3,\"31\":1,\"33\":2,\"41\":1,\"45\":4,\"67\":2,\"80\":2}}],[\"true\",{\"1\":{\"9\":1,\"12\":1,\"28\":1,\"31\":5,\"40\":6,\"43\":1,\"50\":1,\"52\":1,\"54\":1,\"65\":3,\"66\":6,\"67\":16}}],[\"types\",{\"1\":{\"80\":1}}],[\"type>\",{\"1\":{\"65\":7}}],[\"type>>\",{\"1\":{\"44\":1}}],[\"type>>futures\",{\"1\":{\"44\":1}}],[\"type>results\",{\"1\":{\"10\":1}}],[\"typename\",{\"1\":{\"10\":1,\"18\":1,\"44\":2,\"50\":1}}],[\"type\",{\"1\":{\"10\":8,\"27\":1,\"44\":8,\"65\":21,\"81\":2,\"83\":1}}],[\"text\",{\"1\":{\"54\":2}}],[\"test\",{\"1\":{\"14\":4,\"66\":6,\"67\":1}}],[\"terminates\",{\"1\":{\"80\":1}}],[\"terminate\",{\"1\":{\"9\":2,\"13\":1}}],[\"template<\",{\"1\":{\"50\":1,\"84\":1}}],[\"template<class\",{\"1\":{\"29\":1,\"40\":1,\"48\":1,\"84\":2}}],[\"template<typename\",{\"1\":{\"10\":2,\"18\":1,\"41\":1,\"44\":2}}],[\"template\",{\"1\":{\"0\":1,\"21\":1,\"27\":1,\"73\":1,\"80\":4,\"83\":3}}],[\"t\",{\"1\":{\"9\":7,\"10\":6,\"12\":19,\"13\":9,\"14\":22,\"15\":10,\"16\":30,\"18\":19,\"25\":4,\"26\":2,\"27\":2,\"30\":2,\"31\":2,\"36\":5,\"37\":1,\"41\":2,\"43\":3,\"44\":10,\"45\":6,\"48\":6,\"60\":1,\"65\":7,\"79\":6,\"80\":3,\"81\":2,\"83\":5,\"84\":7}}],[\"协程库在\",{\"1\":{\"72\":1}}],[\"协程\",{\"0\":{\"72\":1},\"1\":{\"1\":1}}],[\"协议均可随意使用学习\",{\"1\":{\"0\":1}}],[\"阅读了\",{\"1\":{\"18\":1}}],[\"阅读须知\",{\"0\":{\"73\":1},\"1\":{\"1\":1}}],[\"阅读源码可以帮助我们更轻松的理解标准库设施的使用与原理\",{\"1\":{\"0\":1}}],[\"sfinae\",{\"1\":{\"80\":1}}],[\"space\",{\"1\":{\"66\":1}}],[\"spinlocks\",{\"1\":{\"66\":1}}],[\"spinlock\",{\"1\":{\"66\":4}}],[\"spurious\",{\"1\":{\"40\":1}}],[\"sub\",{\"1\":{\"65\":1}}],[\"sum\",{\"1\":{\"10\":8,\"27\":4,\"44\":7}}],[\"summary\",{\"0\":{\"1\":1}}],[\"schar\",{\"1\":{\"65\":1}}],[\"scoped\",{\"0\":{\"82\":1},\"1\":{\"1\":1,\"27\":3,\"30\":4,\"82\":2,\"83\":26,\"84\":6,\"85\":1}}],[\"short>\",{\"1\":{\"65\":1}}],[\"short\",{\"1\":{\"65\":2}}],[\"share\",{\"1\":{\"46\":2}}],[\"shared<t>\",{\"1\":{\"41\":1}}],[\"shared\",{\"1\":{\"33\":1,\"34\":11,\"38\":1,\"41\":3,\"42\":4,\"46\":30,\"62\":3}}],[\"smph\",{\"1\":{\"58\":6}}],[\"smt\",{\"1\":{\"10\":1}}],[\"satisfied\",{\"1\":{\"45\":2}}],[\"same\",{\"1\":{\"21\":1,\"80\":1}}],[\"square\",{\"1\":{\"45\":2}}],[\"sequence\",{\"1\":{\"80\":2,\"84\":2}}],[\"sequence<std\",{\"1\":{\"84\":1}}],[\"sequence<index\",{\"1\":{\"84\":1}}],[\"sequence<\",{\"1\":{\"80\":1}}],[\"sequence<1\",{\"1\":{\"80\":2}}],[\"seq\",{\"1\":{\"65\":3,\"66\":2}}],[\"semaphore允许同一资源进行多个并发的访问\",{\"1\":{\"58\":1}}],[\"semaphore<3>\",{\"1\":{\"58\":1}}],[\"semaphore<1>\",{\"1\":{\"58\":1}}],[\"semaphore\",{\"1\":{\"58\":13,\"62\":1}}],[\"self\",{\"1\":{\"56\":1}}],[\"second\",{\"1\":{\"49\":1}}],[\"seconds>\",{\"1\":{\"49\":1}}],[\"seconds\",{\"1\":{\"15\":2,\"40\":2,\"45\":1,\"46\":2,\"49\":2,\"50\":1,\"58\":1}}],[\"setupui\",{\"1\":{\"54\":1}}],[\"setspecific\",{\"1\":{\"37\":1}}],[\"set\",{\"1\":{\"34\":1,\"43\":1,\"45\":18,\"66\":6,\"67\":3}}],[\"settings\",{\"1\":{\"34\":1}}],[\"solid\",{\"1\":{\"54\":1}}],[\"some\",{\"1\":{\"32\":4,\"33\":4}}],[\"something\",{\"1\":{\"29\":4,\"33\":3}}],[\"source\",{\"1\":{\"20\":3,\"21\":6,\"22\":1,\"23\":1}}],[\"ssource\",{\"1\":{\"20\":1,\"21\":2}}],[\"swap\",{\"1\":{\"18\":2,\"30\":10,\"31\":3}}],[\"s\",{\"1\":{\"15\":3,\"48\":2,\"49\":2,\"54\":2,\"65\":1,\"80\":2}}],[\"system\",{\"1\":{\"15\":5,\"31\":2,\"48\":6,\"50\":3}}],[\"sleep\",{\"1\":{\"15\":11,\"21\":2,\"28\":1,\"40\":3,\"43\":1,\"45\":1,\"46\":2,\"47\":2,\"50\":1,\"52\":1,\"54\":1,\"58\":3,\"60\":1}}],[\"signed\",{\"1\":{\"65\":1}}],[\"signal\",{\"1\":{\"58\":6}}],[\"simulate\",{\"1\":{\"40\":3}}],[\"simultaneous\",{\"1\":{\"10\":1}}],[\"sizeof\",{\"1\":{\"20\":1,\"79\":1,\"80\":2,\"81\":1}}],[\"size\",{\"1\":{\"10\":9,\"18\":3,\"25\":1,\"26\":2,\"30\":1,\"36\":1,\"44\":7,\"80\":2,\"84\":2}}],[\"st\",{\"0\":{\"86\":1}}],[\"style\",{\"1\":{\"54\":5}}],[\"studio\",{\"1\":{\"53\":1}}],[\"steady\",{\"1\":{\"48\":4,\"50\":4}}],[\"store\",{\"1\":{\"65\":5,\"67\":3,\"71\":1,\"74\":1}}],[\"storage\",{\"1\":{\"37\":1}}],[\"stop\",{\"1\":{\"20\":3,\"21\":25,\"22\":2,\"23\":2}}],[\"status\",{\"1\":{\"49\":4,\"50\":1}}],[\"static\",{\"1\":{\"33\":1,\"65\":6,\"80\":3}}],[\"start\",{\"1\":{\"10\":8,\"21\":2,\"44\":5,\"50\":2,\"52\":1,\"54\":2,\"71\":3,\"80\":5}}],[\"strong\",{\"1\":{\"65\":2,\"67\":6}}],[\"str\",{\"1\":{\"30\":2,\"54\":2}}],[\"strengthened\",{\"1\":{\"27\":1,\"83\":3,\"84\":1}}],[\"string>sf\",{\"1\":{\"46\":1}}],[\"string>p\",{\"1\":{\"46\":1}}],[\"string>\",{\"1\":{\"34\":1,\"46\":4}}],[\"string\",{\"1\":{\"14\":10,\"29\":1,\"30\":2,\"34\":5,\"46\":2,\"54\":2,\"84\":1}}],[\"struct\",{\"1\":{\"12\":2,\"14\":3,\"30\":1,\"36\":1,\"43\":3,\"65\":2,\"75\":1,\"79\":1}}],[\"stdcall\",{\"1\":{\"80\":1}}],[\"std\",{\"0\":{\"78\":1,\"82\":1,\"86\":1},\"1\":{\"1\":4,\"8\":2,\"9\":12,\"10\":24,\"11\":2,\"12\":25,\"13\":7,\"14\":57,\"15\":32,\"16\":36,\"17\":4,\"18\":25,\"19\":2,\"20\":9,\"21\":26,\"22\":2,\"23\":4,\"24\":1,\"25\":13,\"26\":10,\"27\":34,\"28\":11,\"29\":5,\"30\":30,\"31\":30,\"32\":15,\"33\":20,\"34\":19,\"35\":16,\"36\":7,\"37\":4,\"38\":4,\"39\":1,\"40\":27,\"41\":14,\"42\":7,\"43\":72,\"44\":50,\"45\":42,\"46\":57,\"47\":3,\"48\":25,\"49\":22,\"50\":23,\"52\":3,\"54\":6,\"55\":2,\"56\":1,\"58\":25,\"59\":2,\"60\":6,\"62\":2,\"64\":3,\"65\":36,\"66\":21,\"67\":20,\"71\":2,\"75\":2,\"78\":2,\"79\":2,\"80\":30,\"81\":2,\"82\":3,\"83\":13,\"84\":32,\"85\":2}}],[\"stl\",{\"1\":{\"0\":1,\"20\":1,\"21\":1,\"22\":1,\"27\":1,\"31\":1,\"49\":1,\"65\":1,\"66\":1,\"73\":1,\"74\":1,\"78\":1,\"82\":1,\"84\":1}}],[\"++\",{\"1\":{\"65\":1}}],[\"++a\",{\"1\":{\"64\":4}}],[\"++n\",{\"1\":{\"30\":2,\"31\":1,\"33\":1}}],[\"++i\",{\"1\":{\"10\":1,\"12\":1,\"18\":2,\"26\":2,\"41\":2,\"44\":2,\"52\":1,\"54\":1,\"58\":1}}],[\"+=\",{\"1\":{\"12\":1,\"36\":1,\"44\":1,\"65\":1}}],[\"+\",{\"1\":{\"0\":2,\"10\":2,\"15\":1,\"20\":1,\"27\":1,\"41\":66,\"44\":3,\"50\":2,\"53\":1,\"62\":1,\"73\":2,\"74\":1,\"80\":3,\"84\":1}}],[\"本单章专门介绍标准库在\",{\"1\":{\"82\":1}}],[\"本教程长期维护\",{\"1\":{\"76\":1}}],[\"本教程在中文社区的同类型教程中是绝对的第一\",{\"1\":{\"73\":1}}],[\"本教程不保证你学习之后的成果\",{\"1\":{\"73\":1}}],[\"本教程假设开发者的最低水平为\",{\"1\":{\"0\":1}}],[\"本套教程侧重点在于使用\",{\"1\":{\"73\":1}}],[\"本章讨论了多种用于同步操作的工具\",{\"1\":{\"62\":1}}],[\"本章讨论了多线程的共享数据引发的恶性条件竞争会带来的问题\",{\"1\":{\"38\":1}}],[\"本章将讨论如何使用条件变量等待事件\",{\"1\":{\"39\":1}}],[\"本章的主要内容有\",{\"1\":{\"39\":1}}],[\"本章的内容在市面上并不少见\",{\"1\":{\"23\":1}}],[\"本章也完全不用担心\",{\"1\":{\"24\":1}}],[\"本章节主要内容\",{\"1\":{\"24\":1}}],[\"本章节的内容围绕着\",{\"1\":{\"23\":1}}],[\"本身不是原子操作\",{\"1\":{\"64\":1}}],[\"本身是重载了\",{\"1\":{\"44\":1}}],[\"本身就是右值表达式\",{\"1\":{\"16\":1}}],[\"本身就是生成了一个函数对象\",{\"1\":{\"12\":1}}],[\"本身设置使用很简单\",{\"1\":{\"15\":1}}],[\"本节主要广泛介绍\",{\"1\":{\"65\":1}}],[\"本节内容总体来说是很简单的\",{\"1\":{\"16\":1}}],[\"本节代码只是为了学习\",{\"1\":{\"10\":1}}],[\"本节其实是要普及一下计算机常识\",{\"1\":{\"10\":1}}],[\"本仓库用来存放\",{\"1\":{\"0\":1}}],[\"准确的方式进行教学\",{\"1\":{\"0\":1}}],[\"不为空\",{\"1\":{\"80\":1}}],[\"不需要模板的水平有多高\",{\"1\":{\"73\":1,\"81\":1}}],[\"不需要额外的同步设施进行保护\",{\"1\":{\"64\":1}}],[\"不使用构造函数\",{\"1\":{\"71\":1}}],[\"不禁止就是有可能\",{\"1\":{\"71\":1}}],[\"不相等\",{\"1\":{\"67\":1}}],[\"不在乎其返回类型只用来实施它的副作用\",{\"1\":{\"84\":1}}],[\"不在\",{\"1\":{\"54\":1}}],[\"不管使用哪种时钟获取时间\",{\"1\":{\"48\":1}}],[\"不管是\",{\"1\":{\"81\":1}}],[\"不管是书籍\",{\"1\":{\"0\":1}}],[\"不管是否购买课程\",{\"1\":{\"0\":1}}],[\"不确定的\",{\"1\":{\"47\":1}}],[\"不然就会抛出异常\",{\"1\":{\"45\":1}}],[\"不然保护将形同虚设\",{\"1\":{\"29\":1}}],[\"不能复制\",{\"1\":{\"44\":1}}],[\"不能调用\",{\"1\":{\"43\":1}}],[\"不堵塞\",{\"1\":{\"44\":1}}],[\"不给出执行策略就是以\",{\"1\":{\"43\":1}}],[\"不创建线程\",{\"1\":{\"43\":2,\"49\":1}}],[\"不执行\",{\"1\":{\"41\":1}}],[\"不应该执行\",{\"1\":{\"41\":1}}],[\"不包括用户定义的\",{\"1\":{\"36\":1}}],[\"不要在用户空间中使用自旋锁\",{\"1\":{\"66\":1}}],[\"不要\",{\"1\":{\"33\":1}}],[\"不再表示执行线程失去了线程的所有权\",{\"1\":{\"80\":1}}],[\"不再强调\",{\"1\":{\"32\":1}}],[\"不再管理此线程\",{\"1\":{\"12\":1}}],[\"不获得互斥体的所有权\",{\"1\":{\"31\":1}}],[\"不同架构的内存模型\",{\"1\":{\"74\":1}}],[\"不同于通常情况\",{\"1\":{\"67\":1}}],[\"不同于\",{\"1\":{\"58\":1}}],[\"不同线程对同一个互斥量进行锁定时\",{\"1\":{\"35\":1}}],[\"不同\",{\"1\":{\"28\":1}}],[\"不存在一个对象同时被多个线程修改\",{\"1\":{\"27\":1}}],[\"不会造成任何额外开销\",{\"1\":{\"83\":1}}],[\"不会模板\",{\"1\":{\"81\":1,\"82\":1,\"85\":1}}],[\"不会单独使用或直接面向普通开发者\",{\"1\":{\"66\":1}}],[\"不会阻塞\",{\"1\":{\"52\":1}}],[\"不会被其它线程的执行所打断\",{\"1\":{\"26\":1}}],[\"不会被打断\",{\"1\":{\"25\":1}}],[\"不会有任何其他的线程打断这个操作\",{\"1\":{\"26\":1}}],[\"不是同一个\",{\"1\":{\"27\":1}}],[\"不是线程安全的容器\",{\"1\":{\"25\":1}}],[\"不是真的返回引用\",{\"1\":{\"14\":1}}],[\"不完全支持\",{\"1\":{\"21\":1}}],[\"不直接为\",{\"1\":{\"20\":1}}],[\"不可表示一个线程\",{\"1\":{\"80\":1}}],[\"不可能观察到原子操作完成了一半\",{\"1\":{\"63\":1}}],[\"不可能看到正在被add\",{\"1\":{\"27\":1}}],[\"不可能每一个任务都单独给一个核心\",{\"1\":{\"5\":1}}],[\"不可复制不可移动\",{\"1\":{\"32\":1}}],[\"不可复制\",{\"1\":{\"16\":1,\"45\":1,\"80\":1}}],[\"不用为数据竞争而担心\",{\"1\":{\"33\":1}}],[\"不用赘述\",{\"1\":{\"21\":1}}],[\"不用调用\",{\"1\":{\"16\":1}}],[\"不用着急\",{\"1\":{\"15\":1,\"16\":1,\"66\":1}}],[\"不用担心生存期的问题\",{\"1\":{\"14\":1}}],[\"不用担心\",{\"1\":{\"14\":1,\"82\":1}}],[\"不用在乎\",{\"1\":{\"13\":1}}],[\"不用在意\",{\"1\":{\"3\":1,\"60\":1}}],[\"不允许这些操作主要在于\",{\"1\":{\"13\":1}}],[\"不掩盖错误\",{\"1\":{\"12\":1}}],[\"不等待线程结束\",{\"1\":{\"12\":1}}],[\"不过你可能有疑问\",{\"1\":{\"84\":1}}],[\"不过实测\",{\"1\":{\"81\":1}}],[\"不过依然可以自信地说\",{\"1\":{\"73\":1}}],[\"不过并不推荐各位在实践中使用它\",{\"1\":{\"66\":1}}],[\"不过其实我们的\",{\"1\":{\"65\":1}}],[\"不过因为是通用模板\",{\"1\":{\"65\":1}}],[\"不过可以隐式转换成对应的内置类型\",{\"1\":{\"65\":1}}],[\"不过不影响\",{\"1\":{\"46\":1}}],[\"不过这个\",{\"1\":{\"67\":1}}],[\"不过这个重载的返回类型是\",{\"1\":{\"44\":1}}],[\"不过这显然不是我们的重点\",{\"1\":{\"64\":1}}],[\"不过这也不是问题\",{\"1\":{\"16\":1}}],[\"不过也可以单独使用\",{\"1\":{\"44\":1}}],[\"不过引用的并非是局部的n\",{\"1\":{\"43\":1}}],[\"不过引用的不是我们传递的局部对象\",{\"1\":{\"43\":1}}],[\"不过对于处理一个互斥量的情况\",{\"1\":{\"27\":1}}],[\"不过一般不推荐这样显式的\",{\"1\":{\"27\":1}}],[\"不过在\",{\"1\":{\"21\":1}}],[\"不过需要注意\",{\"1\":{\"14\":1}}],[\"不过有件事情需要注意\",{\"1\":{\"12\":1}}],[\"不过我们说了\",{\"1\":{\"10\":1}}],[\"不过使用类似\",{\"1\":{\"10\":1}}],[\"不过\",{\"1\":{\"9\":1,\"37\":1,\"42\":1,\"46\":1,\"65\":1}}],[\"不够准确\",{\"1\":{\"0\":1}}],[\"视频\",{\"1\":{\"0\":1}}],[\"博客\",{\"1\":{\"0\":1}}],[\"国内的\",{\"1\":{\"0\":1}}],[\"捐赠\",{\"1\":{\"0\":1}}],[\"000000\",{\"1\":{\"54\":1}}],[\"01\",{\"1\":{\"47\":1}}],[\"07t12\",{\"1\":{\"47\":1}}],[\"05\",{\"1\":{\"47\":1}}],[\"0>\",{\"1\":{\"21\":1,\"80\":1}}],[\"0\",{\"1\":{\"0\":1,\"10\":5,\"12\":4,\"13\":1,\"14\":4,\"16\":2,\"18\":2,\"25\":2,\"26\":2,\"27\":3,\"33\":1,\"35\":2,\"37\":7,\"41\":7,\"43\":2,\"44\":3,\"45\":1,\"52\":2,\"54\":5,\"58\":10,\"60\":2,\"62\":1,\"64\":1,\"65\":1,\"66\":2,\"75\":2,\"80\":7}}],[\"404\",{\"1\":{\"88\":1}}],[\"40\",{\"1\":{\"65\":1}}],[\"400>\",{\"1\":{\"49\":1}}],[\"4\",{\"1\":{\"0\":1,\"10\":1,\"27\":1,\"33\":1,\"41\":7,\"79\":1}}],[\"nil\",{\"1\":{\"66\":1}}],[\"native\",{\"1\":{\"81\":2}}],[\"nanosecond\",{\"1\":{\"49\":1}}],[\"nanoseconds\",{\"1\":{\"49\":1,\"50\":2}}],[\"nano>\",{\"1\":{\"49\":1}}],[\"namespace\",{\"1\":{\"15\":1,\"21\":1,\"49\":1,\"50\":1}}],[\"new\",{\"1\":{\"32\":1,\"33\":3,\"36\":14,\"38\":1,\"41\":3,\"54\":4,\"65\":2,\"67\":2}}],[\"next\",{\"1\":{\"10\":2,\"44\":1}}],[\"nullptr\",{\"1\":{\"29\":1,\"31\":1,\"32\":1,\"36\":1,\"54\":4,\"80\":2}}],[\"numbers\",{\"1\":{\"27\":6}}],[\"num\",{\"1\":{\"10\":6,\"44\":6,\"45\":6}}],[\"notify\",{\"1\":{\"40\":3,\"41\":1}}],[\"not\",{\"1\":{\"31\":1,\"66\":1,\"88\":1}}],[\"nodiscard\",{\"1\":{\"21\":1,\"27\":1,\"32\":1,\"80\":2,\"83\":2}}],[\"now2\",{\"1\":{\"48\":1}}],[\"now\",{\"1\":{\"15\":11,\"48\":12,\"50\":5}}],[\"noexcept\",{\"1\":{\"14\":1,\"18\":9,\"21\":1,\"27\":2,\"31\":2,\"32\":1,\"43\":1,\"65\":1,\"66\":3,\"75\":1,\"80\":4,\"83\":5,\"84\":2}}],[\"n\",{\"1\":{\"10\":3,\"12\":15,\"13\":2,\"14\":33,\"15\":2,\"16\":5,\"18\":3,\"25\":3,\"26\":2,\"27\":5,\"30\":1,\"33\":3,\"36\":2,\"37\":2,\"43\":26,\"44\":3,\"45\":5,\"48\":2,\"49\":3,\"50\":2,\"58\":7,\"60\":2,\"66\":1,\"67\":2,\"75\":1}}],[\"nd\",{\"1\":{\"0\":1}}],[\"nc\",{\"1\":{\"0\":1}}],[\"cnd\",{\"1\":{\"80\":1}}],[\"cnt++\",{\"1\":{\"25\":1}}],[\"cnt\",{\"1\":{\"25\":1}}],[\"cstd\",{\"1\":{\"80\":2}}],[\"cst\",{\"1\":{\"65\":3,\"66\":2}}],[\"csapp\",{\"1\":{\"10\":1}}],[\"centralwidget\",{\"1\":{\"54\":1}}],[\"center\",{\"1\":{\"54\":2}}],[\"cerr\",{\"1\":{\"45\":2}}],[\"cpp\",{\"1\":{\"53\":2,\"80\":2}}],[\"cpu\",{\"1\":{\"5\":2,\"10\":3,\"15\":4,\"41\":1,\"71\":9}}],[\"cmake\",{\"1\":{\"53\":1,\"62\":1,\"74\":1}}],[\"cxx20\",{\"1\":{\"49\":1}}],[\"cv\",{\"1\":{\"40\":8,\"50\":3,\"80\":1}}],[\"cvref\",{\"1\":{\"21\":1,\"80\":1}}],[\"create\",{\"1\":{\"37\":1}}],[\"cref\",{\"1\":{\"14\":3,\"27\":2}}],[\"ctor\",{\"1\":{\"21\":1,\"32\":1,\"80\":1}}],[\"current\",{\"1\":{\"15\":1,\"45\":3,\"48\":2}}],[\"clear\",{\"1\":{\"66\":4,\"67\":1}}],[\"clicked\",{\"1\":{\"54\":2}}],[\"clock>\",{\"1\":{\"50\":1}}],[\"clock\",{\"1\":{\"15\":5,\"47\":1,\"48\":9,\"50\":8}}],[\"class\",{\"1\":{\"12\":1,\"13\":1,\"18\":1,\"21\":1,\"27\":2,\"29\":2,\"33\":6,\"34\":1,\"41\":1,\"48\":2,\"50\":3,\"54\":1,\"66\":1,\"80\":2,\"81\":1,\"83\":4,\"84\":4}}],[\"clang18\",{\"1\":{\"72\":1,\"74\":1}}],[\"clang19\",{\"1\":{\"21\":1}}],[\"clang\",{\"1\":{\"0\":1,\"21\":1,\"37\":2,\"74\":2}}],[\"check\",{\"1\":{\"31\":1}}],[\"chrono\",{\"1\":{\"15\":10,\"21\":1,\"28\":1,\"40\":3,\"43\":1,\"45\":1,\"46\":2,\"47\":1,\"48\":11,\"49\":12,\"50\":18,\"58\":1}}],[\"char>\",{\"1\":{\"65\":2,\"84\":1}}],[\"char8\",{\"1\":{\"65\":1}}],[\"char32\",{\"1\":{\"65\":1}}],[\"char16\",{\"1\":{\"65\":1}}],[\"char\",{\"1\":{\"14\":5,\"65\":2,\"75\":1}}],[\"chunk\",{\"1\":{\"10\":5,\"44\":2,\"54\":1}}],[\"c\",{\"1\":{\"14\":1,\"54\":2,\"64\":2,\"84\":1}}],[\"cast<\",{\"1\":{\"80\":1}}],[\"cast<void\",{\"1\":{\"80\":2}}],[\"cast<std\",{\"1\":{\"49\":1,\"50\":1}}],[\"cast<>\",{\"1\":{\"49\":1}}],[\"calculate\",{\"1\":{\"45\":2}}],[\"calloc\",{\"1\":{\"36\":1}}],[\"call\",{\"1\":{\"33\":9,\"38\":1}}],[\"callable\",{\"1\":{\"9\":1,\"12\":1,\"14\":1,\"18\":2,\"33\":1,\"43\":2,\"44\":2,\"80\":1,\"84\":5}}],[\"can\",{\"1\":{\"31\":1}}],[\"cancel\",{\"1\":{\"21\":4}}],[\"catch`\",{\"1\":{\"12\":1}}],[\"catch\",{\"1\":{\"12\":5,\"33\":2,\"45\":4}}],[\"copied\",{\"1\":{\"80\":7}}],[\"copyable<trivial\",{\"1\":{\"65\":1}}],[\"copyassignable\",{\"1\":{\"65\":1}}],[\"copyconstructible\",{\"1\":{\"65\":1}}],[\"copy\",{\"1\":{\"14\":1,\"65\":2}}],[\"complier\",{\"1\":{\"74\":1}}],[\"compare\",{\"1\":{\"65\":4,\"67\":12}}],[\"co\",{\"1\":{\"72\":3}}],[\"color\",{\"1\":{\"54\":3}}],[\"counting\",{\"1\":{\"58\":7}}],[\"counter++\",{\"1\":{\"37\":2}}],[\"counters\",{\"1\":{\"37\":3}}],[\"counter\",{\"1\":{\"37\":5}}],[\"count\",{\"1\":{\"35\":10,\"36\":2,\"49\":3,\"50\":1,\"60\":3}}],[\"cout\",{\"1\":{\"9\":2,\"10\":1,\"12\":2,\"14\":6,\"15\":5,\"16\":5,\"18\":3,\"21\":2,\"25\":4,\"26\":3,\"27\":3,\"28\":3,\"33\":1,\"35\":2,\"36\":1,\"37\":2,\"40\":1,\"41\":2,\"43\":11,\"44\":3,\"45\":4,\"46\":8,\"48\":2,\"49\":3,\"50\":2,\"58\":7,\"60\":2,\"65\":8,\"66\":1,\"67\":2,\"84\":1}}],[\"code\",{\"1\":{\"14\":3,\"27\":2,\"31\":2,\"53\":1}}],[\"connect\",{\"1\":{\"47\":1,\"54\":2}}],[\"consume\",{\"1\":{\"65\":2}}],[\"consumer\",{\"1\":{\"41\":7}}],[\"constructible<trivial\",{\"1\":{\"65\":2}}],[\"construct\",{\"1\":{\"27\":2,\"31\":1,\"83\":4,\"84\":2}}],[\"constexpr\",{\"1\":{\"21\":1,\"65\":3,\"80\":3,\"84\":3}}],[\"const\",{\"1\":{\"12\":3,\"13\":2,\"14\":15,\"18\":4,\"27\":4,\"30\":1,\"31\":1,\"34\":4,\"41\":1,\"43\":5,\"50\":1,\"62\":1,\"65\":5,\"75\":1,\"80\":2,\"83\":6,\"84\":1}}],[\"cond\",{\"1\":{\"41\":4}}],[\"condition\",{\"1\":{\"40\":11,\"41\":1,\"47\":1,\"50\":1}}],[\"concurrency\",{\"1\":{\"10\":5,\"44\":1}}],[\"cc\",{\"1\":{\"0\":1}}],[\"c++23\",{\"1\":{\"72\":1}}],[\"c++20\",{\"0\":{\"19\":1,\"58\":1,\"59\":1},\"1\":{\"10\":1,\"20\":1,\"58\":2,\"65\":1,\"66\":2,\"72\":1}}],[\"c++标准库提供了很多工具\",{\"1\":{\"38\":1}}],[\"c++17\",{\"1\":{\"10\":1,\"16\":1,\"27\":2,\"30\":1,\"34\":1,\"36\":1,\"65\":3,\"78\":1,\"82\":1}}],[\"c++14\",{\"1\":{\"10\":1,\"15\":1,\"34\":1,\"49\":1,\"78\":3}}],[\"c++11中\",{\"1\":{\"37\":1}}],[\"c++11\",{\"1\":{\"0\":1,\"10\":1,\"12\":1,\"19\":1,\"27\":1,\"31\":1,\"33\":2,\"36\":2,\"37\":1,\"56\":1,\"64\":1,\"65\":1,\"73\":1,\"78\":3}}],[\"c++\",{\"1\":{\"0\":3,\"3\":2,\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"12\":1,\"13\":1,\"20\":1,\"21\":1,\"23\":2,\"25\":1,\"30\":1,\"33\":1,\"34\":1,\"35\":1,\"36\":1,\"37\":2,\"40\":2,\"42\":3,\"47\":1,\"48\":5,\"50\":1,\"58\":2,\"60\":1,\"62\":3,\"72\":1,\"73\":2,\"74\":1,\"80\":1,\"81\":1}}],[\"站课程\",{\"1\":{\"0\":1}}],[\"broadcast\",{\"1\":{\"80\":1}}],[\"binary\",{\"1\":{\"58\":6,\"62\":1}}],[\"bind\",{\"1\":{\"14\":4,\"44\":1}}],[\"bind与成员指针一起使用\",{\"1\":{\"14\":1}}],[\"bold\",{\"1\":{\"54\":1}}],[\"border\",{\"1\":{\"54\":2}}],[\"boolalpha\",{\"1\":{\"43\":2}}],[\"bool\",{\"1\":{\"18\":1,\"28\":1,\"31\":3,\"40\":3,\"41\":1,\"50\":2,\"65\":1,\"66\":2,\"67\":9}}],[\"basically\",{\"1\":{\"66\":1}}],[\"basiclockable\",{\"1\":{\"40\":1}}],[\"barrier\",{\"1\":{\"59\":2}}],[\"barclass\",{\"1\":{\"54\":1}}],[\"bar\",{\"1\":{\"53\":2,\"54\":15}}],[\"background\",{\"1\":{\"54\":2}}],[\"back\",{\"1\":{\"10\":1,\"18\":2,\"25\":3,\"26\":2,\"27\":2,\"44\":2,\"58\":1}}],[\"be\",{\"1\":{\"31\":1,\"66\":1}}],[\"beginthreadex\",{\"1\":{\"14\":1,\"80\":5}}],[\"begin\",{\"1\":{\"10\":1,\"25\":1,\"27\":2}}],[\"b执行完了前面求\",{\"1\":{\"27\":1}}],[\"b执行函数\",{\"1\":{\"27\":1}}],[\"busy\",{\"1\":{\"40\":1}}],[\"button2\",{\"1\":{\"54\":8}}],[\"button\",{\"1\":{\"52\":4,\"54\":15}}],[\"but\",{\"1\":{\"27\":1,\"31\":1,\"83\":2,\"84\":1}}],[\"buffer\",{\"1\":{\"14\":12,\"75\":1}}],[\"by\",{\"1\":{\"0\":1,\"35\":2}}],[\"b\",{\"1\":{\"0\":1,\"27\":3,\"29\":1,\"30\":10,\"44\":8,\"64\":2,\"65\":2,\"67\":10}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
