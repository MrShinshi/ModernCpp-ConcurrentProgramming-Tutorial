import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as c,c as l,a as n,b as s,d as e,e as t}from"./app-BGUIea1J.js";const r={},i=n("h1",{id:"std-thread-的构造-源码解析",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#std-thread-的构造-源码解析"},[n("span",null,[n("code",null,"std::thread"),s(" 的构造-源码解析")])])],-1),d=n("p",null,[s("我们这单章是为了专门解释一下 C++11 引入的 "),n("code",null,"std::thread"),s(" 是如何构造的，是如何创建线程传递参数的，让你彻底了解这个类。")],-1),u=n("strong",null,"MSVC",-1),_={href:"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread",target:"_blank",rel:"noopener noreferrer"},k=n("code",null,"std::thread",-1),h=n("strong",null,"C++14",-1),m=n("strong",null,"C++17",-1),v={href:"https://zh.cppreference.com/w/cpp/utility/functional/invoke",target:"_blank",rel:"noopener noreferrer"},b=n("code",null,"invoke",-1),g=n("strong",null,"C++14",-1),f=n("h2",{id:"std-thread-的数据成员",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#std-thread-的数据成员"},[n("span",null,[n("code",null,"std::thread"),s(" 的数据成员")])])],-1),T=n("ul",null,[n("li",null,[n("strong",null,"了解一个庞大的类，最简单的方式就是先看它的数据成员有什么"),s("。")])],-1),y=n("code",null,"std::thread",-1),w={href:"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L163",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"_Thr",-1),A=t(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">private</span><span class="token operator">:</span>
    _Thrd_t _Thr<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,1),E={href:"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/__msvc_threads_core.hpp#L20-L24",target:"_blank",rel:"noopener noreferrer"},S=n("code",null,"_Thrd_t",-1),C=t(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">using</span> _Thrd_id_t <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">_Thrd_t</span> <span class="token punctuation">{</span> <span class="token comment">// thread identifier for Win32</span>
    <span class="token keyword">void</span><span class="token operator">*</span> _Hnd<span class="token punctuation">;</span> <span class="token comment">// Win32 HANDLE</span>
    _Thrd_id_t _Id<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构很明确，这个结构体的 <code>_Hnd</code> 成员是指向线程的句柄，<code>_Id</code> 成员就是保有线程的 ID。</p><p>在64 位操作系统，因为内存对齐，指针 8 ，无符号 int 4，这个结构体 <code>_Thrd_t</code> 就是占据 16 个字节。也就是说 <code>sizeof(std::thread)</code> 的结果应该为 <strong>16</strong>。</p><h2 id="std-thread-的构造函数" tabindex="-1"><a class="header-anchor" href="#std-thread-的构造函数"><span><code>std::thread</code> 的构造函数</span></a></h2>`,4),I=n("code",null,"std::thread",-1),D={href:"https://zh.cppreference.com/w/cpp/thread/thread/thread",target:"_blank",rel:"noopener noreferrer"},L=t(`<p>默认构造函数，构造不关联线程的新 std::thread 对象。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> _Thr<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),B={href:"https://zh.cppreference.com/w/cpp/language/value_initialization#:~:text=%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%EF%BC%89%EF%BC%8C-,%E9%82%A3%E4%B9%88%E9%9B%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1,-%EF%BC%8C%E7%84%B6%E5%90%8E%E5%A6%82%E6%9E%9C%E5%AE%83",target:"_blank",rel:"noopener noreferrer"},z=n("code",null,"_Hnd",-1),F=n("code",null,"_Id",-1),q={href:"https://zh.cppreference.com/w/cpp/language/zero_initialization",target:"_blank",rel:"noopener noreferrer"},R=t(`<p>移动构造函数，转移线程的所有权，构造 other 关联的执行线程的 <code>std::thread</code> 对象。此调用后 other 不再表示执行线程失去了线程的所有权。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token function">thread</span><span class="token punctuation">(</span>thread<span class="token operator">&amp;&amp;</span> _Other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">_Thr</span><span class="token punctuation">(</span>_STD <span class="token function">exchange</span><span class="token punctuation">(</span>_Other<span class="token punctuation">.</span>_Thr<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),N={href:"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/yvals_core.h#L1934",target:"_blank",rel:"noopener noreferrer"},H=n("code",null,"::std::",-1),V={href:"https://zh.cppreference.com/w/cpp/utility/exchange",target:"_blank",rel:"noopener noreferrer"},G=n("code",null,"::std::exchange",-1),O=n("code",null,"_Other._Thr",-1),M=n("code",null,"{}",-1),X=n("code",null,"_Other._Thr",-1),U=n("code",null,"_Thr",-1),P=t(`<li><p>复制构造函数被定义为弃置的，std::thread 不可复制。两个 std::thread 不可表示一个线程，std::thread 对线程资源是独占所有权。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token function">thread</span><span class="token punctuation">(</span><span class="token keyword">const</span> thread<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>构造新的 <code>std::thread</code> 对象并将它与执行线程关联。<strong>表示新的执行线程开始执行</strong>。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Fn</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Args<span class="token punctuation">,</span> enable_if_t<span class="token operator">&lt;</span><span class="token operator">!</span>is_same_v<span class="token operator">&lt;</span>_Remove_cvref_t<span class="token operator">&lt;</span>_Fn<span class="token operator">&gt;</span><span class="token punctuation">,</span> thread<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">&gt;</span>
    _NODISCARD_CTOR_THREAD <span class="token keyword">explicit</span> <span class="token function">thread</span><span class="token punctuation">(</span>_Fn<span class="token operator">&amp;&amp;</span> _Fx<span class="token punctuation">,</span> _Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Ax<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">_Start</span><span class="token punctuation">(</span>_STD <span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Fn<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Fx<span class="token punctuation">)</span><span class="token punctuation">,</span> _STD <span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Args<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Ax<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>`,2),J=n("hr",null,null,-1),W=n("p",null,[s("前三个构造函数都没啥要特别聊的，非常简单，只有第四个构造函数较为复杂，且是我们本章重点，需要详细讲解。（"),n("em",null,[s("注意 MSVC 使用标准库的内容很多时候不加 "),n("strong",null,"std::"),s("，脑补一下就行")]),s("）")],-1),Y={href:"https://zh.cppreference.com/w/cpp/language/sfinae",target:"_blank",rel:"noopener noreferrer"},j={href:"https://zh.cppreference.com/w/cpp/named_req/Callable",target:"_blank",rel:"noopener noreferrer"},K=n("code",null,"std::thread",-1),Q={href:"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L72-L87",target:"_blank",rel:"noopener noreferrer"},Z=n("strong",null,[n("code",null,"_Start")],-1),$=t(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Fn</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">_Start</span><span class="token punctuation">(</span>_Fn<span class="token operator">&amp;&amp;</span> _Fx<span class="token punctuation">,</span> _Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Ax<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> _Tuple                 <span class="token operator">=</span> tuple<span class="token operator">&lt;</span>decay_t<span class="token operator">&lt;</span>_Fn<span class="token operator">&gt;</span><span class="token punctuation">,</span> decay_t<span class="token operator">&lt;</span>_Args<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> _Decay_copied           <span class="token operator">=</span> _STD <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Tuple<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_STD <span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Fn<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Fx<span class="token punctuation">)</span><span class="token punctuation">,</span> _STD <span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Args<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Ax<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> _Invoker_proc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">_Get_invoke</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Tuple<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>make_index_sequence<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>_Args<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    _Thr<span class="token punctuation">.</span>_Hnd <span class="token operator">=</span>
        <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_CSTD <span class="token function">_beginthreadex</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _Invoker_proc<span class="token punctuation">,</span> _Decay_copied<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>_Thr<span class="token punctuation">.</span>_Id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>_Thr<span class="token punctuation">.</span>_Hnd<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// ownership transferred to the thread</span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> _Decay_copied<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// failed to start thread</span>
        _Thr<span class="token punctuation">.</span>_Id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">_Throw_Cpp_error</span><span class="token punctuation">(</span>_RESOURCE_UNAVAILABLE_TRY_AGAIN<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),nn=n("li",null,[n("p",null,[s("它也是一个可变参数成员函数模板，接受一个可调用对象 "),n("code",null,"_Fn"),s(" 和一系列参数 "),n("code",null,"_Args..."),s(" ，这些东西用来创建一个线程。")])],-1),sn=n("p",null,[n("code",null,"using _Tuple = tuple<decay_t<_Fn>, decay_t<_Args>...>")],-1),an={href:"https://zh.cppreference.com/w/cpp/utility/tuple",target:"_blank",rel:"noopener noreferrer"},en=n("code",null,"_Tuple",-1),tn={href:"https://zh.cppreference.com/w/cpp/types/decay",target:"_blank",rel:"noopener noreferrer"},on=n("code",null,"decay_t",-1),pn=n("p",null,[n("code",null,"auto _Decay_copied = _STD make_unique<_Tuple>(_STD forward<_Fn>(_Fx), _STD forward<_Args>(_Ax)...)")],-1),cn={href:"https://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique",target:"_blank",rel:"noopener noreferrer"},ln=n("code",null,"make_unique",-1),rn=n("code",null,"_Tuple",-1),dn=n("strong",null,"存储了传入的函数对象和参数的副本",-1),un=n("p",null,[n("code",null,"constexpr auto _Invoker_proc = _Get_invoke<_Tuple>(make_index_sequence<1 + sizeof...(_Args)>{})")],-1),_n={href:"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L65-L68",target:"_blank",rel:"noopener noreferrer"},kn=n("code",null,"_Get_invoke",-1),hn=n("code",null,"_Tuple",-1),mn={href:"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread#L55-L63",target:"_blank",rel:"noopener noreferrer"},vn=n("code",null,"_Invoke",-1),bn=t(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tuple</span><span class="token punctuation">,</span> size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Indices<span class="token operator">&gt;</span>
 _NODISCARD <span class="token keyword">static</span> <span class="token keyword">constexpr</span> <span class="token keyword">auto</span> <span class="token function">_Get_invoke</span><span class="token punctuation">(</span>index_sequence<span class="token operator">&lt;</span>_Indices<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token operator">&amp;</span>_Invoke<span class="token operator">&lt;</span>_Tuple<span class="token punctuation">,</span> _Indices<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Tuple</span><span class="token punctuation">,</span> size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Indices<span class="token operator">&gt;</span>
 <span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __stdcall <span class="token function">_Invoke</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> _RawVals<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">/* terminates */</span> <span class="token punctuation">{</span>
     <span class="token comment">// adapt invoke of user&#39;s callable object to _beginthreadex&#39;s thread procedure</span>
     <span class="token keyword">const</span> unique_ptr<span class="token operator">&lt;</span>_Tuple<span class="token operator">&gt;</span> <span class="token function">_FnVals</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Tuple<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_RawVals<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     _Tuple<span class="token operator">&amp;</span> _Tup <span class="token operator">=</span> <span class="token operator">*</span>_FnVals<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// avoid ADL, handle incomplete types</span>
     _STD <span class="token function">invoke</span><span class="token punctuation">(</span>_STD <span class="token function">move</span><span class="token punctuation">(</span>_STD <span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>_Indices<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>_Tup<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">_Cnd_do_broadcast_at_thread_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TRANSITION, ABI</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>_Get_invoke 函数很简单，就是接受一个元组类型，和形参包的索引，传递给 _Invoke 静态成员函数模板，实例化，获取它的函数指针。</p>`,2),gn={href:"https://en.cppreference.com/w/cpp/utility/integer_sequence",target:"_blank",rel:"noopener noreferrer"},fn=n("code",null,"index_sequence",-1),Tn=n("code",null,"make_index_sequence",-1),yn={href:"https://godbolt.org/z/dv88aPGac",target:"_blank",rel:"noopener noreferrer"},wn=n("p",null,[n("strong",null,"_Invoke 是重中之重，它是线程实际执行的函数"),s("，如你所见它的形参类型是 "),n("code",null,"void*"),s(" ，这是必须的，要符合 "),n("code",null,"_beginthreadex"),s(" 执行函数的类型要求。虽然是 "),n("code",null,"void*"),s("，但是我可以将它转换为 "),n("code",null,"_Tuple*"),s(" 类型，构造一个独占智能指针，然后调用 get() 成员函数获取底层指针，解引用指针，得到元组的引用初始化"),n("code",null,"_Tup"),s(" 。")],-1),xn={href:"https://zh.cppreference.com/w/cpp/utility/functional/invoke",target:"_blank",rel:"noopener noreferrer"},An=n("code",null,"std::invoke",-1),En=n("code",null,"std::move",-1),Sn=n("code",null,"_STD get<_Indices>(_Tup))...",-1),Cn=n("code",null,"std::get<>",-1),In=n("code",null,"_Indices",-1),Dn=n("p",null,[n("code",null,"_Thr._Hnd = reinterpret_cast<void*>(_CSTD _beginthreadex(nullptr, 0, _Invoker_proc, _Decay_copied.get(), 0, &_Thr._Id))")],-1),Ln={href:"https://learn.microsoft.com/zh-cn/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=msvc-170",target:"_blank",rel:"noopener noreferrer"},Bn=n("code",null,"_beginthreadex",-1),zn=n("code",null,"_Thr._Hnd",-1),Fn=n("code",null,"_Invoker_proc",-1),qn=n("strong",null,"_Invoke",-1),Rn=n("code",null,"_Decay_copied.get()",-1),Nn=t("<li><p><code>if (_Thr._Hnd) {</code></p><ul><li>如果线程句柄 <code>_Thr._Hnd</code> 不为空，则表示线程已成功启动，将独占指针的所有权转移给线程。</li></ul></li><li><p><code>(void) _Decay_copied.release()</code></p><ul><li>释放独占指针的所有权，因为已经将参数传递给了线程。</li></ul></li><li><p><code>} else { // failed to start thread</code></p><ul><li>如果线程启动失败，则进入这个分支</li></ul></li><li><p><code>_Thr._Id = 0;</code></p><ul><li>将线程ID设置为0。</li></ul></li><li><p><code>_Throw_Cpp_error(_RESOURCE_UNAVAILABLE_TRY_AGAIN);</code></p><ul><li>抛出一个 C++ 错误，表示资源不可用，请再次尝试。</li></ul></li>",5),Hn=n("h2",{id:"总结",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#总结"},[n("span",null,"总结")])],-1),Vn=n("code",null,"sizeof(std::thread)",-1),Gn=n("strong",null,"8",-1),On={href:"https://github.com/gcc-mirror/gcc/blob/3e3d115c946944c81d8231dfbe778d4dae26cbb7/libstdc%2B%2B-v3/include/bits/std_thread.h#L123",target:"_blank",rel:"noopener noreferrer"},Mn=n("code",null,"std::thread::id",-1),Xn={href:"https://github.com/gcc-mirror/gcc/blob/3e3d115c946944c81d8231dfbe778d4dae26cbb7/libstdc%2B%2B-v3/include/bits/std_thread.h#L81-L85",target:"_blank",rel:"noopener noreferrer"},Un=n("code",null,"win32",-1),Pn=n("code",null,"POSIX",-1),Jn=n("code",null,"_GLIBCXX_HAS_GTHREADS",-1),Wn={href:"https://docs.gtk.org/glib/struct.Thread.html",target:"_blank",rel:"noopener noreferrer"},Yn=t(`<blockquote><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code> <span class="token keyword">class</span> <span class="token class-name">thread</span>
  <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_GLIBCXX_HAS_GTHREADS</span></span>
    <span class="token keyword">using</span> native_handle_type <span class="token operator">=</span> __gthread_t<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token keyword">using</span> native_handle_type <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>__gthread_t</code> 即 <code>void*</code>。</p></blockquote><p>我们这里的源码解析涉及到的 C++ 技术很多，我们也没办法每一个都单独讲，那会显得文章很冗长，而且也不是重点。</p>`,2),jn=n("strong",null,"不会模板，你阅读标准库源码，是无稽之谈",-1),Kn={href:"https://github.com/Mq-b/Modern-Cpp-templates-tutorial",target:"_blank",rel:"noopener noreferrer"},Qn=n("strong",null,"现代C++模板教程",-1);function Zn($n,ns){const a=p("ExternalLinkIcon");return c(),l("div",null,[i,d,n("p",null,[s("我们以 "),u,s(" 实现的 "),n("a",_,[k,e(a)]),s(" 代码进行讲解，MSVC STL 很早之前就不支持 C++11 了，它的实现完全基于 "),h,s("，出于某些原因 "),m,s(" 的一些库（如 "),n("a",v,[b,e(a)]),s("， _v 变量模板）被向后移植到了 "),g,s(" 模式，所以即使是 C++11 标准库设施，实现中可能也是使用到了 C++14、17 的东西。")]),f,T,n("p",null,[y,s(" 只保有一个私有数据成员 "),n("a",w,[x,e(a)]),s("：")]),A,n("p",null,[n("a",E,[S,e(a)]),s(" 是一个结构体，它保有两个数据成员：")]),C,n("p",null,[I,s(" 有四个"),n("a",D,[s("构造函数"),e(a)]),s("，分别是：")]),n("ol",null,[n("li",null,[L,n("p",null,[n("a",B,[s("值初始化"),e(a)]),s("了数据成员 _Thr ，这里的效果相当于给其成员 "),z,s(" 和 "),F,s(" 都进行"),n("a",q,[s("零初始化"),e(a)]),s("。")])]),n("li",null,[R,n("p",null,[n("a",N,[s("_STD"),e(a)]),s(" 是一个宏，展开就是 "),H,s("，也就是 "),n("a",V,[G,e(a)]),s("，将 "),O,s(" 赋为 "),M,s(" （也就是置空），返回 "),X,s(" 的旧值用以初始化当前对象的数据成员 "),U,s("。")])]),P]),J,W,n("p",null,[s("如你所见，这个构造函数本身并没有做什么，它只是一个可变参数成员函数模板，增加了一些 "),n("a",Y,[s("SFINAE"),e(a)]),s(" 进行约束我们传入的"),n("a",j,[s("可调用"),e(a)]),s("对象的类型不能是 "),K,s("。函数体中调用了一个函数 "),n("a",Q,[Z,e(a)]),s("，将我们构造函数的参数全部完美转发，去调用它，这个函数才是我们的重点，如下：")]),$,n("ol",null,[nn,n("li",null,[sn,n("ul",null,[n("li",null,[s("定义了一个"),n("a",an,[s("元组"),e(a)]),s("类型 "),en,s(" ，它包含了可调用对象和参数的类型，这里使用了 "),n("a",tn,[on,e(a)]),s(" 来去除了类型的引用和 cv 限定。")])])]),n("li",null,[pn,n("ul",null,[n("li",null,[s("使用 "),n("a",cn,[ln,e(a)]),s(" 创建了一个独占指针，指向的是 "),rn,s(" 类型的对象，"),dn,s("。")])])]),n("li",null,[un,n("ul",null,[n("li",null,[s("调用 "),n("a",_n,[kn,e(a)]),s(" 函数，传入 "),hn,s(" 类型和一个参数序列的索引序列（为了遍历形参包）。这个函数用于获取一个函数指针，指向了一个静态成员函数 "),n("a",mn,[vn,e(a)]),s("，用来实际执行线程。这两个函数都非常的简单，我们来看看：")])]),bn,n("blockquote",null,[n("p",null,[s("它的形参类型我们不再过多介绍，你只需要知道 "),n("a",gn,[fn,e(a)]),s(" 这个东西可以用来接收一个由 "),Tn,s(" 创建的索引形参包，帮助我们进行遍历元组即可。"),n("a",yn,[s("示例代码"),e(a)]),s("。")])]),wn,n("p",null,[s("此时，我们就可以进行调用了，使用 "),n("a",xn,[An,e(a)]),s(" + "),En,s("（默认移动） ，这里有一个形参包展开，"),Sn,s("，_Tup 就是 std::tuple 的引用，我们使用 "),Cn,s(" 获取元组存储的数据，需要传入一个索引，这里就用到了 "),In,s("。展开之后，就等于 invoke 就接受了我们构造 std::thread 传入的可调用对象，调用可调用对象的参数，invoke 就可以执行了。")])]),n("li",null,[Dn,n("ul",null,[n("li",null,[s("调用 "),n("a",Ln,[Bn,e(a)]),s(" 函数来启动一个线程，并将线程句柄存储到 "),zn,s(" 中。传递给线程的参数为 "),Fn,s("（一个静态函数指针，就是我们前面讲的 "),qn,s("）和 "),Rn,s("（存储了函数对象和参数的副本的指针）。")])])]),Nn]),Hn,n("p",null,[s("需要注意，libstdc++ 和 libc++ 可能不同，就比如它们 64 位环境下 "),Vn,s(" 的结果就可能是 "),Gn,s("。libstdc++ 的实现只"),n("a",On,[s("保有一个 "),Mn,e(a)]),s("。"),n("a",Xn,[s("参见"),e(a)]),s("。不过实测 gcc 不管是 "),Un,s(" 还是 "),Pn,s(" 线程模型，线程对象的大小都是 8，宏 "),Jn,s(" 的值都为 1（"),n("a",Wn,[s("GThread"),e(a)]),s("）。")]),Yn,n("p",null,[s("相信你也感受到了，"),jn,s("，市面上很多教程教学，教导一些实现容器，过度简化了，真要去出错了去看标准库的代码，那是不现实的。不需要模板的水平有多高，也不需要会什么元编程，但是基本的需求得能做到，得会，这里推荐一下："),n("a",Kn,[Qn,e(a)]),s("。")])])}const es=o(r,[["render",Zn],["__file","01thread的构造与源码解析.html.vue"]]),ts=JSON.parse('{"path":"/md/%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/01thread%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html","title":"std::thread 的构造-源码解析","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"std::thread 的数据成员","slug":"std-thread-的数据成员","link":"#std-thread-的数据成员","children":[]},{"level":2,"title":"std::thread 的构造函数","slug":"std-thread-的构造函数","link":"#std-thread-的构造函数","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1710214174000,"updatedTime":1714801671000,"contributors":[{"name":"归故里","email":"3326284481@qq.com","commits":8},{"name":"A. Jiang","email":"de34@live.cn","commits":2}]},"readingTime":{"minutes":7.05,"words":2114},"filePathRelative":"md/详细分析/01thread的构造与源码解析.md","localizedDate":"2024年3月12日","excerpt":"\\n<p>我们这单章是为了专门解释一下 C++11 引入的 <code>std::thread</code> 是如何构造的，是如何创建线程传递参数的，让你彻底了解这个类。</p>\\n<p>我们以 <strong>MSVC</strong> 实现的 <a href=\\"https://github.com/microsoft/STL/blob/8e2d724cc1072b4052b14d8c5f81a830b8f1d8cb/stl/inc/thread\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>std::thread</code></a> 代码进行讲解，MSVC STL 很早之前就不支持 C++11 了，它的实现完全基于 <strong>C++14</strong>，出于某些原因 <strong>C++17</strong> 的一些库（如 <a href=\\"https://zh.cppreference.com/w/cpp/utility/functional/invoke\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\"><code>invoke</code></a>， _v 变量模板）被向后移植到了 <strong>C++14</strong> 模式，所以即使是 C++11 标准库设施，实现中可能也是使用到了 C++14、17 的东西。</p>"}');export{es as comp,ts as data};
