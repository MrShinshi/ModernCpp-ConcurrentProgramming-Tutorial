import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as l,c as u,a as n,d as a,b as s,w as i,e as o}from"./app-BGUIea1J.js";const d={},r=o(`<h1 id="共享数据" tabindex="-1"><a class="header-anchor" href="#共享数据"><span>共享数据</span></a></h1><p>本章节主要内容：</p><ul><li><p>多线程共享数据的问题</p></li><li><p>使用互斥量保护共享数据</p></li><li><p>保护共享数据的其它方案</p></li></ul><p>在上一章内容，我们对于线程的基本使用和管理，可以说已经比较了解了，甚至深入阅读了部分的 <code>std::thread</code> 源码。所以如果你好好学习了上一章，本章也完全不用担心。</p><p>我们本章，就要开始聊共享数据的那些事。</p><h2 id="条件竞争" tabindex="-1"><a class="header-anchor" href="#条件竞争"><span>条件竞争</span></a></h2><p>在多线程的情况下，每个线程都抢着完成自己的任务。在大多数情况下，即使会改变执行顺序，也是良性竞争，这是无所谓的。比如两个线程都要往标准输出输出一段字符，谁先谁后并不会有什么太大影响。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;❤️\\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;😢\\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">{</span> f <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread t2<span class="token punctuation">{</span> f2 <span class="token punctuation">}</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),k={href:"https://zh.cppreference.com/w/cpp/io/cout",target:"_blank",rel:"noopener noreferrer"},v=n("code",null,"std::cout",-1),m=n("em",null,"同步的 C++ 流保证是线程安全的（从多个线程输出的单独字符可能交错，但无数据竞争）",-1),_=o(`<p>只有在涉及多线程读写相同共享数据的时候，才会导致“<em>恶性的条件竞争</em>”。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>v<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> v<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> v<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">{</span> f <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread t2<span class="token punctuation">{</span> f2 <span class="token punctuation">}</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如这段代码就是典型的恶性条件竞争，两个线程共享一个 <code>vector</code>，并对它进行修改。可能导致许多问题，比如 <code>f2</code> 先执行，此时 <code>vector</code> 还没有元素，导致抛出异常。又或者 <code>f</code> 执行了一半，调用了 <code>f2()</code>，等等。</p><p>当然了，也有可能先执行 f，然后执行 f2，最后打印了 0，程序老老实实执行完毕。</p><p>但是我们显然不能寄希望于这种操作系统的调度。</p>`,5),b=n("code",null,"emplace_back",-1),h={href:"https://zh.cppreference.com/w/cpp/language/memory_model#.E7.BA.BF.E7.A8.8B.E4.B8.8E.E6.95.B0.E6.8D.AE.E7.AB.9E.E4.BA.89",target:"_blank",rel:"noopener noreferrer"},g=n("em",null,"未定义的行为",-1),f=n("code",null,"emplace_back",-1),w=n("em",null,"未定义",-1),x=n("blockquote",null,[n("p",null,[s("当某个表达式的求值写入某个内存位置，而另一求值读或修改同一内存位置时，称这些"),n("strong",null,"表达式冲突"),s("。"),n("strong",null,"拥有两个冲突的求值的程序就有数据竞争"),s("，除非")]),n("ul",null,[n("li",null,"两个求值都在同一线程上，或者在同一信号处理函数中执行，或"),n("li",null,"两个冲突的求值都是原子操作（见 std::atomic），或"),n("li",null,"一个冲突的求值发生早于 另一个（见 std::memory_order）")]),n("p",null,[n("strong",null,"如果出现数据竞争，那么程序的行为未定义。")])],-1),y=n("em",null,"数据竞争",-1),E={href:"https://zh.cppreference.com/w/cpp/language/memory_model#.E7.BA.BF.E7.A8.8B.E4.B8.8E.E6.95.B0.E6.8D.AE.E7.AB.9E.E4.BA.89",target:"_blank",rel:"noopener noreferrer"},q=n("em",null,"未定义行为",-1),z=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">{</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread t1<span class="token punctuation">{</span>f<span class="token punctuation">}</span><span class="token punctuation">,</span> t2<span class="token punctuation">{</span>f<span class="token punctuation">}</span><span class="token punctuation">,</span> t3<span class="token punctuation">{</span>f<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 未定义行为</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用互斥量" tabindex="-1"><a class="header-anchor" href="#使用互斥量"><span>使用互斥量</span></a></h2><p>互斥量（Mutex），又称为互斥锁（或者直接被称作“锁”），是一种用来保护<strong>临界区</strong><sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>的特殊对象，其相当于实现了一个公共的“<strong>标志位</strong>”。它可以处于锁定（locked）状态，也可以处于解锁（unlocked）状态：</p><ol><li><p>如果互斥量是锁定的，通常说某个特定的线程正持有这个锁。</p></li><li><p>如果没有线程持有这个互斥量，那么这个互斥量就处于解锁状态。</p></li></ol><hr><p>概念从来不是我们的重点，用一段对比代码为你直观的展示互斥量的作用：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> threads<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        threads<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> thread <span class="token operator">:</span> threads<span class="token punctuation">)</span>
        thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),B={href:"https://godbolt.org/z/93vTzcPzK",target:"_blank",rel:"noopener noreferrer"},A={href:"https://zh.cppreference.com/w/cpp/thread/mutex",target:"_blank",rel:"noopener noreferrer"},C=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span> <span class="token comment">// 必要标头</span></span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span>
    m<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span>threads<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        threads<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> thread <span class="token operator">:</span> threads<span class="token punctuation">)</span>
        thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当多个线程执行函数 <code>f</code> 的时候，只有一个线程能成功调用 <code>lock()</code> 给互斥量上锁，其他所有的线程 <code>lock()</code> 的调用将阻塞执行，直至获得锁。第一个调用 <code>lock()</code> 的线程得以继续往下执行，执行我们的 <code>std::cout</code> 输出语句，不会有任何其他的线程打断这个操作。直到线程执行 <code>unlock()</code>，就解锁了互斥量。</p><p>那么其他线程此时也就能再有一个成功调用 <code>lock</code>...</p><blockquote><p>至于到底哪个线程才会成功调用，这个是由操作系统调度决定的。</p></blockquote><p>看一遍描述就可以了，简而言之，被 <code>lock()</code> 和 <code>unlock()</code> 包含在其中的代码是线程安全的，同一时间只有一个线程执行，不会被其它线程的执行所打断。</p><h3 id="std-lock-guard" tabindex="-1"><a class="header-anchor" href="#std-lock-guard"><span><code>std::lock_guard</code></span></a></h3>`,6),M=n("code",null,"lock()",-1),D=n("code",null,"unlock()",-1),T={href:"https://zh.cppreference.com/w/cpp/thread/lock_guard",target:"_blank",rel:"noopener noreferrer"},O=n("code",null,"std::lock_guard",-1),j=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span>lc<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),S=n("code",null,"std::lock_guard",-1),L={href:"https://github.com/microsoft/STL/blob/8dc4faadafb52e3e0a627e046b41258032d9bc6a/stl/inc/mutex#L448-L469",target:"_blank",rel:"noopener noreferrer"},X=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>_EXPORT_STD <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Mutex</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">_NODISCARD_LOCK</span> lock_guard <span class="token punctuation">{</span> <span class="token comment">// class with destructor that unlocks a mutex</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> mutex_type <span class="token operator">=</span> _Mutex<span class="token punctuation">;</span>

    <span class="token keyword">explicit</span> <span class="token function">lock_guard</span><span class="token punctuation">(</span>_Mutex<span class="token operator">&amp;</span> _Mtx<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">_MyMutex</span><span class="token punctuation">(</span>_Mtx<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// construct and lock</span>
        _MyMutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">lock_guard</span><span class="token punctuation">(</span>_Mutex<span class="token operator">&amp;</span> _Mtx<span class="token punctuation">,</span> adopt_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token comment">// strengthened</span>
        <span class="token operator">:</span> <span class="token function">_MyMutex</span><span class="token punctuation">(</span>_Mtx<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// construct but don&#39;t lock</span>

    <span class="token operator">~</span><span class="token function">lock_guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
        _MyMutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">lock_guard</span><span class="token punctuation">(</span><span class="token keyword">const</span> lock_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span>            <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    lock_guard<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> lock_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    _Mutex<span class="token operator">&amp;</span> _MyMutex<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),F={href:"https://zh.cppreference.com/w/cpp/language/function#.E5.BC.83.E7.BD.AE.E5.87.BD.E6.95.B0",target:"_blank",rel:"noopener noreferrer"},P={href:"https://zh.cppreference.com/w/cpp/language/rule_of_three#.E4.BA.94.E4.B9.8B.E6.B3.95.E5.88.99",target:"_blank",rel:"noopener noreferrer"},V=n("p",null,"它只保有一个私有数据成员，一个引用，用来引用互斥量。",-1),I=n("p",null,[s("构造函数中初始化这个引用，同时上锁，析构函数中解锁，这是一个非常典型的 "),n("code",null,"RAII"),s(" 式的管理。")],-1),G={href:"https://zh.cppreference.com/w/cpp/thread/lock_tag_t",target:"_blank",rel:"noopener noreferrer"},R=n("code",null,"std::adopt_lock_t",-1),K=o(`<p>所以有的时候你可能会看到一些这样的代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//code..</span>
    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 涉及共享资源的修改的代码...</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//code..</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>{}</code> 创建了一个块作用域，限制了对象 <code>lc</code> 的生存期，进入作用域构造 <code>lock_guard</code> 的时候上锁（lock），离开作用域析构的时候解锁（unlock）。</p><ul><li>我们要尽可能的让互斥量上锁的<strong>粒度</strong>小，只用来确保必须的共享资源的线程安全。</li></ul><blockquote><p><strong>“粒度”通常用于描述锁定的范围大小，较小的粒度意味着锁定的范围更小，因此有更好的性能和更少的竞争。</strong></p></blockquote><p>我们举一个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">add_to_list</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">numbers</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">iota</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> numbers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> numbers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">print_list</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> i <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">&#39; &#39;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> list<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread t1<span class="token punctuation">{</span> add_to_list<span class="token punctuation">,</span>i<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread t2<span class="token punctuation">{</span> add_to_list<span class="token punctuation">,</span>i<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread t3<span class="token punctuation">{</span> print_list<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">cref</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread t4<span class="token punctuation">{</span> print_list<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span><span class="token function">cref</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),N={href:"https://godbolt.org/z/E3396dMxG",target:"_blank",rel:"noopener noreferrer"},W=o("<p>先看 <code>add_to_list</code>，只有 <code>list.push_back(sum)</code> 涉及到了对共享数据的修改，需要进行保护，我们用 <code>{}</code> 包起来了。</p><p>假设有线程 A、B执行函数 <code>add_to_list()</code> ：线程 A 中的 numbers、sum 与线程 B 中的，不是同一个，希望大家分清楚，自然不存在数据竞争，也不需要上锁。线程 A、B执行完了前面求 <code>0-n</code> 的计算，只有一个线程能在 <code>lock_guard</code> 的构造函数中成功调用 lock() 给互斥量上锁。假设线程 A 成功调用 lock()，那么线程 B 的 lock() 调用就阻塞了，必须等待线程 A 执行完里面的代码，然后作用域结束，调用 <code>lock_guard</code> 的析构函数，解锁 unlock()，此时线程 B 就可以进去执行了，避免了数据竞争，不存在一个对象同时被多个线程修改。</p><p>函数 <code>print_list()</code> 就更简单了，打印 <code>list</code>，给整个函数上锁，同一时刻只能有一个线程执行。</p><p>我们的使用代码是多个线程执行这两个函数，两个函数共享了一个锁，这样确保了当执行函数 <code>print_list()</code> 打印的时候，list 的状态是确定的。打印函数 <code>print_list</code> 和 <code>add_to_list</code> 函数的修改操作同一时间只能有一个线程在执行。<code>print_list()</code> 不可能看到正在被<code>add_to_list()</code> 修改的 list。</p><p>至于到底哪个函数哪个线程会先执行，执行多少次，这些都由操作系统调度决定，也完全有可能<strong>连续 4 次</strong>都是执行函数 <code>print_list</code> 的线程成功调用 <code>lock</code>，会打印出了一样的值，这都很正常。</p><hr>",6),Y={href:"https://zh.cppreference.com/w/cpp/language/class_template_argument_deduction",target:"_blank",rel:"noopener noreferrer"},J=n("code",null,"std::lock_guard",-1),Q=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>lock_guard lc<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// std::lock_guard&lt;std::mutex&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,1),Z={href:"https://zh.cppreference.com/w/cpp/thread/scoped_lock",target:"_blank",rel:"noopener noreferrer"},H=n("code",null,"std::scoped_lock",-1),U=n("code",null,"lock_guard",-1),$=n("strong",null,"它可以管理多个互斥量",-1),nn=n("code",null,"lock_guard",-1),sn=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>scoped_lock lc<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// std::scoped_lock&lt;std::mutex&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在后续管理多个互斥量，会详细了解这个类。</p><h3 id="try-lock" tabindex="-1"><a class="header-anchor" href="#try-lock"><span><code>try_lock</code></span></a></h3><p><code>try_lock</code> 是互斥量中的一种尝试上锁的方式。与常规的 <code>lock</code> 不同，<code>try_lock</code> 会尝试上锁，但如果锁已经被其他线程占用，则<strong>不会阻塞当前线程，而是立即返回</strong>。</p><p>它的返回类型是 <code>bool</code> ，如果上锁成功就返回 <code>true</code>，失败就返回 <code>false</code>。</p><p>这种方法在多线程编程中很有用，特别是在需要保护临界区的同时，又不想线程因为等待锁而阻塞的情况下。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread_function</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 尝试加锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mtx<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;线程：&quot;</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; 获得锁&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
        <span class="token comment">// 临界区代码</span>
        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模拟临界区操作</span>
        mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;线程：&quot;</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; 释放锁&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;线程：&quot;</span> <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; 获取锁失败 处理步骤&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有两个线程运行这段代码，必然有一个线程无法成功上锁，要走 else 的分支。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>thread_function<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>thread_function<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),an={href:"https://godbolt.org/z/hqW8eahWx",target:"_blank",rel:"noopener noreferrer"},tn=n("strong",null,"运行结果",-1),on=o(`<div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><pre class="language-txt"><code>线程：1 获得锁
线程：2 获取锁失败 处理步骤
线程：1 释放锁
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="保护共享数据" tabindex="-1"><a class="header-anchor" href="#保护共享数据"><span>保护共享数据</span></a></h2><p>互斥量主要也就是为了保护共享数据，上一节的<em>使用互斥量</em>也已经为各位展示了一些。</p><p>然而使用互斥量来保护共享数据也并不是在函数中加上一个 <code>std::lock_guard</code> 就万事大吉了。有的时候只需要一个指针或者引用，就能让这种保护<strong>形同虚设</strong>。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Data</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string b<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 修改数据成员等...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Data_wrapper</span><span class="token punctuation">{</span>
    Data data<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>
    <span class="token keyword">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span>Func func<span class="token punctuation">)</span><span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc<span class="token punctuation">{</span>m<span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token function">func</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 受保护数据传递给函数</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Data<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">malicious_function</span><span class="token punctuation">(</span>Data<span class="token operator">&amp;</span> protected_data<span class="token punctuation">)</span><span class="token punctuation">{</span>
    p <span class="token operator">=</span> <span class="token operator">&amp;</span>protected_data<span class="token punctuation">;</span> <span class="token comment">// 受保护的数据被传递</span>
<span class="token punctuation">}</span>

Data_wrapper d<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    d<span class="token punctuation">.</span><span class="token function">process_data</span><span class="token punctuation">(</span>malicious_function<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传递了一个恶意的函数</span>
    p<span class="token operator">-&gt;</span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 在无保护的情况下访问保护数据</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>成员函数模板 <code>process_data</code> 看起来一点问题也没有，使用 <code>std::lock_guard</code> 对数据做了保护，但是调用方传递了 <code>malicious_function</code> 这样一个恶意的函数，使受保护数据传递给外部，可以在没有被互斥量保护的情况下调用 <code>do_something()</code>。</p><p>我们传递的函数就不该是涉及外部副作用的，就应该是单纯的在受互斥量保护的情况下老老实实调用 <code>do_something()</code> 操作受保护的数据。</p><ul><li><em>简而言之：<strong>切勿将受保护数据的指针或引用传递到互斥量作用域之外</strong>，不然保护将<strong>形同虚设</strong>。</em></li></ul><blockquote><p><code>process_data</code> 的确算是没问题，用户非要做这些事情也是防不住的，我们只是告诉各位可能的情况。</p></blockquote><h2 id="死锁-问题与解决" tabindex="-1"><a class="header-anchor" href="#死锁-问题与解决"><span>死锁：问题与解决</span></a></h2><p>试想一下，有一个玩具，这个玩具有两个部分，必须同时拿到两部分才能玩。比如一个遥控汽车，需要遥控器和玩具车才能玩。有两个小孩，他们都想玩这个玩具。当其中一个小孩拿到了遥控器和玩具车时，就可以尽情玩耍。当另一个小孩也想玩，他就得等待另一个小孩玩完才行。再试想，遥控器和玩具车被放在两个不同的地方，并且两个小孩都想要玩，并且一个拿到了遥控器，另一个拿到了玩具车。问题就出现了，除非其中一个孩子决定让另一个先玩，他把自己的那个部分给另一个小孩。但如果他们都不愿意，那么这个遥控汽车就谁都没有办法玩。</p><p>我们当然不在乎小孩抢玩具，我们要聊的是线程对锁的竞争：<em>两个线程需要对它们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个线程的互斥量解锁。因为它们都在等待对方释放互斥量，没有线程工作。</em> 这种情况就是死锁。</p><ul><li><strong>多个互斥量才可能遇到死锁问题</strong>。</li></ul><p>避免死锁的一般建议是让两个互斥量以相同的顺序上锁，总在互斥量 B 之前锁住互斥量 A，就通常不会死锁。反面示例</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>mutex m1<span class="token punctuation">,</span>m2<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc1<span class="token punctuation">{</span> m1 <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc2<span class="token punctuation">{</span> m2 <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc1<span class="token punctuation">{</span> m2 <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lc2<span class="token punctuation">{</span> m1 <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>f</code> 与 <code>f2</code> 因为互斥量<strong>上锁顺序不同</strong>，就有死锁风险。函数 <code>f</code> 先锁定 <code>m1</code>，然后再尝试锁定 <code>m2</code>，而函数 <code>f2</code> 先锁定 <code>m2</code> 再锁定 <code>m1</code> 。如果两个线程同时运行，它们就可能会彼此等待对方释放其所需的锁，从而造成死锁。</p>`,16),en={href:"https://godbolt.org/z/T8vWYzqnT",target:"_blank",rel:"noopener noreferrer"},pn=o(`<hr><p>但是有的时候即使固定锁顺序，依旧会产生问题。当有多个互斥量保护同一个类的对象时，对于相同类型的两个不同对象进行数据的交换操作，为了保证数据交换的正确性，就要避免其它线程修改，确保每个对象的互斥量都锁住自己要保护的区域。如果按照前面的的选择一个固定的顺序上锁解锁，则毫无意义，比如：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token punctuation">{</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token operator">:</span>object<span class="token punctuation">{</span> str <span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string object<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lock1<span class="token punctuation">{</span> lhs<span class="token punctuation">.</span>m <span class="token punctuation">}</span><span class="token punctuation">;</span> 
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lock2<span class="token punctuation">{</span> rhs<span class="token punctuation">.</span>m <span class="token punctuation">}</span><span class="token punctuation">;</span> 
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>object<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>考虑用户调用的时候将参数交换，就会产生死锁</strong>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>X a<span class="token punctuation">{</span> <span class="token string">&quot;🤣&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> b<span class="token punctuation">{</span> <span class="token string">&quot;😅&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>
std<span class="token double-colon punctuation">::</span>thread t2<span class="token punctuation">{</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token function">swap</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>1</code> 执行的时候，先上锁 a 的互斥量，再上锁 b 的互斥量。</p><p><code>2</code> 执行的时候，先上锁 b 的互斥量，再上锁 a 的互斥量。</p>`,7),cn=n("code",null,"2",-1),ln=n("strong",null,"死锁",-1),un={href:"https://godbolt.org/z/M6hfeb778",target:"_blank",rel:"noopener noreferrer"},dn=n("p",null,"其实也就是回到了第一个示例的问题。",-1),rn={href:"https://zh.cppreference.com/w/cpp/thread/lock",target:"_blank",rel:"noopener noreferrer"},kn=n("code",null,"std::lock",-1),vn=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">lock</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 给两个互斥量上锁</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lock1<span class="token punctuation">{</span> lhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>adopt_lock <span class="token punctuation">}</span><span class="token punctuation">;</span> 
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lock2<span class="token punctuation">{</span> rhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>adopt_lock <span class="token punctuation">}</span><span class="token punctuation">;</span> 
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>object<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为前面已经使用了 <code>std::lock</code> 上锁，所以后的 <code>std::lock_guard</code> 构造都额外传递了一个 <code>std::adopt_lock</code> 参数，让其选择到不上锁的构造函数。函数退出也能正常解锁。</p><p><code>std::lock</code> 给 <code>lhs.m</code> 或 <code>rhs.m</code> 上锁时若抛出异常，则在重抛前对任何已锁的对象调用 <code>unlock()</code> 解锁，也就是 <code>std::lock</code> 要么将互斥量都上锁，要么一个都不锁。</p>`,3),mn={href:"https://zh.cppreference.com/w/cpp/thread/scoped_lock",target:"_blank",rel:"noopener noreferrer"},_n=n("code",null,"std::scoped_lock",-1),bn={href:"https://zh.cppreference.com/w/cpp/language/raii",target:"_blank",rel:"noopener noreferrer"},hn=n("code",null,"std::lock",-1),gn=o(`<p>所以我们前面的代码可以改写为：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>scoped_lock guard<span class="token punctuation">{</span> lhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span>rhs<span class="token punctuation">.</span>m <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>object<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),fn=n("strong",null,[n("code",null,"std::scoped_lock"),s(" 的源码实现与解析")],-1),wn=o('<p>使用 <code>std::scoped_lock</code> 可以将所有 <code>std::lock</code> 替换掉，减少错误发生。</p><p>然而它们的帮助都是有限的，一切最终都是依靠开发者使用与管理。</p><p>死锁是多线程编程中令人相当头疼的问题，并且死锁经常是不可预见，甚至难以复现，因为在大部分时间里，程序都能正常完成工作。我们可以<strong>通过一些简单的规则，约束开发者的行为，帮助写出“无死锁”的代码</strong>。</p><ul><li><p><strong>避免嵌套锁</strong></p><p>线程获取一个锁时，就别再获取第二个锁。每个线程只持有一个锁，自然不会产生死锁。如果必须要获取多个锁，使用 <code>std::lock</code> 。</p></li><li><p><strong>避免在持有锁时调用外部代码</strong></p><p>这个建议是很简单的：因为代码是外部提供的，所以没办法确定外部要做什么。外部程序可能做任何事情，包括获取锁。在持有锁的情况下，如果用外部代码要获取一个锁，就会违反第一个指导意见，并造成死锁（有时这是无法避免的）。当写通用代码时（比如<a href="#%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">保护共享数据</a>中的 <code>Date</code> 类）。这不是接口设计者可以处理的，只能寄希望于调用方传递的代码是能正常执行的。</p></li><li><p><strong>使用固定顺序获取锁</strong></p><p>如同第一个示例那样，固定的顺序上锁就不存在问题。</p></li></ul><h2 id="std-unique-lock-灵活的锁" tabindex="-1"><a class="header-anchor" href="#std-unique-lock-灵活的锁"><span><code>std::unique_lock</code> 灵活的锁</span></a></h2>',5),xn={href:"https://zh.cppreference.com/w/cpp/thread/unique_lock",target:"_blank",rel:"noopener noreferrer"},yn=n("code",null,"std::unique_lock",-1),En=n("code",null,"std::lock_guard",-1),qn={href:"https://zh.cppreference.com/w/cpp/thread#.E6.9D.A1.E4.BB.B6.E5.8F.98.E9.87.8F",target:"_blank",rel:"noopener noreferrer"},zn=n("code",null,"std::lock_guard",-1),Bn=n("code",null,"swap",-1),An=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>X<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> X<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lhs <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lock1<span class="token punctuation">{</span> lhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>defer_lock <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lock2<span class="token punctuation">{</span> rhs<span class="token punctuation">.</span>m<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>defer_lock <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">lock</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>object<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),Cn=n("code",null,"std::defer_lock",-1),Mn={href:"https://github.com/microsoft/STL/blob/8dc4faadafb52e3e0a627e046b41258032d9bc6a/stl/inc/mutex#L135-L269",target:"_blank",rel:"noopener noreferrer"},Dn=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">private</span><span class="token operator">:</span>
    _Mutex<span class="token operator">*</span> _Pmtx <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> _Owns    <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见很简单，一个互斥量的指针，还有一个就是表示对象是否拥有互斥量所有权的 bool 类型的对象 <code>_Owns</code> 了。我们前面代码会调用构造函数：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token function">unique_lock</span><span class="token punctuation">(</span>_Mutex<span class="token operator">&amp;</span> _Mtx<span class="token punctuation">,</span> defer_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
    <span class="token operator">:</span> <span class="token function">_Pmtx</span><span class="token punctuation">(</span>_STD <span class="token function">addressof</span><span class="token punctuation">(</span>_Mtx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_Owns</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// construct but don&#39;t lock</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,3),Tn=n("strong",null,[s("这个构造函数没有给互斥量上锁，且 "),n("code",null,"_Owns"),s(" 为 "),n("code",null,"false"),s(" 表示没有互斥量所有权")],-1),On=n("code",null,"std::unique_lock",-1),jn={href:"https://zh.cppreference.com/w/cpp/thread/unique_lock/lock",target:"_blank",rel:"noopener noreferrer"},Sn=n("code",null,"lock()",-1),Ln={href:"https://zh.cppreference.com/w/cpp/thread/unique_lock/try_lock",target:"_blank",rel:"noopener noreferrer"},Xn=n("code",null,"try_lock()",-1),Fn={href:"https://zh.cppreference.com/w/cpp/thread/unique_lock/unlock",target:"_blank",rel:"noopener noreferrer"},Pn=n("code",null,"unlock()",-1),Vn=n("code",null,"std::lock",-1),In=n("code",null,"lock()",-1),Gn=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// lock the mutex</span>
    <span class="token function">_Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _Pmtx<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _Owns <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，正常上锁，并且把 <code>_Owns</code> 设置为 <code>true</code>，即表示当前对象拥有互斥量的所有权。那么接下来看析构函数：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token operator">~</span><span class="token function">unique_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_Owns<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        _Pmtx<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>必须得是<strong>当前对象拥有互斥量的所有权析构函数才会调用 unlock() 解锁互斥量</strong>。我们的代码因为调用了 <code>lock</code> ，所以 <code>_Owns</code> 设置为 <code>true</code> ，函数结束的时候会解锁互斥量。</p><hr><p>设计挺奇怪的对吧，这个所有权语义。其实上面的代码还不够简单直接，我们再举个例子：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span>lock<span class="token punctuation">{</span> m<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>adopt_lock <span class="token punctuation">}</span><span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),Rn={href:"https://godbolt.org/z/KqKrETe6d",target:"_blank",rel:"noopener noreferrer"},Kn=n("code",null,"std::adopt_lock",-1),Nn=n("strong",null,"有所有权",-1),Wn=n("code",null,"_Owns",-1),Yn=n("code",null,"true",-1),Jn=n("code",null,"lock()",-1),Qn=n("code",null,"_Validate()",-1),Zn=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">_Validate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">// check if the mutex can be locked</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_Pmtx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">_Throw_system_error</span><span class="token punctuation">(</span>errc<span class="token double-colon punctuation">::</span>operation_not_permitted<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>_Owns<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">_Throw_system_error</span><span class="token punctuation">(</span>errc<span class="token double-colon punctuation">::</span>resource_deadlock_would_occur<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),Hn=n("code",null,"_Owns",-1),Un=n("code",null,"true",-1),$n={href:"https://github.com/gcc-mirror/gcc/blob/3e3d115c946944c81d8231dfbe778d4dae26cbb7/libstdc%2B%2B-v3/include/bits/unique_lock.h#L141-L144",target:"_blank",rel:"noopener noreferrer"},ns=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>lock<span class="token punctuation">.</span><span class="token function">mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也就是说 <code>std::unique_lock</code> 要想调用 <code>lock()</code> 成员函数，必须是当前<strong>没有所有权</strong>。</p><p>所以正常的用法其实是，先上锁了互斥量，然后传递 <code>std::adopt_lock</code> 构造 <code>std::unique_lock</code> 对象表示拥有互斥量的所有权，即可在析构的时候正常解锁。如下：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span>lock <span class="token punctuation">{</span> m<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>adopt_lock <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>简而言之：</p><ul><li>使用 <code>std::defer_lock</code> 构造函数不上锁，要求构造之后上锁</li><li>使用 <code>std::adopt_lock</code> 构造函数不上锁，要求在构造之前互斥量上锁</li><li>默认构造会上锁，要求构造函数之前和构造函数之后都不能再次上锁</li></ul><hr><p>我们前面提到了 <code>std::unique_lock</code> 更加灵活，那么灵活在哪？很简单，它拥有 <code>lock()</code> 和 <code>unlock()</code> 成员函数，所以我们能写出如下代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//code..</span>
    
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lock<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 涉及共享资源的修改的代码...</span>

    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁并释放所有权，析构函数不会再 unlock()</span>

    <span class="token comment">//code..</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而不是像之前 <code>std::lock_guard</code> 一样使用 <code>{}</code>。</p><p>另外再聊一聊开销吧，其实倒也还好，多了一个 <code>bool</code> ，内存对齐，x64 环境也就是 <code>16</code> 字节。这都不是最重要的，主要是复杂性和需求，通常建议优先 <code>std::lock_guard</code>，当它无法满足你的需求或者显得代码非常繁琐，那么可以考虑使用 <code>std::unique_lock</code>。</p><h2 id="在不同作用域传递互斥量" tabindex="-1"><a class="header-anchor" href="#在不同作用域传递互斥量"><span>在不同作用域传递互斥量</span></a></h2>`,13),ss={href:"https://zh.cppreference.com/w/cpp/named_req/Mutex",target:"_blank",rel:"noopener noreferrer"},as=n("em",null,"互斥体 (Mutex)",-1),ts=n("strong",null,"不可复制不可移动",-1),os=n("code",null,"std::unique_lock",-1),es=n("code",null,"std::unique_lock",-1),ps=n("code",null,"std::unique_lock",-1),cs=n("em",null,"就是调用移动构造",-1),ls={href:"https://zh.cppreference.com/w/cpp/language/return#.E8.87.AA.E5.8A.A8.E4.BB.8E.E5.B1.80.E9.83.A8.E5.8F.98.E9.87.8F.E5.92.8C.E5.BD.A2.E5.8F.82.E7.A7.BB.E5.8A.A8",target:"_blank",rel:"noopener noreferrer"},us=n("code",null,"std::unique_lock",-1),is={href:"https://zh.cppreference.com/w/cpp/utility/move",target:"_blank",rel:"noopener noreferrer"},ds=n("code",null,"std::move",-1),rs=o(`<blockquote><p>请勿对移动语义和转移所有权抱有错误的幻想，我们说的无非是调用 <code>std::unique_lock</code> 的移动构造罢了：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>_NODISCARD_CTOR_LOCK <span class="token function">unique_lock</span><span class="token punctuation">(</span>unique_lock<span class="token operator">&amp;&amp;</span> _Other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">_Pmtx</span><span class="token punctuation">(</span>_Other<span class="token punctuation">.</span>_Pmtx<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_Owns</span><span class="token punctuation">(</span>_Other<span class="token punctuation">.</span>_Owns<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _Other<span class="token punctuation">.</span>_Pmtx <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    _Other<span class="token punctuation">.</span>_Owns <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将数据成员赋给新对象，原来的置空，这就是所谓的 <em>“<strong>所有权</strong>”转移</em>，切勿被词语迷惑。</p></blockquote><p><code>std::unique_lock</code> 是只能移动不可复制的类，它移动即标志其管理的互斥量的所有权转移了。</p><p>一种可能的使用是允许函数去锁住一个互斥量，并将互斥量的所有权转移到调用者上，所以调用者可以在这个锁保护的范围内执行代码。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token function">get_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">extern</span> std<span class="token double-colon punctuation">::</span>mutex some_mutex<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lk<span class="token punctuation">{</span> some_mutex <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> lk<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">process_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lk<span class="token punctuation">{</span> <span class="token function">get_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">// 执行一些任务...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>return lk</code> 这里会调用移动构造，将互斥量的所有权转移给调用方， <code>process_data</code> 函数结束的时候会解锁互斥量。</p>`,5),ks=n("code",null,"extern std::mutex some_mutex",-1),vs=n("em",null,"所谓的在不同作用域传递互斥量，其实只是传递了它们的指针或者引用罢了",-1),ms={href:"https://zh.cppreference.com/w/cpp/language/lifetime",target:"_blank",rel:"noopener noreferrer"},_s={href:"https://zh.cppreference.com/w/cpp/language/storage_duration",target:"_blank",rel:"noopener noreferrer"},bs=n("p",null,[s("如果你简单写一个 "),n("code",null,"std::mutex some_mutex"),s(" 那么函数 "),n("code",null,"process_data"),s(" 中的 "),n("code",null,"lk"),s(" 会持有一个悬垂指针。")],-1),hs=n("code",null,"extern std::mutex",-1),gs={href:"https://godbolt.org/z/z47x1Es5z",target:"_blank",rel:"noopener noreferrer"},fs=n("code",null,"new std::mutex",-1),ws=o('<p><code>std::unique_lock</code> 是灵活的，同样允许在对象销毁之前就解锁互斥量，调用 <code>unlock()</code> 成员函数即可，不再强调。</p><h2 id="保护共享数据的初始化过程" tabindex="-1"><a class="header-anchor" href="#保护共享数据的初始化过程"><span>保护共享数据的初始化过程</span></a></h2><p>保护共享数据并非必须使用互斥量，互斥量只是其中一种常见的方式而已，对于一些特殊的场景，也有专门的保护方式，比如<strong>对于共享数据的初始化过程的保护</strong>。我们通常就不会用互斥量，<strong>这会造成很多的额外开销</strong>。</p><p>我们不想为各位介绍其它乱七八糟的各种保护初始化的方式，我们只介绍三种：<strong>双检锁（错误）</strong>、<strong>使用 <code>std::call_once</code></strong>、<strong>静态局部变量初始化在 C++11 是线程安全</strong>。</p>',4),xs=o(`<li><p><strong>双检锁（错误）线程不安全</strong></p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment">// 1</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lk<span class="token punctuation">{</span> m <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ptr<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 2</span>
            ptr<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> some<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 3</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    ptr<span class="token operator">-&gt;</span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 4</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>① 是查看指针是否为空，空才需要初始化，才需要获取锁。指针为空，当获取锁后会再检查一次指针②（这就是双重检查），避免另一线程在第一次检查后再做初始化，并且让当前线程获取锁。</p><p>然而这显然没用，因为<strong>有潜在的条件竞争</strong>。未被锁保护的读取操作①没有与其他线程里被锁保护的写入操作③进行同步，因此就会产生条件竞争。</p><p>简而言之：一个线程知道另一个线程已经在执行③，但是此时还没有创建 some 对象，而只是分配内存对指针写入。那么这个线程在①的时候就不会进入，直接执行了 <code>ptr-&gt;do_something()</code>④，得不到正确的结果，因为对象还没构造。</p><blockquote><p>如果你觉得难以理解，那就记住 <code>ptr.reset(new some);</code> 并非是不可打断不可交换的固定指令。</p><p>这种错误写法在一些单例中也非常的常见。如果你的同事或上司写出此代码，一般不建议指出，因为不见得你能教会他们，不要“没事找事”，只要不影响自己即可。</p></blockquote></li>`,1),ys={href:"https://zh.cppreference.com/w/cpp/thread/call_once",target:"_blank",rel:"noopener noreferrer"},Es=n("code",null,"std::call_once",-1),qs={href:"https://zh.cppreference.com/w/cpp/thread/once_flag",target:"_blank",rel:"noopener noreferrer"},zs=n("code",null,"std::once_flag",-1),Bs=n("code",null,"std::call_once",-1),As=n("strong",null,[s("使用 "),n("code",null,"std::call_once"),s(" 比显式使用互斥量消耗的资源更少，特别是当初始化完成之后")],-1),Cs=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>some<span class="token operator">&gt;</span>ptr<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>once_flag resource_flag<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">init_resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    ptr<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> some<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>resource_flag<span class="token punctuation">,</span> init_resource<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 线程安全的一次初始化</span>
    ptr<span class="token operator">-&gt;</span><span class="token function">do_something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),Ms=n("code",null,"std::once_flag",-1),Ds=n("code",null,"std::call_once",-1),Ts=n("strong",null,"一次",-1),Os=n("code",null,"std::call_once",-1),js={href:"https://zh.cppreference.com/w/cpp/named_req/Callable",target:"_blank",rel:"noopener noreferrer"},Ss=n("em",null,"可调用 (Callable)",-1),Ls=o(`<p>“<strong>初始化</strong>”，自然是<strong>一次</strong>。但是 <code>std::call_once</code> 也有一些例外情况（比如异常）会让传入的可调用对象被多次调用，即“<strong>多次</strong>”初始化：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>once_flag flag<span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
        <span class="token operator">++</span>n<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;第&quot;</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;次调用\\n&quot;</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> std<span class="token double-colon punctuation">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">&quot;异常&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),Xs={href:"https://godbolt.org/z/aWqfEchd6",target:"_blank",rel:"noopener noreferrer"},Fs=o(`<li><p><strong>静态局部变量初始化在 C++11 是线程安全</strong></p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">my_class</span><span class="token punctuation">;</span>
my_class<span class="token operator">&amp;</span> <span class="token function">get_my_class_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span> my_class instance<span class="token punctuation">;</span>  <span class="token comment">// 线程安全的初始化过程 初始化严格发生一次</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>多线程可以安全的调用 <code>get_my_class_instance</code> 函数，不用为数据竞争而担心。此方式也在单例中多见，是简单合理的做法。</p></li>`,1),Ps=n("hr",null,null,-1),Vs=n("p",null,[s("其实还有不少其他的做法或者反例，但是觉得没必要再聊了，因为本文不是详尽的文档，而是“"),n("strong",null,"教程"),s("”。")],-1),Is=n("h2",{id:"保护不常更新的数据结构",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#保护不常更新的数据结构"},[n("span",null,"保护不常更新的数据结构")])],-1),Gs=n("p",null,"试想一下，你有一个数据结构存储了用户的设置信息，每次用户打开程序的时候，都要进行读取，且运行时很多地方都依赖这个数据结构需要读取，所以为了效率，我们使用了多线程读写。这个数据结构很少进行改变，而我们知道，多线程读取，是没有数据竞争的，是安全的，但是有些时候又不可避免的有修改和读取都要工作的时候，所以依然必须得使用互斥量进行保护。",-1),Rs=n("code",null,"std::mutex",-1),Ks={href:"https://zh.wikipedia.org/wiki/%E8%AF%BB%E5%86%99%E9%94%81",target:"_blank",rel:"noopener noreferrer"},Ns=n("em",null,[n("strong",null,"读写锁")],-1),Ws={href:"https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex",target:"_blank",rel:"noopener noreferrer"},Ys=n("code",null,"std::shared_timed_mutex",-1),Js={href:"https://zh.cppreference.com/w/cpp/thread/shared_mutex",target:"_blank",rel:"noopener noreferrer"},Qs=n("code",null,"std::shared_mutex",-1),Zs=n("code",null,"std::shared_mutex",-1),Hs=n("code",null,"std::lock_guard",-1),Us=n("code",null,"std::unique_lock",-1),$s=n("code",null,"std::mutex",-1),na=n("em",null,"写线程",-1),sa=n("em",null,"读线程",-1),aa={href:"https://zh.cppreference.com/w/cpp/thread/shared_lock",target:"_blank",rel:"noopener noreferrer"},ta=n("code",null,"std::shared_lock<std::shared_mutex>",-1),oa=o(`<div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Settings</span> <span class="token punctuation">{</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> data_<span class="token punctuation">;</span>
    <span class="token keyword">mutable</span> std<span class="token double-colon punctuation">::</span>shared_mutex mutex_<span class="token punctuation">;</span> <span class="token comment">// “M&amp;M 规则”：mutable 与 mutex 一起出现</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_mutex<span class="token operator">&gt;</span> lock<span class="token punctuation">{</span> mutex_ <span class="token punctuation">}</span><span class="token punctuation">;</span>
        data_<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    std<span class="token double-colon punctuation">::</span>string <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> key<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>shared_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> it <span class="token operator">=</span> data_<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> data_<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> it<span class="token operator">-&gt;</span>second <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 如果没有找到键返回空字符串</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),ea={href:"https://github.com/Mq-b/ModernCpp-ConcurrentProgramming-Tutorial/blob/main/code/03%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/%E4%BF%9D%E6%8A%A4%E4%B8%8D%E5%B8%B8%E6%9B%B4%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.cpp",target:"_blank",rel:"noopener noreferrer"},pa={href:"https://godbolt.org/z/ezh1Pdo5E",target:"_blank",rel:"noopener noreferrer"},ca=n("p",null,[n("code",null,"std::shared_timed_mutex"),s(" 具有 "),n("code",null,"std::shared_mutex"),s(" 的所有功能，并且额外支持超时功能。所以以上代码可以随意更换这两个互斥量。")],-1),la=n("h2",{id:"std-recursive-mutex",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#std-recursive-mutex"},[n("span",null,[n("code",null,"std::recursive_mutex")])])],-1),ua=n("code",null,"std::mutex",-1),ia={href:"https://zh.cppreference.com/w/cpp/language/ub",target:"_blank",rel:"noopener noreferrer"},da=n("em",null,"未定义行为",-1),ra=n("code",null,"std::recursive_mutex",-1),ka=o(`<p><code>std::recursive_mutex</code> 是 C++ 标准库提供的一种互斥量类型，它允许同一线程多次锁定同一个互斥量，而不会造成死锁。当同一线程多次对同一个 <code>std::recursive_mutex</code> 进行锁定时，<strong>只有在解锁与锁定次数相匹配时，互斥量才会真正释放</strong>。但它并不影响不同线程对同一个互斥量进行锁定的情况。不同线程对同一个互斥量进行锁定时，会按照互斥量的规则<strong>进行阻塞</strong>，</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>

std<span class="token double-colon punctuation">::</span>recursive_mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">recursive_function</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归函数，每次递归都会锁定互斥量</span>
    mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Locked by thread: &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, count: &quot;</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">recursive_function</span><span class="token punctuation">(</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归调用</span>
    <span class="token punctuation">}</span>
    mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解锁互斥量</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>recursive_function<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>recursive_function<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),va={href:"https://godbolt.org/z/aefrYbGd7",target:"_blank",rel:"noopener noreferrer"},ma={href:"https://zh.cppreference.com/w/cpp/thread/recursive_mutex/lock",target:"_blank",rel:"noopener noreferrer"},_a=n("strong",null,[n("code",null,"lock")],-1),ba=n("code",null,"lock",-1),ha=n("code",null,"unlock",-1),ga=n("strong",null,"释放",-1),fa={href:"https://zh.cppreference.com/w/cpp/thread/recursive_mutex/unlock",target:"_blank",rel:"noopener noreferrer"},wa=n("strong",null,[n("code",null,"unlock")],-1),xa={href:"https://zh.cppreference.com/w/cpp/thread/recursive_mutex/lock",target:"_blank",rel:"noopener noreferrer"},ya=n("code",null,"unlock()",-1),Ea=n("strong",null,"解锁互斥体",-1),qa=o(`<p>我们重点的强调了一下这两个成员函数的这个概念，其实也很简单，总而言之就是 <code>unlock</code> 必须和 <code>lock</code> 的调用次数一样，才会真正解锁互斥量。</p><p>同样的，我们也可以使用 <code>std::lock_guard</code>、<code>std::unique_lock</code> 帮我们管理 <code>std::recursive_mutex</code>，而非显式调用 <code>lock</code> 与 <code>unlock</code>：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">recursive_function</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>recursive_mutex<span class="token operator">&gt;</span> lc<span class="token punctuation">{</span> mtx <span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Locked by thread: &quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;, count: &quot;</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">recursive_function</span><span class="token punctuation">(</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),za={href:"https://godbolt.org/z/d63zrG1cK",target:"_blank",rel:"noopener noreferrer"},Ba=n("h2",{id:"new、delete-是线程安全的吗",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#new、delete-是线程安全的吗"},[n("span",null,[n("code",null,"new"),s("、"),n("code",null,"delete"),s(" 是线程安全的吗？")])])],-1),Aa=n("p",null,[s("如果你的标准达到 "),n("strong",null,"C++11"),s("，要求下列"),n("strong",null,"函数"),s("是线程安全的：")],-1),Ca={href:"https://zh.cppreference.com/w/cpp/memory/new/operator_new",target:"_blank",rel:"noopener noreferrer"},Ma=n("code",null,"new",-1),Da={href:"https://zh.cppreference.com/w/cpp/memory/new/operator_delete",target:"_blank",rel:"noopener noreferrer"},Ta=n("code",null,"delete",-1),Oa=n("strong",null,"库",-1),ja=n("li",null,[s("全局 "),n("code",null,"new"),s(" 运算符和 "),n("code",null,"delete"),s(" 运算符的用户替换版本")],-1),Sa={href:"https://zh.cppreference.com/w/cpp/memory/c/calloc",target:"_blank",rel:"noopener noreferrer"},La={href:"https://zh.cppreference.com/w/cpp/memory/c/malloc",target:"_blank",rel:"noopener noreferrer"},Xa={href:"https://zh.cppreference.com/w/cpp/memory/c/realloc",target:"_blank",rel:"noopener noreferrer"},Fa={href:"https://zh.cppreference.com/w/cpp/memory/c/aligned_alloc",target:"_blank",rel:"noopener noreferrer"},Pa={href:"https://zh.cppreference.com/w/cpp/memory/c/free",target:"_blank",rel:"noopener noreferrer"},Va=o(`<p>所以以下函数在多线程运行是线程安全的：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    T<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内存分配、释放操作是线程安全，构造和析构不涉及共享资源。而局部对象 <code>p</code> 对于每个线程来说是独立的。换句话说，每个线程都有其自己的 <code>p</code> 对象实例，因此它们不会共享同一个对象，自然没有数据竞争。</p><p>如果 <code>p</code> 是全局对象（或者外部的，只要可被多个线程读写），多个线程同时对其进行访问和修改时，就可能会导致数据竞争和未定义行为。因此，确保全局对象的线程安全访问通常需要额外的同步措施，比如互斥量或原子操作。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>T<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    p <span class="token operator">=</span> <span class="token keyword">new</span> T<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 存在数据竞争</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使 <code>p</code> 是局部对象，如果构造函数（析构同理）涉及读写共享资源，那么一样存在数据竞争，需要进行额外的同步措施进行保护。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">X</span><span class="token punctuation">{</span>
    <span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token double-colon punctuation">::</span>n <span class="token operator">+=</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    X<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> X<span class="token punctuation">{</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 存在数据竞争</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),Ia=n("code",null,"std::cout",-1),Ga={href:"https://godbolt.org/z/acT7bcz8E",target:"_blank",rel:"noopener noreferrer"},Ra=o(`<hr><p>值得注意的是，如果是自己重载 <code>operator new</code>、<code>operator delete</code> 替换了库的<strong>全局</strong>版本，那么它的线程安全就要我们来保证。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token comment">// 全局的 new 运算符，替换了库的版本</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span>  <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t count<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码是线程安全的，因为 C++11 保证了 new 运算符的库版本，即 <code>::operator new</code> 是线程安全的，我们直接调用它自然不成问题。如果你需要更多的操作，就得使用互斥量之类的方式保护了。</p><hr><p>总而言之，<code>new</code> 表达式线程安全要考虑三方面：<code>operator new</code>、构造函数、修改指针。</p><p><code>delete</code> 表达式线程安全考虑两方面：<code>operator delete</code>、析构函数。</p><p>C++ 只保证了 <code>operator new</code>、<code>operator delete</code> 这两个方面的线程安全（不包括用户定义的），其它方面就得自己保证了。前面的内容也都提到了。</p><h2 id="线程存储期" tabindex="-1"><a class="header-anchor" href="#线程存储期"><span>线程存储期</span></a></h2>`,9),Ka=n("strong",null,"线程存储期",-1),Na={href:"https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8",target:"_blank",rel:"noopener noreferrer"},Wa=n("em",null,"线程局部存储",-1),Ya={href:"https://zh.cppreference.com/w/cpp/keyword/thread_local",target:"_blank",rel:"noopener noreferrer"},Ja=n("strong",null,[n("code",null,"thread_local")],-1),Qa=o(`<p>以下是一个示例代码，展示了 <code>thread_local</code> 关键字的使用：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> global_counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">thread_local</span> <span class="token keyword">int</span> thread_local_counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">print_counters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;global：&quot;</span> <span class="token operator">&lt;&lt;</span> global_counter<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;thread_local：&quot;</span> <span class="token operator">&lt;&lt;</span> thread_local_counter<span class="token operator">++</span> <span class="token operator">&lt;&lt;</span> <span class="token char">&#39;\\n&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>thread<span class="token punctuation">{</span> print_counters <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread<span class="token punctuation">{</span> print_counters <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),Za={href:"https://godbolt.org/z/ncxTEce7f",target:"_blank",rel:"noopener noreferrer"},Ha=n("strong",null,"运行结果",-1),Ua=o(`<div class="language-txt line-numbers-mode" data-ext="txt" data-title="txt"><pre class="language-txt"><code>global：0
thread_local：0
global：1
thread_local：0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码很好的展示了 <code>thread_local</code> 关键字的使用以及它的作用。每一个线程都有独立的 <code>thread_local_counter</code> 对象，它们不是同一个。</p><hr><p>我知道你会有问题：“那么 C++11 之前呢？”那时开发者通常使用 POSIX 线程（Pthreads）或 Win32 线程的接口，或者依赖各家编译器的扩展。例如：</p>`,4),$a={href:"https://pubs.opengroup.org/onlinepubs/9699919799/",target:"_blank",rel:"noopener noreferrer"},nt=n("strong",null,"POSIX",-1),st=n("code",null,"pthread_key_t",-1),at=n("code",null,"pthread_key_create",-1),tt=n("code",null,"pthread_setspecific",-1),ot=n("code",null,"pthread_getspecific",-1),et=n("code",null,"pthread_key_delete",-1),pt=n("strong",null,"Win32",-1),ct={href:"https://learn.microsoft.com/zh-cn/windows/win32/procthread/using-thread-local-storage",target:"_blank",rel:"noopener noreferrer"},lt=n("code",null,"TlsAlloc",-1),ut=n("code",null,"TlsSetValue",-1),it=n("code",null,"TlsGetValue",-1),dt=n("code",null,"TlsFree",-1),rt=n("strong",null,"GCC",-1),kt={href:"https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/thread-local-storage.html",target:"_blank",rel:"noopener noreferrer"},vt=n("code",null,"__thread",-1),mt=n("strong",null,"MSVC",-1),_t={href:"https://learn.microsoft.com/zh-cn/cpp/cpp/thread?view=msvc-170",target:"_blank",rel:"noopener noreferrer"},bt=n("code",null,"__declspec(thread)",-1),ht=o(`<p>POSIX 与 Win32 接口的就不再介绍了，有兴趣参见我们的链接即可。我们就拿先前的代码改成使用 GCC 与 MSVC 的编译器扩展即可。</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>__thread <span class="token keyword">int</span> thread_local_counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">// GCC</span>
<span class="token function">__declspec</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span> <span class="token keyword">int</span> thread_local_counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// MSVC</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,2),gt=n("code",null,"__thread",-1),ft=n("code",null,"__declspec(thread)",-1),wt={href:"https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fms-extensions",target:"_blank",rel:"noopener noreferrer"},xt=n("code",null,"-fms-extensions",-1),yt={href:"https://godbolt.org/z/eMz8Yz3hv",target:"_blank",rel:"noopener noreferrer"},Et=n("strong",null,[n("code",null,"__declspec(thread)"),s(" 运行测试")],-1),qt={href:"https://godbolt.org/z/Wx6zKhK44",target:"_blank",rel:"noopener noreferrer"},zt=n("strong",null,[n("code",null,"__thread"),s(" 运行测试")],-1),Bt=o('<p>要注意的是，这些扩展并不是标准的 C++ 语言特性，它们的跨平台性和可移植性较差，我们应当使用 C++ 标准的 <code>thread_local</code>。</p><p>了解其它 API 以及编译器扩展有助于理解历史上线程存储期的演进。同时扩展知识面。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>本章讨论了多线程的共享数据引发的恶性条件竞争会带来的问题。并说明了可以使用互斥量（<code>std::mutex</code>）保护共享数据，并且要注意互斥量上锁的“<strong>粒度</strong>”。C++标准库提供了很多工具，包括管理互斥量的管理类（<code>std::lock_guard</code>），但是互斥量只能解决它能解决的问题，并且它有自己的问题（<strong>死锁</strong>）。同时我们讲述了一些避免死锁的方法和技术。还讲了一下互斥量所有权转移。然后讨论了面对不同情况保护共享数据的不同方式，使用 <code>std::call_once()</code> 保护共享数据的初始化过程，使用读写锁（<code>std::shared_mutex</code>）保护不常更新的数据结构。以及特殊情况可能用到的互斥量 <code>recursive_mutex</code>，有些人可能喜欢称作：<strong>递归锁</strong>。最后聊了一下 <code>new</code>、<code>delete</code> 运算符的库函数实际是线程安全的，以及线程存储期。</p>',4),At={href:"https://zh.cppreference.com/w/cpp/thread#.E6.9C.AA.E6.9D.A5.E4.BD.93",target:"_blank",rel:"noopener noreferrer"},Ct=n("strong",null,"Futures",-1),Mt={href:"https://zh.cppreference.com/w/cpp/thread#.E6.9D.A1.E4.BB.B6.E5.8F.98.E9.87.8F",target:"_blank",rel:"noopener noreferrer"},Dt=n("strong",null,"条件变量",-1),Tt=n("hr",{class:"footnotes-sep"},null,-1),Ot={class:"footnotes"},jt={class:"footnotes-list"},St={id:"footnote1",class:"footnote-item"},Lt={href:"https://zh.wikipedia.org/wiki/%E8%87%A8%E7%95%8C%E5%8D%80%E6%AE%B5",target:"_blank",rel:"noopener noreferrer"},Xt=n("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1);function Ft(Pt,Vt){const t=e("ExternalLinkIcon"),p=e("RouteLink");return l(),u("div",null,[r,n("blockquote",null,[n("p",null,[n("a",k,[v,a(t)]),s(" 的 operator<< 调用是线程安全的，不会被打断。即："),m])]),_,n("p",null,[s("而且即使不是一个添加元素，一个删除元素，全是 "),b,s(" 添加元素，也一样会有问题，由于 std::vector 不是线程安全的容器，因此当多个线程同时访问并修改 v 时，可能会发生"),n("a",h,[g,a(t)]),s("。具体来说，当两个线程同时尝试向 v 中添加元素时，但是 "),f,s(" 函数却是可以被打断的，执行了一半，又去执行另一个线程。可能会导致数据竞争，从而引发"),w,s("的结果。")]),x,n("p",null,[s("标量类型等都同理，有"),y,s("，"),n("a",E,[q,a(t)]),s("：")]),z,n("p",null,[s("这段代码你多次"),n("a",B,[s("运行"),a(t)]),s("它会得到毫无规律和格式的结果，我们可以使用"),n("a",A,[s("互斥量"),a(t)]),s("解决这个问题：")]),C,n("p",null,[s("不过一般不推荐这样显式的 "),M,s(" 与 "),D,s("，我们可以使用 C++11 标准库引入的“管理类” "),n("a",T,[O,a(t)]),s("：")]),j,n("p",null,[s("那么问题来了，"),S,s(" 是如何做到的呢？它是怎么实现的呢？首先顾名思义，这是一个“管理类”模板，用来管理互斥量的上锁与解锁，我们来看它在 "),n("a",L,[s("MSVC STL"),a(t)]),s(" 的实现：")]),X,n("p",null,[s("这段代码极其简单，首先管理类，自然不可移动不可复制，我们定义复制构造与复制赋值为"),n("a",F,[s("弃置函数"),a(t)]),s("，同时"),n("a",P,[s("阻止"),a(t)]),s("了移动等函数的隐式定义。")]),V,I,n("p",null,[s("同时它还提供一个有额外"),n("a",G,[R,a(t)]),s("参数的构造函数 ，如果使用这个构造函数，则构造函数不会上锁。")]),K,n("blockquote",null,[n("p",null,[s("完整"),n("a",N,[s("代码测试"),a(t)]),s("。")])]),W,n("p",null,[s("C++17 添加了一个新的特性，"),n("a",Y,[s("类模板实参推导"),a(t)]),s("， "),J,s(" 可以根据传入的参数自行推导，而不需要写明模板类型参数：")]),Q,n("p",null,[s("并且 C++17 还引入了一个新的“管理类”："),n("a",Z,[H,a(t)]),s("，它相较于 "),U,s("的区别在于，"),$,s("。不过对于处理一个互斥量的情况，它和 "),nn,s(" 几乎完全相同。")]),sn,n("p",null,[s("可能的"),n("a",an,[tn,a(t)]),s("：")]),on,n("blockquote",null,[n("p",null,[s("简而言之，有可能函数 f 锁定了 m1，函数 f2 锁定了 m2，函数 f 要往下执行，给 m2 上锁，所以在等待 f2 解锁 m2，然而函数 f2 也在等待函数 f 解锁 m1 它才能往下执行。所以死锁。"),n("a",en,[s("测试代码"),a(t)]),s("。")])]),pn,n("blockquote",null,[n("p",null,[s("完全可能线程 A 执行 1 的时候上锁了 a 的互斥量，线程 B 执行 "),cn,s(" 上锁了 b 的互斥量。线程 A 往下执行需要上锁 b 的互斥量，线程 B 则要上锁 a 的互斥量执行完毕才能解锁，哪个都没办法往下执行，"),ln,s("。"),n("a",un,[s("测试代码"),a(t)]),s("。")])]),dn,n("p",null,[s("C++ 标准库有很多办法解决这个问题，"),n("strong",null,[s("可以使用 "),n("a",rn,[kn,a(t)])]),s(" ，它能一次性锁住多个互斥量，并且没有死锁风险。修改 swap 代码后如下：")]),vn,n("p",null,[s("C++17 新增了 "),n("a",mn,[_n,a(t)]),s(" ，提供此函数的 "),n("a",bn,[s("RAII"),a(t)]),s(" 包装，通常它比裸调用 "),hn,s(" 更好。")]),gn,n("p",null,[s("对此类有兴趣或任何疑问，建议阅读"),a(p,{to:"/md/%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/02scoped_lock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"},{default:i(()=>[fn]),_:1})]),wn,n("p",null,[n("a",xn,[yn,a(t)]),s(" 是 C++11 引入的一种通用互斥包装器，它相比于 "),En,s(" 更加的灵活。当然，它也更加的复杂，尤其它还可以与我们下一章要讲的"),n("a",qn,[s("条件变量"),a(t)]),s("一起使用。使用它可以将之前使用 "),zn,s(" 的 "),Bn,s(" 改写一下：")]),An,n("p",null,[s("解释这段代码最简单的方式就是直接展示标准库的源码，首先，我们要了解 "),Cn,s(" 是“不获得互斥体的所有权”。没有所有权自然构造函数就不会上锁，但不止如此。我们还要先知道 std::unique_lock 保有的数据成员（都以 "),n("a",Mn,[s("MSVC STL"),a(t)]),s(" 为例）：")]),Dn,n("p",null,[s("如你所见，只是初始化了数据成员而已，注意，"),Tn,s("。并且 "),On,s(" 是有 "),n("a",jn,[Sn,a(t)]),s(" 、"),n("a",Ln,[Xn,a(t)]),s(" 、"),n("a",Fn,[Pn,a(t)]),s(" 成员函数的，所以可以直接传递给 "),Vn,s("、 进行调用。这里还需要提一下 "),In,s(" 成员函数的代码：")]),Gn,n("p",null,[s("这段代码运行会"),n("a",Rn,[s("抛出异常"),a(t)]),s("，原因很简单，因为 "),Kn,s(" 只是不上锁，但是"),Nn,s("，即 "),Wn,s(" 设置为 "),Yn,s(" 了，当运行 "),Jn,s(" 成员函数的时候，调用了 "),Qn,s(" 进行检测，也就是：")]),Zn,n("p",null,[s("满足第二个 if，因为 "),Hn,s(" 为 "),Un,s(" 所以抛出异常，别的标准库也都有"),n("a",$n,[s("类似设计"),a(t)]),s("。很诡异的设计对吧，正常。除非我们写成：")]),ns,n("p",null,[s("首先我们要明白，互斥量满足"),n("a",ss,[as,a(t)]),s("的要求，"),ts,s("。所谓的在不同作用域传递互斥量，其实只是传递了它们的指针或者引用罢了。可以利用各种类来进行传递，比如前面提到的 "),os,s("。")]),n("p",null,[es,s(" 可以获取互斥量的所有权，而互斥量的所有权可以通过移动操作转移给其他的 "),ps,s(" 对象。有些时候，这种转移（"),cs,s("）是自动发生的，比如当"),n("a",ls,[s("函数返回"),a(t)]),s(),us,s(" 对象。另一种情况就是得显式使用 "),n("a",is,[ds,a(t)]),s("。")]),rs,n("p",null,[s("我相信你可能对 "),ks,s(" 有疑问，其实不用感到奇怪，这是一个互斥量的声明，可能别的翻译单元（或 dll 等）有它的定义，成功链接上。我们前面也说了：“"),vs,s("”，所以"),n("strong",null,[s("要特别注意互斥量的"),n("a",ms,[s("生存期"),a(t)])]),s("。")]),n("blockquote",null,[n("p",null,[s("extern 说明符只能搭配变量声明和函数声明（除了类成员或函数形参）。"),n("em",null,[s("它指定外部链接，而且技术上不影响存储期，但它不能用来定义自动存储期的对象，故所有 extern 对象都具有"),n("strong",null,[s("静态或线程"),n("a",_s,[s("存储期"),a(t)]),s("。")])])])]),bs,n("blockquote",null,[n("p",null,[s("举一个使用 "),hs,s(" 的完整"),n("a",gs,[s("运行示例"),a(t)]),s("。当然，其实理论上你 "),fs,s(" 也是完全可行...... 🤣🤣")])]),ws,n("ol",null,[xs,n("li",null,[n("p",null,[s("C++ 标准委员会也认为处理此问题很重要，"),n("strong",null,[s("所以标准库提供了 "),n("a",ys,[Es,a(t)]),s(" 和 "),n("a",qs,[zs,a(t)])]),s(" 来处理这种情况。比起锁住互斥量并显式检查指针，每个线程只需要使用 "),Bs,s(" 就可以。"),As,s("。")]),Cs,n("p",null,[s("以上代码 "),Ms,s(" 对象是全局命名空间作用域声明，如果你有需要，它也可以是类的成员。用于搭配 "),Ds,s(" 使用，保证线程安全的"),Ts,s("初始化。"),Os,s(" 只需要接受"),n("a",js,[Ss,a(t)]),s("对象即可，也不要求一定是函数。")]),n("blockquote",null,[Ls,n("p",null,[n("a",Xs,[s("测试链接"),a(t)]),s("。正常情况会保证传入的可调用对象只调用一次，即初始化只有一次。异常之类的是例外。")])])]),Fs]),Ps,Vs,Is,Gs,n("p",null,[s("然而使用 "),Rs,s(" 的开销是过大的，它不管有没有发生数据竞争（也就是就算全是读的情况）也必须是老老实实上锁解锁，只有一个线程可以运行。如果你学过其它语言或者操作系统，相信这个时候就已经想到了：“"),n("a",Ks,[Ns,a(t)]),s("”。")]),n("p",null,[s("C++ 标准库自然为我们提供了： "),n("a",Ws,[Ys,a(t)]),s("（C++14）、 "),n("a",Js,[Qs,a(t)]),s("（C++17）。它们的区别简单来说，前者支持更多的操作方式，后者有更高的性能优势。")]),n("p",null,[Zs,s(" 同样支持 "),Hs,s("、"),Us,s("。和 "),$s,s(" 做的一样，保证"),na,s("的独占访问。"),n("strong",null,[s("而那些无需修改数据结构的"),sa,s("，可以使用 "),n("a",aa,[ta,a(t)]),s(" 获取访问权")]),s("，多个线程可以一起读取。")]),oa,n("blockquote",null,[n("p",null,[n("a",ea,[s("完整代码"),a(t)]),s("。"),n("a",pa,[s("测试"),a(t)]),s("链接。标准输出可能交错，但无数据竞争。")])]),ca,la,n("p",null,[s("线程对已经上锁的 "),ua,s(" 再次上锁是错误的，这是"),n("a",ia,[da,a(t)]),s("。然而在某些情况下，一个线程会尝试在释放一个互斥量前多次获取，所以提供了"),ra,s("。")]),ka,n("blockquote",null,[n("p",null,[n("a",va,[s("运行"),a(t)]),s("测试。")])]),n("ul",null,[n("li",null,[n("p",null,[n("a",ma,[_a,a(t)]),s("：线程可以在递归互斥体上重复调用 "),ba,s("。在线程调用 "),ha,s(" 匹配次数后，所有权才会得到"),ga,s("。")])]),n("li",null,[n("p",null,[n("a",fa,[wa,a(t)]),s("：若所有权层数为 1（此线程对 "),n("a",xa,[s("lock()"),a(t)]),s(" 的调用恰好比 "),ya,s(" 多一次 ）则"),Ea,s("，否则将所有权层数减少 1。")])])]),qa,n("blockquote",null,[n("p",null,[n("a",za,[s("运行"),a(t)]),s("测试。")])]),Ba,Aa,n("ul",null,[n("li",null,[n("a",Ca,[Ma,s(" 运算符"),a(t)]),s("和 "),n("a",Da,[Ta,s(" 运算符"),a(t)]),s("的"),Oa,s("版本")]),ja,n("li",null,[n("a",Sa,[s("std::calloc"),a(t)]),s("、"),n("a",La,[s("std::malloc"),a(t)]),s("、"),n("a",Xa,[s("std::realloc"),a(t)]),s("、"),n("a",Fa,[s("std::aligned_alloc"),a(t)]),s(" (C++17 起)、"),n("a",Pa,[s("std::free"),a(t)])])]),Va,n("blockquote",null,[n("p",null,[s("一个直观的展示是，我们可以在构造函数中使用 "),Ia,s("，看到无序的输出，"),n("a",Ga,[s("例子"),a(t)]),s("。")])]),Ra,n("p",null,[Ka,s("（也有人喜欢称作“"),n("a",Na,[Wa,a(t)]),s("”）的概念源自操作系统，是一种非常古老的机制，广泛应用于各种编程语言。线程存储期的对象在线程开始时分配，并在线程结束时释放。每个线程拥有自己独立的对象实例，互不干扰。在 C++11中，引入了"),n("a",Ya,[Ja,a(t)]),s("关键字，用于声明具有线程存储期的对象。")]),Qa,n("p",null,[n("a",Za,[Ha,a(t)]),s("：")]),Ua,n("ul",null,[n("li",null,[n("a",$a,[nt,a(t)]),s("：使用 "),st,s(" 和相关的函数（ "),at,s("、"),tt,s("、"),ot,s(" 和"),et,s("）来管理线程局部存储。")]),n("li",null,[pt,s("：使用 "),n("a",ct,[s("TLS（Thread Local Storage）"),a(t)]),s("机制，通过函数 "),lt,s("、"),ut,s("、"),it,s(" 和 "),dt,s(" 来实现线程局部存储。")]),n("li",null,[rt,s("：使用 "),n("a",kt,[vt,a(t)]),s(" 。")]),n("li",null,[mt,s("：使用 "),n("a",_t,[bt,a(t)]),s("。")])]),ht,n("p",null,[s("MSVC 无法使用 GCC 的编译器扩展，GCC 也肯定无法使用 MSVC 的扩展，不过 Clang 编译器可以，它支持 "),gt,s(" 与 "),ft,s(" 两种。Clang 默认情况就支持 GCC 的编译器扩展，如果要支持 MSVC，需要设置 "),n("a",wt,[xt,a(t)]),s(" 编译选项。")]),n("ul",null,[n("li",null,[n("a",yt,[Et,a(t)])]),n("li",null,[n("a",qt,[zt,a(t)])])]),Bt,n("p",null,[s("下一章，我们将开始讲述同步操作，会使用到 "),n("a",At,[Ct,a(t)]),s("、"),n("a",Mt,[Dt,a(t)]),s("等设施。")]),Tt,n("section",Ot,[n("ol",jt,[n("li",St,[n("p",null,[s('"'),n("em",null,[n("strong",null,[n("a",Lt,[s("临界区"),a(t)])])]),s('"指的是一个访问共享资源的程序片段，而这些共享资源又无法同时被多个线程访问的特性。在临界区中，通常会使用同步机制，比如我们要讲的互斥量（Mutex）。 '),Xt])])])])])}const Rt=c(d,[["render",Ft],["__file","03共享数据.html.vue"]]),Kt=JSON.parse('{"path":"/md/03%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE.html","title":"共享数据","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"条件竞争","slug":"条件竞争","link":"#条件竞争","children":[]},{"level":2,"title":"使用互斥量","slug":"使用互斥量","link":"#使用互斥量","children":[{"level":3,"title":"std::lock_guard","slug":"std-lock-guard","link":"#std-lock-guard","children":[]},{"level":3,"title":"try_lock","slug":"try-lock","link":"#try-lock","children":[]}]},{"level":2,"title":"保护共享数据","slug":"保护共享数据","link":"#保护共享数据","children":[]},{"level":2,"title":"死锁：问题与解决","slug":"死锁-问题与解决","link":"#死锁-问题与解决","children":[]},{"level":2,"title":"std::unique_lock 灵活的锁","slug":"std-unique-lock-灵活的锁","link":"#std-unique-lock-灵活的锁","children":[]},{"level":2,"title":"在不同作用域传递互斥量","slug":"在不同作用域传递互斥量","link":"#在不同作用域传递互斥量","children":[]},{"level":2,"title":"保护共享数据的初始化过程","slug":"保护共享数据的初始化过程","link":"#保护共享数据的初始化过程","children":[]},{"level":2,"title":"保护不常更新的数据结构","slug":"保护不常更新的数据结构","link":"#保护不常更新的数据结构","children":[]},{"level":2,"title":"std::recursive_mutex","slug":"std-recursive-mutex","link":"#std-recursive-mutex","children":[]},{"level":2,"title":"new、delete 是线程安全的吗？","slug":"new、delete-是线程安全的吗","link":"#new、delete-是线程安全的吗","children":[]},{"level":2,"title":"线程存储期","slug":"线程存储期","link":"#线程存储期","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1710730998000,"updatedTime":1716626910000,"contributors":[{"name":"归故里","email":"3326284481@qq.com","commits":28},{"name":"mq白","email":"3326284481@qq.com","commits":4},{"name":"A. Jiang","email":"de34@live.cn","commits":3},{"name":"LeeZQXML","email":"2919625053@qq.com","commits":2}]},"readingTime":{"minutes":34.21,"words":10263},"filePathRelative":"md/03共享数据.md","localizedDate":"2024年3月18日","excerpt":"\\n<p>本章节主要内容：</p>\\n<ul>\\n<li>\\n<p>多线程共享数据的问题</p>\\n</li>\\n<li>\\n<p>使用互斥量保护共享数据</p>\\n</li>\\n<li>\\n<p>保护共享数据的其它方案</p>\\n</li>\\n</ul>\\n<p>在上一章内容，我们对于线程的基本使用和管理，可以说已经比较了解了，甚至深入阅读了部分的 <code>std::thread</code> 源码。所以如果你好好学习了上一章，本章也完全不用担心。</p>\\n<p>我们本章，就要开始聊共享数据的那些事。</p>\\n<h2>条件竞争</h2>\\n<p>在多线程的情况下，每个线程都抢着完成自己的任务。在大多数情况下，即使会改变执行顺序，也是良性竞争，这是无所谓的。比如两个线程都要往标准输出输出一段字符，谁先谁后并不会有什么太大影响。</p>"}');export{Rt as comp,Kt as data};
